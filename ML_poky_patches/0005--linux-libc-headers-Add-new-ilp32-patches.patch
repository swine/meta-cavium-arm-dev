From 98ec93f66101c416cd1591eee9925789a669361f Mon Sep 17 00:00:00 2001
From: Manish Jaggi <mjaggi@cavium.com>
Date: Tue, 4 Apr 2017 02:53:22 -0700
Subject: [PATCH 1/2] linux-libc-headers: Add new ilp32 patches

ILP32 kernel patches with fixes for syscalls

Signed-off-by: Manish Jaggi <mjaggi@cavium.com>
---
 .../linux-libc-headers/ilp32_4_4_patches.inc       |  45 +-
 ...01-all-syscall-wrappers-add-documentation.patch |  56 --
 ...use-non-compat-openat-and-open_by_handle_.patch |  59 ++
 ...-introduce-ARCH_32BIT_OFF_T-config-option.patch | 376 +++++++++
 ...ce-COMPAT_WRAPPER-option-and-enable-it-fo.patch |  42 -
 ...ve-wrapper-infrastructure-to-generic-head.patch | 351 ---------
 ...-Drop-getrlimit-and-setrlimit-syscalls-fr.patch | 215 +++++
 ...ve-compat_wrappers.c-from-arch-s390-kerne.patch | 335 --------
 ...-add-documentation-on-the-ILP32-ABI-for-A.patch |  68 ++
 ...ll-wrap-needed-syscalls-in-generic-unistd.patch | 866 ---------------------
 ...4-rename-COMPAT-to-AARCH32_EL0-in-Kconfig.patch | 425 ++++++++++
 ...64-ensure-the-kernel-is-compiled-for-LP64.patch |  47 ++
 ...use-non-compat-openat-and-open_by_handle_.patch |  35 -
 ...-introduce-ARCH_32BIT_OFF_T-config-option.patch | 376 ---------
 ...set-__BITS_PER_LONG-correctly-for-ILP32-a.patch |  42 +
 ...-add-documentation-on-the-ILP32-ABI-for-A.patch |  48 --
 ...e-thread-bits-accessors-to-separated-file.patch | 144 ++++
 ...64-ensure-the-kernel-is-compiled-for-LP64.patch |  47 --
 ...troduce-is_a32_task-and-is_a32_thread-for.patch | 444 +++++++++++
 ...-add-is_ilp32_compat_-task-thread-and-TIF.patch | 129 +++
 ...4-rename-COMPAT-to-AARCH32_EL0-in-Kconfig.patch | 423 ----------
 .../0011-arm64-introduce-binfmt_elf32.c.patch      | 130 ++++
 ...set-__BITS_PER_LONG-correctly-for-ILP32-a.patch |  42 -
 ...0012-arm64-ilp32-introduce-binfmt_ilp32.c.patch | 135 ++++
 ...e-thread-bits-accessors-to-separated-file.patch | 145 ----
 ...rm64-ilp32-share-aarch32-syscall-handlers.patch | 233 ++++++
 ...duce-is_a32_task-and-is_a32_thread-for-AA.patch | 450 -----------
 ...-add-is_ilp32_compat_-task-thread-and-TIF.patch | 121 ---
 ...-add-sys_ilp32.c-and-a-separate-table-in-.patch | 250 ++++++
 .../0015-arm64-introduce-binfmt_elf32.c.patch      | 141 ----
 ...ignal-share-lp64-signal-routines-to-ilp32.patch | 241 ++++++
 ...0016-arm64-ilp32-introduce-binfmt_ilp32.c.patch | 126 ---
 ...l32-move-ilp32-and-aarch32-common-code-to.patch | 339 ++++++++
 ...-introduce-ilp32-specific-handlers-for-si.patch | 309 ++++++++
 ...e-handle-ptrace_request-differently-for-a.patch | 189 -----
 ...-add-sys_ilp32.c-and-a-separate-table-in-.patch | 183 -----
 ...e-handle-ptrace_request-differently-for-a.patch | 119 +++
 ...-add-vdso-ilp32-and-use-for-signal-return.patch | 558 +++++++++++++
 ...ignal-share-lp64-signal-routines-to-ilp32.patch | 239 ------
 ...20-arm64-ilp32-add-ARM64_ILP32-to-Kconfig.patch |  47 ++
 ...l32-move-ilp32-and-aarch32-common-code-to.patch | 278 -------
 ...-introduce-ilp32-specific-handlers-for-si.patch | 343 --------
 ...-add-vdso-ilp32-and-use-for-signal-return.patch | 540 -------------
 ...23-arm64-ilp32-add-ARM64_ILP32-to-Kconfig.patch |  54 --
 .../0024-fiz-set_personality-by-Catalin.patch      |  47 --
 45 files changed, 4331 insertions(+), 5501 deletions(-)
 delete mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0001-all-syscall-wrappers-add-documentation.patch
 create mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0001-compat-ABI-use-non-compat-openat-and-open_by_handle_.patch
 create mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0002-32-bit-ABI-introduce-ARCH_32BIT_OFF_T-config-option.patch
 delete mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0002-all-introduce-COMPAT_WRAPPER-option-and-enable-it-fo.patch
 delete mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0003-all-s390-move-wrapper-infrastructure-to-generic-head.patch
 create mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0003-asm-generic-Drop-getrlimit-and-setrlimit-syscalls-fr.patch
 delete mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0004-all-s390-move-compat_wrappers.c-from-arch-s390-kerne.patch
 create mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0004-arm64-ilp32-add-documentation-on-the-ILP32-ABI-for-A.patch
 delete mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0005-all-wrap-needed-syscalls-in-generic-unistd.patch
 create mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0005-arm64-rename-COMPAT-to-AARCH32_EL0-in-Kconfig.patch
 create mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0006-arm64-ensure-the-kernel-is-compiled-for-LP64.patch
 delete mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0006-compat-ABI-use-non-compat-openat-and-open_by_handle_.patch
 delete mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0007-32-bit-ABI-introduce-ARCH_32BIT_OFF_T-config-option.patch
 create mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0007-arm64-uapi-set-__BITS_PER_LONG-correctly-for-ILP32-a.patch
 delete mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0008-arm64-ilp32-add-documentation-on-the-ILP32-ABI-for-A.patch
 create mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0008-thread-move-thread-bits-accessors-to-separated-file.patch
 delete mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0009-arm64-ensure-the-kernel-is-compiled-for-LP64.patch
 create mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0009-arm64-introduce-is_a32_task-and-is_a32_thread-for.patch
 create mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0010-arm64-ilp32-add-is_ilp32_compat_-task-thread-and-TIF.patch
 delete mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0010-arm64-rename-COMPAT-to-AARCH32_EL0-in-Kconfig.patch
 create mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0011-arm64-introduce-binfmt_elf32.c.patch
 delete mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0011-arm64-uapi-set-__BITS_PER_LONG-correctly-for-ILP32-a.patch
 create mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0012-arm64-ilp32-introduce-binfmt_ilp32.c.patch
 delete mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0012-thread-move-thread-bits-accessors-to-separated-file.patch
 create mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0013-arm64-ilp32-share-aarch32-syscall-handlers.patch
 delete mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0013-arm64-introduce-is_a32_task-and-is_a32_thread-for-AA.patch
 delete mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0014-arm64-ilp32-add-is_ilp32_compat_-task-thread-and-TIF.patch
 create mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0014-arm64-ilp32-add-sys_ilp32.c-and-a-separate-table-in-.patch
 delete mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0015-arm64-introduce-binfmt_elf32.c.patch
 create mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0015-arm64-signal-share-lp64-signal-routines-to-ilp32.patch
 delete mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0016-arm64-ilp32-introduce-binfmt_ilp32.c.patch
 create mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0016-arm64-signal32-move-ilp32-and-aarch32-common-code-to.patch
 create mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0017-arm64-ilp32-introduce-ilp32-specific-handlers-for-si.patch
 delete mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0017-arm64-ptrace-handle-ptrace_request-differently-for-a.patch
 delete mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0018-arm64-ilp32-add-sys_ilp32.c-and-a-separate-table-in-.patch
 create mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0018-arm64-ptrace-handle-ptrace_request-differently-for-a.patch
 create mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0019-arm64-ilp32-add-vdso-ilp32-and-use-for-signal-return.patch
 delete mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0019-arm64-signal-share-lp64-signal-routines-to-ilp32.patch
 create mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0020-arm64-ilp32-add-ARM64_ILP32-to-Kconfig.patch
 delete mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0020-arm64-signal32-move-ilp32-and-aarch32-common-code-to.patch
 delete mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0021-arm64-ilp32-introduce-ilp32-specific-handlers-for-si.patch
 delete mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0022-arm64-ilp32-add-vdso-ilp32-and-use-for-signal-return.patch
 delete mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0023-arm64-ilp32-add-ARM64_ILP32-to-Kconfig.patch
 delete mode 100644 meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0024-fiz-set_personality-by-Catalin.patch

diff --git a/meta/recipes-kernel/linux-libc-headers/ilp32_4_4_patches.inc b/meta/recipes-kernel/linux-libc-headers/ilp32_4_4_patches.inc
index 667e10c..9e6ad5d 100644
--- a/meta/recipes-kernel/linux-libc-headers/ilp32_4_4_patches.inc
+++ b/meta/recipes-kernel/linux-libc-headers/ilp32_4_4_patches.inc
@@ -1,24 +1,21 @@
-SRC_URI += "file://ilp32_4_4/0001-all-syscall-wrappers-add-documentation.patch"
-SRC_URI += "file://ilp32_4_4/0002-all-introduce-COMPAT_WRAPPER-option-and-enable-it-fo.patch"
-SRC_URI += "file://ilp32_4_4/0003-all-s390-move-wrapper-infrastructure-to-generic-head.patch"
-SRC_URI += "file://ilp32_4_4/0004-all-s390-move-compat_wrappers.c-from-arch-s390-kerne.patch"
-SRC_URI += "file://ilp32_4_4/0005-all-wrap-needed-syscalls-in-generic-unistd.patch"
-SRC_URI += "file://ilp32_4_4/0006-compat-ABI-use-non-compat-openat-and-open_by_handle_.patch"
-SRC_URI += "file://ilp32_4_4/0007-32-bit-ABI-introduce-ARCH_32BIT_OFF_T-config-option.patch"
-SRC_URI += "file://ilp32_4_4/0008-arm64-ilp32-add-documentation-on-the-ILP32-ABI-for-A.patch"
-SRC_URI += "file://ilp32_4_4/0009-arm64-ensure-the-kernel-is-compiled-for-LP64.patch"
-SRC_URI += "file://ilp32_4_4/0010-arm64-rename-COMPAT-to-AARCH32_EL0-in-Kconfig.patch"
-SRC_URI += "file://ilp32_4_4/0011-arm64-uapi-set-__BITS_PER_LONG-correctly-for-ILP32-a.patch"
-SRC_URI += "file://ilp32_4_4/0012-thread-move-thread-bits-accessors-to-separated-file.patch"
-SRC_URI += "file://ilp32_4_4/0013-arm64-introduce-is_a32_task-and-is_a32_thread-for-AA.patch"
-SRC_URI += "file://ilp32_4_4/0014-arm64-ilp32-add-is_ilp32_compat_-task-thread-and-TIF.patch"
-SRC_URI += "file://ilp32_4_4/0015-arm64-introduce-binfmt_elf32.c.patch"
-SRC_URI += "file://ilp32_4_4/0016-arm64-ilp32-introduce-binfmt_ilp32.c.patch"
-SRC_URI += "file://ilp32_4_4/0017-arm64-ptrace-handle-ptrace_request-differently-for-a.patch"
-SRC_URI += "file://ilp32_4_4/0018-arm64-ilp32-add-sys_ilp32.c-and-a-separate-table-in-.patch"
-SRC_URI += "file://ilp32_4_4/0019-arm64-signal-share-lp64-signal-routines-to-ilp32.patch"
-SRC_URI += "file://ilp32_4_4/0020-arm64-signal32-move-ilp32-and-aarch32-common-code-to.patch"
-SRC_URI += "file://ilp32_4_4/0021-arm64-ilp32-introduce-ilp32-specific-handlers-for-si.patch"
-SRC_URI += "file://ilp32_4_4/0022-arm64-ilp32-add-vdso-ilp32-and-use-for-signal-return.patch"
-SRC_URI += "file://ilp32_4_4/0023-arm64-ilp32-add-ARM64_ILP32-to-Kconfig.patch"
-SRC_URI += "file://ilp32_4_4/0024-fiz-set_personality-by-Catalin.patch"
+SRC_URI += "file://ilp32_test/0001-compat-ABI-use-non-compat-openat-and-open_by_handle_.patch"
+SRC_URI += "file://ilp32_test/0002-32-bit-ABI-introduce-ARCH_32BIT_OFF_T-config-option.patch"
+SRC_URI += "file://ilp32_test/0003-asm-generic-Drop-getrlimit-and-setrlimit-syscalls-fr.patch"
+SRC_URI += "file://ilp32_test/0004-arm64-ilp32-add-documentation-on-the-ILP32-ABI-for-A.patch"
+SRC_URI += "file://ilp32_test/0005-arm64-rename-COMPAT-to-AARCH32_EL0-in-Kconfig.patch"
+SRC_URI += "file://ilp32_test/0006-arm64-ensure-the-kernel-is-compiled-for-LP64.patch"
+SRC_URI += "file://ilp32_test/0007-arm64-uapi-set-__BITS_PER_LONG-correctly-for-ILP32-a.patch"
+SRC_URI += "file://ilp32_test/0008-thread-move-thread-bits-accessors-to-separated-file.patch"
+SRC_URI += "file://ilp32_test/0009-arm64-introduce-is_a32_task-and-is_a32_thread-for.patch"
+SRC_URI += "file://ilp32_test/0010-arm64-ilp32-add-is_ilp32_compat_-task-thread-and-TIF.patch"
+SRC_URI += "file://ilp32_test/0011-arm64-introduce-binfmt_elf32.c.patch"
+SRC_URI += "file://ilp32_test/0012-arm64-ilp32-introduce-binfmt_ilp32.c.patch"
+SRC_URI += "file://ilp32_test/0013-arm64-ilp32-share-aarch32-syscall-handlers.patch"
+SRC_URI += "file://ilp32_test/0014-arm64-ilp32-add-sys_ilp32.c-and-a-separate-table-in-.patch"
+SRC_URI += "file://ilp32_test/0015-arm64-signal-share-lp64-signal-routines-to-ilp32.patch"
+SRC_URI += "file://ilp32_test/0016-arm64-signal32-move-ilp32-and-aarch32-common-code-to.patch"
+SRC_URI += "file://ilp32_test/0017-arm64-ilp32-introduce-ilp32-specific-handlers-for-si.patch"
+SRC_URI += "file://ilp32_test/0018-arm64-ptrace-handle-ptrace_request-differently-for-a.patch"
+SRC_URI += "file://ilp32_test/0019-arm64-ilp32-add-vdso-ilp32-and-use-for-signal-return.patch"
+SRC_URI += "file://ilp32_test/0020-arm64-ilp32-add-ARM64_ILP32-to-Kconfig.patch"
+
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0001-all-syscall-wrappers-add-documentation.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0001-all-syscall-wrappers-add-documentation.patch
deleted file mode 100644
index c4b2350..0000000
--- a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0001-all-syscall-wrappers-add-documentation.patch
+++ /dev/null
@@ -1,56 +0,0 @@
-From c7d4fd3d84054559f8de77b8a98caf3c51260060 Mon Sep 17 00:00:00 2001
-From: Yury Norov <ynorov@caviumnetworks.com>
-Date: Tue, 24 May 2016 03:04:30 +0300
-Subject: [PATCH 01/24] all: syscall wrappers: add documentation
-
-Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
----
- Documentation/adding-syscalls.txt | 32 ++++++++++++++++++++++++++++++++
- 1 file changed, 32 insertions(+)
-
-diff --git a/Documentation/adding-syscalls.txt b/Documentation/adding-syscalls.txt
-index cc2d4ac..d02a6bd 100644
---- a/Documentation/adding-syscalls.txt
-+++ b/Documentation/adding-syscalls.txt
-@@ -341,6 +341,38 @@ To summarize, you need:
-  - instance of __SC_COMP not __SYSCALL in include/uapi/asm-generic/unistd.h
- 
- 
-+Compatibility System Calls Wrappers
-+--------------------------------
-+
-+Some architectures prevent 32-bit userspace from access to top halves of 64-bit
-+registers, but some not. It's not a problem if specific argument is the same
-+size in kernel and userspace. It also is not a problem if system call is already
-+handled by compatible routine. Otherwise we'd take care of it. Usually, glibc
-+and compiler handles register's top halve, but from kernel side, we cannot rely
-+on it, as malicious code may cause incorrect behaviour and/or security
-+vulnerabilities.
-+
-+For now, only s390 and arm64/ilp32 are affected.
-+
-+To clear that top halves, automatic wrappers are introduced. They clear all
-+required registers before passing control to regular syscall handler.
-+
-+If your architecture allows userspace code to access top halves of register,
-+you need to:
-+ - enable COMPAT_WRAPPER in configuration file;
-+ - declare: "#define __SC_WRAP(nr, sym) [nr] = compat_##sym,", just before
-+   compatible syscall table declaration, if you use generic unistd; or
-+ - declare compat wrappers manually, if you use non-generic syscall table.
-+   The list of unsafe syscalls is in kernel/compat_wrapper.
-+
-+If you write new syscall, make sure, its arguments are the same size in both
-+64- and 32-bits modes. If no, and if there's no explicit compat version for
-+syscall handler, you need to:
-+ - declare compat version prototype in 'include/linux/compat.h';
-+ - in 'include/uapi/asm-generic/unistd.h' declare syscall with macro '__SC_WRAP'
-+   instead of '__SYSCALL';
-+ - add corresponding line to 'kernel/compat_wrapper.c' to let it generate wrapper.
-+
- Compatibility System Calls (x86)
- --------------------------------
- 
--- 
-1.9.1
-
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0001-compat-ABI-use-non-compat-openat-and-open_by_handle_.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0001-compat-ABI-use-non-compat-openat-and-open_by_handle_.patch
new file mode 100644
index 0000000..50de6f3
--- /dev/null
+++ b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0001-compat-ABI-use-non-compat-openat-and-open_by_handle_.patch
@@ -0,0 +1,59 @@
+From bcd91f4dfb229fc80c3fea6346bfd3948b464bf0 Mon Sep 17 00:00:00 2001
+From: Yury Norov <ynorov@caviumnetworks.com>
+Date: Tue, 29 Dec 2015 12:26:34 +0300
+Subject: [PATCH 01/20] compat ABI: use non-compat openat and open_by_handle_at
+ variants
+
+The only difference is that non-compat version forces O_LARGEFILE,
+and it should be the default behaviour for all architectures, as
+we don't support 32-bit off_t. The only exception is tile32, that
+continues with compat version of syscalls.
+
+Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
+Acked-by: Arnd Bergmann <arnd@arndb.de>
+Acked-by: Chris Metcalf <cmetcalf@ezchip.com> [for tile]
+---
+ arch/tile/kernel/compat.c         | 3 +++
+ include/uapi/asm-generic/unistd.h | 5 ++---
+ 2 files changed, 5 insertions(+), 3 deletions(-)
+
+diff --git a/arch/tile/kernel/compat.c b/arch/tile/kernel/compat.c
+index 4912084..489ae19 100644
+--- a/arch/tile/kernel/compat.c
++++ b/arch/tile/kernel/compat.c
+@@ -94,6 +94,9 @@ COMPAT_SYSCALL_DEFINE5(llseek, unsigned int, fd, unsigned int, offset_high,
+ #define compat_sys_readahead sys32_readahead
+ #define sys_llseek compat_sys_llseek
+ 
++#define sys_openat		compat_sys_openat
++#define sys_open_by_handle_at	compat_sys_open_by_handle_at
++
+ /* Call the assembly trampolines where necessary. */
+ #define compat_sys_rt_sigreturn _compat_sys_rt_sigreturn
+ #define sys_clone _sys_clone
+diff --git a/include/uapi/asm-generic/unistd.h b/include/uapi/asm-generic/unistd.h
+index 1324b02..07761e5 100644
+--- a/include/uapi/asm-generic/unistd.h
++++ b/include/uapi/asm-generic/unistd.h
+@@ -175,7 +175,7 @@ __SYSCALL(__NR_fchownat, sys_fchownat)
+ #define __NR_fchown 55
+ __SYSCALL(__NR_fchown, sys_fchown)
+ #define __NR_openat 56
+-__SC_COMP(__NR_openat, sys_openat, compat_sys_openat)
++__SYSCALL(__NR_openat, sys_openat)
+ #define __NR_close 57
+ __SYSCALL(__NR_close, sys_close)
+ #define __NR_vhangup 58
+@@ -673,8 +673,7 @@ __SYSCALL(__NR_fanotify_mark, sys_fanotify_mark)
+ #define __NR_name_to_handle_at         264
+ __SYSCALL(__NR_name_to_handle_at, sys_name_to_handle_at)
+ #define __NR_open_by_handle_at         265
+-__SC_COMP(__NR_open_by_handle_at, sys_open_by_handle_at, \
+-	  compat_sys_open_by_handle_at)
++__SYSCALL(__NR_open_by_handle_at, sys_open_by_handle_at)
+ #define __NR_clock_adjtime 266
+ __SC_COMP(__NR_clock_adjtime, sys_clock_adjtime, compat_sys_clock_adjtime)
+ #define __NR_syncfs 267
+-- 
+2.5.0
+
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0002-32-bit-ABI-introduce-ARCH_32BIT_OFF_T-config-option.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0002-32-bit-ABI-introduce-ARCH_32BIT_OFF_T-config-option.patch
new file mode 100644
index 0000000..06a15d6
--- /dev/null
+++ b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0002-32-bit-ABI-introduce-ARCH_32BIT_OFF_T-config-option.patch
@@ -0,0 +1,376 @@
+From 0810c83bc35997412613ca2c124382ed96f53cdb Mon Sep 17 00:00:00 2001
+From: Yury Norov <ynorov@caviumnetworks.com>
+Date: Tue, 29 Dec 2015 12:26:35 +0300
+Subject: [PATCH 02/20] 32-bit ABI: introduce ARCH_32BIT_OFF_T config option
+
+All new 32-bit architectures should have 64-bit off_t type, but existing
+architectures has 32-bit ones.
+
+To handle it, new config option is added to arch/Kconfig that defaults
+ARCH_32BIT_OFF_T to be disabled for non-64 bit architectures. All existing
+32-bit architectures enable it explicitly here.
+
+New option affects force_o_largefile() behaviour. Namely, if off_t is
+64-bits long, we have no reason to reject user to open big files.
+
+Note that even if architectures has only 64-bit off_t in the kernel
+(arc, c6x, h8300, hexagon, metag, nios2, openrisc, tile32 and unicore32),
+a libc may use 32-bit off_t, and therefore want to limit the file size
+to 4GB unless specified differently in the open flags.
+
+Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
+---
+ arch/Kconfig            | 4 ++++
+ arch/arc/Kconfig        | 1 +
+ arch/arm/Kconfig        | 1 +
+ arch/blackfin/Kconfig   | 1 +
+ arch/cris/Kconfig       | 1 +
+ arch/frv/Kconfig        | 1 +
+ arch/h8300/Kconfig      | 1 +
+ arch/hexagon/Kconfig    | 1 +
+ arch/m32r/Kconfig       | 1 +
+ arch/m68k/Kconfig       | 1 +
+ arch/metag/Kconfig      | 1 +
+ arch/microblaze/Kconfig | 1 +
+ arch/mips/Kconfig       | 1 +
+ arch/mn10300/Kconfig    | 1 +
+ arch/nios2/Kconfig      | 1 +
+ arch/openrisc/Kconfig   | 1 +
+ arch/parisc/Kconfig     | 1 +
+ arch/powerpc/Kconfig    | 1 +
+ arch/score/Kconfig      | 1 +
+ arch/sh/Kconfig         | 1 +
+ arch/sparc/Kconfig      | 1 +
+ arch/tile/Kconfig       | 1 +
+ arch/unicore32/Kconfig  | 1 +
+ arch/x86/Kconfig        | 1 +
+ arch/x86/um/Kconfig     | 1 +
+ arch/xtensa/Kconfig     | 1 +
+ include/linux/fcntl.h   | 2 +-
+ 27 files changed, 30 insertions(+), 1 deletion(-)
+
+diff --git a/arch/Kconfig b/arch/Kconfig
+index 4e949e5..b356bb6 100644
+--- a/arch/Kconfig
++++ b/arch/Kconfig
+@@ -233,6 +233,10 @@ config ARCH_THREAD_INFO_ALLOCATOR
+ config ARCH_WANTS_DYNAMIC_TASK_STRUCT
+ 	bool
+ 
++config ARCH_32BIT_OFF_T
++	bool
++	depends on !64BIT
++
+ config HAVE_REGS_AND_STACK_ACCESS_API
+ 	bool
+ 	help
+diff --git a/arch/arc/Kconfig b/arch/arc/Kconfig
+index 6312f60..570dc39 100644
+--- a/arch/arc/Kconfig
++++ b/arch/arc/Kconfig
+@@ -9,6 +9,7 @@
+ config ARC
+ 	def_bool y
+ 	select ARCH_SUPPORTS_ATOMIC_RMW if ARC_HAS_LLSC
++	select ARCH_32BIT_OFF_T
+ 	select BUILDTIME_EXTABLE_SORT
+ 	select COMMON_CLK
+ 	select CLONE_BACKWARDS
+diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
+index ac1bd29..d5e6a08 100644
+--- a/arch/arm/Kconfig
++++ b/arch/arm/Kconfig
+@@ -1,6 +1,7 @@
+ config ARM
+ 	bool
+ 	default y
++	select ARCH_32BIT_OFF_T
+ 	select ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE
+ 	select ARCH_HAS_ELF_RANDOMIZE
+ 	select ARCH_HAS_TICK_BROADCAST if GENERIC_CLOCKEVENTS_BROADCAST
+diff --git a/arch/blackfin/Kconfig b/arch/blackfin/Kconfig
+index af76634..9b5fc06 100644
+--- a/arch/blackfin/Kconfig
++++ b/arch/blackfin/Kconfig
+@@ -12,6 +12,7 @@ config RWSEM_XCHGADD_ALGORITHM
+ 
+ config BLACKFIN
+ 	def_bool y
++	select ARCH_32BIT_OFF_T
+ 	select HAVE_ARCH_KGDB
+ 	select HAVE_ARCH_TRACEHOOK
+ 	select HAVE_DYNAMIC_FTRACE
+diff --git a/arch/cris/Kconfig b/arch/cris/Kconfig
+index e086f9e..5bc9203 100644
+--- a/arch/cris/Kconfig
++++ b/arch/cris/Kconfig
+@@ -50,6 +50,7 @@ config LOCKDEP_SUPPORT
+ config CRIS
+ 	bool
+ 	default y
++	select ARCH_32BIT_OFF_T
+ 	select HAVE_IDE
+ 	select GENERIC_ATOMIC64
+ 	select HAVE_UID16
+diff --git a/arch/frv/Kconfig b/arch/frv/Kconfig
+index 34aa193..09b82fc 100644
+--- a/arch/frv/Kconfig
++++ b/arch/frv/Kconfig
+@@ -1,6 +1,7 @@
+ config FRV
+ 	bool
+ 	default y
++	select ARCH_32BIT_OFF_T
+ 	select HAVE_IDE
+ 	select HAVE_ARCH_TRACEHOOK
+ 	select HAVE_PERF_EVENTS
+diff --git a/arch/h8300/Kconfig b/arch/h8300/Kconfig
+index dd3ac75..7761f4a 100644
+--- a/arch/h8300/Kconfig
++++ b/arch/h8300/Kconfig
+@@ -1,5 +1,6 @@
+ config H8300
+         def_bool y
++	select ARCH_32BIT_OFF_T
+ 	select GENERIC_ATOMIC64
+ 	select HAVE_UID16
+ 	select VIRT_TO_BUS
+diff --git a/arch/hexagon/Kconfig b/arch/hexagon/Kconfig
+index 4dc89d1..29836fc 100644
+--- a/arch/hexagon/Kconfig
++++ b/arch/hexagon/Kconfig
+@@ -3,6 +3,7 @@ comment "Linux Kernel Configuration for Hexagon"
+ 
+ config HEXAGON
+ 	def_bool y
++	select ARCH_32BIT_OFF_T
+ 	select HAVE_OPROFILE
+ 	# Other pending projects/to-do items.
+ 	# select HAVE_REGS_AND_STACK_ACCESS_API
+diff --git a/arch/m32r/Kconfig b/arch/m32r/Kconfig
+index 9e44bbd..c6865a9 100644
+--- a/arch/m32r/Kconfig
++++ b/arch/m32r/Kconfig
+@@ -1,6 +1,7 @@
+ config M32R
+ 	bool
+ 	default y
++	select ARCH_32BIT_OFF_T
+ 	select HAVE_IDE
+ 	select HAVE_OPROFILE
+ 	select INIT_ALL_POSSIBLE
+diff --git a/arch/m68k/Kconfig b/arch/m68k/Kconfig
+index 498b567..e9897e4 100644
+--- a/arch/m68k/Kconfig
++++ b/arch/m68k/Kconfig
+@@ -1,6 +1,7 @@
+ config M68K
+ 	bool
+ 	default y
++	select ARCH_32BIT_OFF_T
+ 	select ARCH_MIGHT_HAVE_PC_PARPORT if ISA
+ 	select HAVE_IDE
+ 	select HAVE_AOUT if MMU
+diff --git a/arch/metag/Kconfig b/arch/metag/Kconfig
+index 0b389a8..6b44d37 100644
+--- a/arch/metag/Kconfig
++++ b/arch/metag/Kconfig
+@@ -1,5 +1,6 @@
+ config METAG
+ 	def_bool y
++	select ARCH_32BIT_OFF_T
+ 	select EMBEDDED
+ 	select GENERIC_ATOMIC64
+ 	select GENERIC_CLOCKEVENTS
+diff --git a/arch/microblaze/Kconfig b/arch/microblaze/Kconfig
+index 0bce820..4b293e5 100644
+--- a/arch/microblaze/Kconfig
++++ b/arch/microblaze/Kconfig
+@@ -1,5 +1,6 @@
+ config MICROBLAZE
+ 	def_bool y
++	select ARCH_32BIT_OFF_T
+ 	select ARCH_HAS_GCOV_PROFILE_ALL
+ 	select ARCH_MIGHT_HAVE_PC_PARPORT
+ 	select ARCH_WANT_IPC_PARSE_VERSION
+diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
+index db45961..0ef9d4c 100644
+--- a/arch/mips/Kconfig
++++ b/arch/mips/Kconfig
+@@ -1,6 +1,7 @@
+ config MIPS
+ 	bool
+ 	default y
++	select ARCH_32BIT_OFF_T if !64BIT
+ 	select ARCH_SUPPORTS_UPROBES
+ 	select ARCH_MIGHT_HAVE_PC_PARPORT
+ 	select ARCH_MIGHT_HAVE_PC_SERIO
+diff --git a/arch/mn10300/Kconfig b/arch/mn10300/Kconfig
+index 78ae555..edf7372 100644
+--- a/arch/mn10300/Kconfig
++++ b/arch/mn10300/Kconfig
+@@ -1,5 +1,6 @@
+ config MN10300
+ 	def_bool y
++	select ARCH_32BIT_OFF_T
+ 	select HAVE_OPROFILE
+ 	select HAVE_UID16
+ 	select GENERIC_IRQ_SHOW
+diff --git a/arch/nios2/Kconfig b/arch/nios2/Kconfig
+index 4375554..e62c41f 100644
+--- a/arch/nios2/Kconfig
++++ b/arch/nios2/Kconfig
+@@ -1,6 +1,7 @@
+ config NIOS2
+ 	def_bool y
+ 	select ARCH_WANT_OPTIONAL_GPIOLIB
++	select ARCH_32BIT_OFF_T
+ 	select CLKSRC_OF
+ 	select GENERIC_ATOMIC64
+ 	select GENERIC_CLOCKEVENTS
+diff --git a/arch/openrisc/Kconfig b/arch/openrisc/Kconfig
+index 443f44d..7bef847 100644
+--- a/arch/openrisc/Kconfig
++++ b/arch/openrisc/Kconfig
+@@ -5,6 +5,7 @@
+ 
+ config OPENRISC
+ 	def_bool y
++	select ARCH_32BIT_OFF_T
+ 	select OF
+ 	select OF_EARLY_FLATTREE
+ 	select IRQ_DOMAIN
+diff --git a/arch/parisc/Kconfig b/arch/parisc/Kconfig
+index 729f891..8bf0fe2 100644
+--- a/arch/parisc/Kconfig
++++ b/arch/parisc/Kconfig
+@@ -1,5 +1,6 @@
+ config PARISC
+ 	def_bool y
++	select ARCH_32BIT_OFF_T if !64BIT
+ 	select ARCH_HAS_DEBUG_STRICT_USER_COPY_CHECKS
+ 	select ARCH_MIGHT_HAVE_PC_PARPORT
+ 	select HAVE_IDE
+diff --git a/arch/powerpc/Kconfig b/arch/powerpc/Kconfig
+index 38220c1..d5e6ec2 100644
+--- a/arch/powerpc/Kconfig
++++ b/arch/powerpc/Kconfig
+@@ -88,6 +88,7 @@ config ARCH_HAS_DMA_SET_COHERENT_MASK
+ config PPC
+ 	bool
+ 	default y
++	select ARCH_32BIT_OFF_T if PPC32
+ 	select ARCH_MIGHT_HAVE_PC_PARPORT
+ 	select ARCH_MIGHT_HAVE_PC_SERIO
+ 	select BINFMT_ELF
+diff --git a/arch/score/Kconfig b/arch/score/Kconfig
+index 366e1b5..bc7bc7a 100644
+--- a/arch/score/Kconfig
++++ b/arch/score/Kconfig
+@@ -2,6 +2,7 @@ menu "Machine selection"
+ 
+ config SCORE
+        def_bool y
++       select ARCH_32BIT_OFF_T
+        select GENERIC_IRQ_SHOW
+        select GENERIC_IOMAP
+        select GENERIC_ATOMIC64
+diff --git a/arch/sh/Kconfig b/arch/sh/Kconfig
+index d514df7e..1e9d63a 100644
+--- a/arch/sh/Kconfig
++++ b/arch/sh/Kconfig
+@@ -52,6 +52,7 @@ config SUPERH
+ 
+ config SUPERH32
+ 	def_bool ARCH = "sh"
++	select ARCH_32BIT_OFF_T
+ 	select HAVE_KPROBES
+ 	select HAVE_KRETPROBES
+ 	select HAVE_IOREMAP_PROT if MMU && !X2TLB
+diff --git a/arch/sparc/Kconfig b/arch/sparc/Kconfig
+index 56442d2..1268a2a 100644
+--- a/arch/sparc/Kconfig
++++ b/arch/sparc/Kconfig
+@@ -46,6 +46,7 @@ config SPARC
+ 
+ config SPARC32
+ 	def_bool !64BIT
++	select ARCH_32BIT_OFF_T
+ 	select GENERIC_ATOMIC64
+ 	select CLZ_TAB
+ 	select HAVE_UID16
+diff --git a/arch/tile/Kconfig b/arch/tile/Kconfig
+index 8ec7a45..522cf45 100644
+--- a/arch/tile/Kconfig
++++ b/arch/tile/Kconfig
+@@ -3,6 +3,7 @@
+ 
+ config TILE
+ 	def_bool y
++	select ARCH_32BIT_OFF_T if !64BIT
+ 	select HAVE_PERF_EVENTS
+ 	select USE_PMC if PERF_EVENTS
+ 	select HAVE_DMA_ATTRS
+diff --git a/arch/unicore32/Kconfig b/arch/unicore32/Kconfig
+index c9faddc..1a8c3c0 100644
+--- a/arch/unicore32/Kconfig
++++ b/arch/unicore32/Kconfig
+@@ -1,5 +1,6 @@
+ config UNICORE32
+ 	def_bool y
++	select ARCH_32BIT_OFF_T
+ 	select ARCH_MIGHT_HAVE_PC_PARPORT
+ 	select ARCH_MIGHT_HAVE_PC_SERIO
+ 	select HAVE_MEMBLOCK
+diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
+index fd4932c..003ad62 100644
+--- a/arch/x86/Kconfig
++++ b/arch/x86/Kconfig
+@@ -20,6 +20,7 @@ config X86
+ 	select ACPI_LEGACY_TABLES_LOOKUP	if ACPI
+ 	select ACPI_SYSTEM_POWER_STATES_SUPPORT	if ACPI
+ 	select ANON_INODES
++	select ARCH_32BIT_OFF_T			if X86_32
+ 	select ARCH_CLOCKSOURCE_DATA
+ 	select ARCH_DISCARD_MEMBLOCK
+ 	select ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE
+diff --git a/arch/x86/um/Kconfig b/arch/x86/um/Kconfig
+index ed56a1c..8436bcd 100644
+--- a/arch/x86/um/Kconfig
++++ b/arch/x86/um/Kconfig
+@@ -21,6 +21,7 @@ config 64BIT
+ config X86_32
+ 	def_bool !64BIT
+ 	select HAVE_AOUT
++	select ARCH_32BIT_OFF_T
+ 	select ARCH_WANT_IPC_PARSE_VERSION
+ 	select MODULES_USE_ELF_REL
+ 	select CLONE_BACKWARDS
+diff --git a/arch/xtensa/Kconfig b/arch/xtensa/Kconfig
+index 82044f7..7ff155a 100644
+--- a/arch/xtensa/Kconfig
++++ b/arch/xtensa/Kconfig
+@@ -3,6 +3,7 @@ config ZONE_DMA
+ 
+ config XTENSA
+ 	def_bool y
++	select ARCH_32BIT_OFF_T
+ 	select ARCH_WANT_FRAME_POINTERS
+ 	select ARCH_WANT_IPC_PARSE_VERSION
+ 	select ARCH_WANT_OPTIONAL_GPIOLIB
+diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h
+index 76ce329..46960a1 100644
+--- a/include/linux/fcntl.h
++++ b/include/linux/fcntl.h
+@@ -5,7 +5,7 @@
+ 
+ 
+ #ifndef force_o_largefile
+-#define force_o_largefile() (BITS_PER_LONG != 32)
++#define force_o_largefile() (!IS_ENABLED(CONFIG_ARCH_32BIT_OFF_T))
+ #endif
+ 
+ #if BITS_PER_LONG == 32
+-- 
+2.5.0
+
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0002-all-introduce-COMPAT_WRAPPER-option-and-enable-it-fo.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0002-all-introduce-COMPAT_WRAPPER-option-and-enable-it-fo.patch
deleted file mode 100644
index 6bb1cd0..0000000
--- a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0002-all-introduce-COMPAT_WRAPPER-option-and-enable-it-fo.patch
+++ /dev/null
@@ -1,42 +0,0 @@
-From 60e20cceb8833d62ee1609980809f089997555bb Mon Sep 17 00:00:00 2001
-From: Yury Norov <ynorov@caviumnetworks.com>
-Date: Tue, 24 May 2016 03:04:31 +0300
-Subject: [PATCH 02/24] all: introduce COMPAT_WRAPPER option and enable it for
- s390
-
-Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
----
- arch/Kconfig      | 4 ++++
- arch/s390/Kconfig | 1 +
- 2 files changed, 5 insertions(+)
-
-diff --git a/arch/Kconfig b/arch/Kconfig
-index 4e949e5..ab7692e 100644
---- a/arch/Kconfig
-+++ b/arch/Kconfig
-@@ -518,6 +518,10 @@ config HAVE_COPY_THREAD_TLS
- 	  normal C parameter passing, rather than extracting the syscall
- 	  argument from pt_regs.
- 
-+config COMPAT_WRAPPER
-+	bool
-+	depends on COMPAT
-+
- #
- # ABI hall of shame
- #
-diff --git a/arch/s390/Kconfig b/arch/s390/Kconfig
-index 3a55f49..88f48b0 100644
---- a/arch/s390/Kconfig
-+++ b/arch/s390/Kconfig
-@@ -336,6 +336,7 @@ config COMPAT
- 	select COMPAT_BINFMT_ELF if BINFMT_ELF
- 	select ARCH_WANT_OLD_COMPAT_IPC
- 	select COMPAT_OLD_SIGACTION
-+	select COMPAT_WRAPPER
- 	depends on MULTIUSER
- 	help
- 	  Select this option if you want to enable your system kernel to
--- 
-1.9.1
-
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0003-all-s390-move-wrapper-infrastructure-to-generic-head.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0003-all-s390-move-wrapper-infrastructure-to-generic-head.patch
deleted file mode 100644
index 922ba75..0000000
--- a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0003-all-s390-move-wrapper-infrastructure-to-generic-head.patch
+++ /dev/null
@@ -1,351 +0,0 @@
-From 6853b31eed18d9ff7c5e1843be31dc587dfefc30 Mon Sep 17 00:00:00 2001
-From: Yury Norov <ynorov@caviumnetworks.com>
-Date: Tue, 24 May 2016 03:04:32 +0300
-Subject: [PATCH 03/24] all: s390: move wrapper infrastructure to generic
- headers
-
-This patch moves required calls to generic files to let other arches use
-it if needed. Here also, additional code is introduced, as s390 uses asm
-syscall tables, while in general case, wrappers may be used in C code.
-
-__SC_COMPAT_CAST for s390 is too specific due to 31-bit pointer length, so it's
-moved to arch/s390/include/asm/compat.h. Generic declaration assumes that long,
-unsigned long and pointer types are all 32-bit length.
-
-linux/syscalls_structs.h header is introduced, because from now (see next patch)
-structure types listed there are needed for both normal and compat mode.
-
-cond_syscall_wrapped now defined two symbols: sys_foo() and compat_sys_foo(), if
-compat wrappers are enabled.
-
-Here __SC_WRAP() macro is introduced as well. s390 doesn't need it as it uses
-asm-generated syscall table. But architectures that generate that tables with
-C code (ARM64/ILP32) should redefine it as '#define __SC_WRAP(name) compat_##name'.
-
-Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
----
- arch/s390/include/asm/compat.h    | 17 +++++++++--
- arch/s390/kernel/compat_wrapper.c | 51 ---------------------------------
- include/linux/compat.h            | 53 ++++++++++++++++++++++++++++++++++
- include/linux/syscalls.h          | 57 +------------------------------------
- include/linux/syscalls_structs.h  | 60 +++++++++++++++++++++++++++++++++++++++
- include/uapi/asm-generic/unistd.h |  4 +++
- 6 files changed, 133 insertions(+), 109 deletions(-)
- create mode 100644 include/linux/syscalls_structs.h
-
-diff --git a/arch/s390/include/asm/compat.h b/arch/s390/include/asm/compat.h
-index d350ed9..46cb4be 100644
---- a/arch/s390/include/asm/compat.h
-+++ b/arch/s390/include/asm/compat.h
-@@ -7,13 +7,26 @@
- #include <linux/sched.h>
- #include <linux/thread_info.h>
- 
--#define __TYPE_IS_PTR(t) (!__builtin_types_compatible_p(typeof(0?(t)0:0ULL), u64))
--
- #define __SC_DELOUSE(t,v) ({ \
- 	BUILD_BUG_ON(sizeof(t) > 4 && !__TYPE_IS_PTR(t)); \
- 	(t)(__TYPE_IS_PTR(t) ? ((v) & 0x7fffffff) : (v)); \
- })
- 
-+#define __SC_COMPAT_CAST(t, a)						\
-+({									\
-+	long __ReS = a;							\
-+									\
-+	BUILD_BUG_ON((sizeof(t) > 4) && !__TYPE_IS_L(t) &&		\
-+		     !__TYPE_IS_UL(t) && !__TYPE_IS_PTR(t));		\
-+	if (__TYPE_IS_L(t))						\
-+		__ReS = (s32)a;						\
-+	if (__TYPE_IS_UL(t))						\
-+		__ReS = (u32)a;						\
-+	if (__TYPE_IS_PTR(t))						\
-+		__ReS = a & 0x7fffffff;					\
-+	(t)__ReS;							\
-+})
-+
- #define PSW32_MASK_PER		0x40000000UL
- #define PSW32_MASK_DAT		0x04000000UL
- #define PSW32_MASK_IO		0x02000000UL
-diff --git a/arch/s390/kernel/compat_wrapper.c b/arch/s390/kernel/compat_wrapper.c
-index fac4eed..527f75d 100644
---- a/arch/s390/kernel/compat_wrapper.c
-+++ b/arch/s390/kernel/compat_wrapper.c
-@@ -8,57 +8,6 @@
- #include <linux/compat.h>
- #include "entry.h"
- 
--#define COMPAT_SYSCALL_WRAP1(name, ...) \
--	COMPAT_SYSCALL_WRAPx(1, _##name, __VA_ARGS__)
--#define COMPAT_SYSCALL_WRAP2(name, ...) \
--	COMPAT_SYSCALL_WRAPx(2, _##name, __VA_ARGS__)
--#define COMPAT_SYSCALL_WRAP3(name, ...) \
--	COMPAT_SYSCALL_WRAPx(3, _##name, __VA_ARGS__)
--#define COMPAT_SYSCALL_WRAP4(name, ...) \
--	COMPAT_SYSCALL_WRAPx(4, _##name, __VA_ARGS__)
--#define COMPAT_SYSCALL_WRAP5(name, ...) \
--	COMPAT_SYSCALL_WRAPx(5, _##name, __VA_ARGS__)
--#define COMPAT_SYSCALL_WRAP6(name, ...) \
--	COMPAT_SYSCALL_WRAPx(6, _##name, __VA_ARGS__)
--
--#define __SC_COMPAT_TYPE(t, a) \
--	__typeof(__builtin_choose_expr(sizeof(t) > 4, 0L, (t)0)) a
--
--#define __SC_COMPAT_CAST(t, a)						\
--({									\
--	long __ReS = a;							\
--									\
--	BUILD_BUG_ON((sizeof(t) > 4) && !__TYPE_IS_L(t) &&		\
--		     !__TYPE_IS_UL(t) && !__TYPE_IS_PTR(t));		\
--	if (__TYPE_IS_L(t))						\
--		__ReS = (s32)a;						\
--	if (__TYPE_IS_UL(t))						\
--		__ReS = (u32)a;						\
--	if (__TYPE_IS_PTR(t))						\
--		__ReS = a & 0x7fffffff;					\
--	(t)__ReS;							\
--})
--
--/*
-- * The COMPAT_SYSCALL_WRAP macro generates system call wrappers to be used by
-- * compat tasks. These wrappers will only be used for system calls where only
-- * the system call arguments need sign or zero extension or zeroing of the upper
-- * 33 bits of pointers.
-- * Note: since the wrapper function will afterwards call a system call which
-- * again performs zero and sign extension for all system call arguments with
-- * a size of less than eight bytes, these compat wrappers only touch those
-- * system call arguments with a size of eight bytes ((unsigned) long and
-- * pointers). Zero and sign extension for e.g. int parameters will be done by
-- * the regular system call wrappers.
-- */
--#define COMPAT_SYSCALL_WRAPx(x, name, ...)					\
--asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__));			\
--asmlinkage long notrace compat_sys##name(__MAP(x,__SC_COMPAT_TYPE,__VA_ARGS__));\
--asmlinkage long notrace compat_sys##name(__MAP(x,__SC_COMPAT_TYPE,__VA_ARGS__))	\
--{										\
--	return sys##name(__MAP(x,__SC_COMPAT_CAST,__VA_ARGS__));		\
--}
--
- COMPAT_SYSCALL_WRAP2(creat, const char __user *, pathname, umode_t, mode);
- COMPAT_SYSCALL_WRAP2(link, const char __user *, oldname, const char __user *, newname);
- COMPAT_SYSCALL_WRAP1(unlink, const char __user *, pathname);
-diff --git a/include/linux/compat.h b/include/linux/compat.h
-index a76c917..72ef245 100644
---- a/include/linux/compat.h
-+++ b/include/linux/compat.h
-@@ -28,6 +28,10 @@
- #define __SC_DELOUSE(t,v) ((t)(unsigned long)(v))
- #endif
- 
-+#ifndef __TYPE_IS_PTR
-+#define __TYPE_IS_PTR(t) (!__builtin_types_compatible_p(typeof(0?(t)0:0ULL), u64))
-+#endif
-+
- #define COMPAT_SYSCALL_DEFINE0(name) \
- 	asmlinkage long compat_sys_##name(void)
- 
-@@ -718,4 +722,53 @@ asmlinkage long compat_sys_fanotify_mark(int, unsigned int, __u32, __u32,
- #define is_compat_task() (0)
- 
- #endif /* CONFIG_COMPAT */
-+ 
-+#ifdef CONFIG_COMPAT_WRAPPER
-+
-+#define COMPAT_SYSCALL_WRAP1(name, ...) COMPAT_SYSCALL_WRAPx(1, _##name, __VA_ARGS__)
-+#define COMPAT_SYSCALL_WRAP2(name, ...) COMPAT_SYSCALL_WRAPx(2, _##name, __VA_ARGS__)
-+#define COMPAT_SYSCALL_WRAP3(name, ...) COMPAT_SYSCALL_WRAPx(3, _##name, __VA_ARGS__)
-+#define COMPAT_SYSCALL_WRAP4(name, ...) COMPAT_SYSCALL_WRAPx(4, _##name, __VA_ARGS__)
-+#define COMPAT_SYSCALL_WRAP5(name, ...) COMPAT_SYSCALL_WRAPx(5, _##name, __VA_ARGS__)
-+#define COMPAT_SYSCALL_WRAP6(name, ...) COMPAT_SYSCALL_WRAPx(6, _##name, __VA_ARGS__)
-+
-+#ifndef __SC_COMPAT_TYPE
-+#define __SC_COMPAT_TYPE(t, a) \
-+	__typeof(__builtin_choose_expr(sizeof(t) > 4, 0L, (t)0)) a
-+#endif
-+
-+#ifndef __SC_COMPAT_CAST
-+#define __SC_COMPAT_CAST(t, a) ({					\
-+	BUILD_BUG_ON((sizeof(t) > 4) && !__TYPE_IS_L(t) &&		\
-+		     !__TYPE_IS_UL(t) && !__TYPE_IS_PTR(t));		\
-+	((t) ((t)(-1) < 0 ? (s64)(s32)(a) : (u64)(u32)(a)));		\
-+})
-+#endif
-+
-+#ifndef COMPAT_SYSCALL_WRAPx
-+/*
-+ * The COMPAT_SYSCALL_WRAP macro generates system call wrappers to be used by
-+ * compat tasks. These wrappers will only be used for system calls where only
-+ * the system call arguments need sign or zero extension or zeroing of the upper
-+ * parts of arguments passed in register.
-+ * Note: since the wrapper function will afterwards call a system call which
-+ * again performs zero and sign extension for all system call arguments with
-+ * a size of less than eight bytes, these compat wrappers only touch those
-+ * system call arguments with a size of eight bytes ((unsigned) long and
-+ * pointers). Zero and sign extension for e.g. int parameters will be done by
-+ * the regular system call wrappers.
-+ */
-+#define COMPAT_SYSCALL_WRAPx(x, name, ...)						\
-+asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__));				\
-+asmlinkage long compat_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))			\
-+		__attribute__((alias(__stringify(compat_SyS##name))));			\
-+asmlinkage long notrace compat_SyS##name(__MAP(x,__SC_COMPAT_TYPE,__VA_ARGS__));	\
-+asmlinkage long notrace compat_SyS##name(__MAP(x,__SC_COMPAT_TYPE,__VA_ARGS__))		\
-+{											\
-+	return sys##name(__MAP(x,__SC_COMPAT_CAST,__VA_ARGS__));			\
-+}
-+#endif /* COMPAT_SYSCALL_WRAPx */
-+
-+#endif /* CONFIG_COMPAT_WRAPPER */
-+
- #endif /* _LINUX_COMPAT_H */
-diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
-index c2b66a2..1942cf4 100644
---- a/include/linux/syscalls.h
-+++ b/include/linux/syscalls.h
-@@ -11,62 +11,7 @@
- #ifndef _LINUX_SYSCALLS_H
- #define _LINUX_SYSCALLS_H
- 
--struct epoll_event;
--struct iattr;
--struct inode;
--struct iocb;
--struct io_event;
--struct iovec;
--struct itimerspec;
--struct itimerval;
--struct kexec_segment;
--struct linux_dirent;
--struct linux_dirent64;
--struct list_head;
--struct mmap_arg_struct;
--struct msgbuf;
--struct user_msghdr;
--struct mmsghdr;
--struct msqid_ds;
--struct new_utsname;
--struct nfsctl_arg;
--struct __old_kernel_stat;
--struct oldold_utsname;
--struct old_utsname;
--struct pollfd;
--struct rlimit;
--struct rlimit64;
--struct rusage;
--struct sched_param;
--struct sched_attr;
--struct sel_arg_struct;
--struct semaphore;
--struct sembuf;
--struct shmid_ds;
--struct sockaddr;
--struct stat;
--struct stat64;
--struct statfs;
--struct statfs64;
--struct __sysctl_args;
--struct sysinfo;
--struct timespec;
--struct timeval;
--struct timex;
--struct timezone;
--struct tms;
--struct utimbuf;
--struct mq_attr;
--struct compat_stat;
--struct compat_timeval;
--struct robust_list_head;
--struct getcpu_cache;
--struct old_linux_dirent;
--struct perf_event_attr;
--struct file_handle;
--struct sigaltstack;
--union bpf_attr;
--
-+#include <linux/syscalls_structs.h>
- #include <linux/types.h>
- #include <linux/aio_abi.h>
- #include <linux/capability.h>
-diff --git a/include/linux/syscalls_structs.h b/include/linux/syscalls_structs.h
-new file mode 100644
-index 0000000..a920cbc
---- /dev/null
-+++ b/include/linux/syscalls_structs.h
-@@ -0,0 +1,60 @@
-+#ifndef _LINUX_SYSCALL_STRUCTS_H
-+#define _LINUX_SYSCALL_STRUCTS_H
-+
-+struct epoll_event;
-+struct iattr;
-+struct inode;
-+struct iocb;
-+struct io_event;
-+struct iovec;
-+struct itimerspec;
-+struct itimerval;
-+struct kexec_segment;
-+struct linux_dirent;
-+struct linux_dirent64;
-+struct list_head;
-+struct mmap_arg_struct;
-+struct msgbuf;
-+struct user_msghdr;
-+struct mmsghdr;
-+struct msqid_ds;
-+struct new_utsname;
-+struct nfsctl_arg;
-+struct __old_kernel_stat;
-+struct oldold_utsname;
-+struct old_utsname;
-+struct pollfd;
-+struct rlimit;
-+struct rlimit64;
-+struct rusage;
-+struct sched_param;
-+struct sched_attr;
-+struct sel_arg_struct;
-+struct semaphore;
-+struct sembuf;
-+struct shmid_ds;
-+struct sockaddr;
-+struct stat;
-+struct stat64;
-+struct statfs;
-+struct statfs64;
-+struct __sysctl_args;
-+struct sysinfo;
-+struct timespec;
-+struct timeval;
-+struct timex;
-+struct timezone;
-+struct tms;
-+struct utimbuf;
-+struct mq_attr;
-+struct compat_stat;
-+struct compat_timeval;
-+struct robust_list_head;
-+struct getcpu_cache;
-+struct old_linux_dirent;
-+struct perf_event_attr;
-+struct file_handle;
-+struct sigaltstack;
-+union bpf_attr;
-+
-+#endif /* _LINUX_SYSCALL_STRUCTS_H */
-diff --git a/include/uapi/asm-generic/unistd.h b/include/uapi/asm-generic/unistd.h
-index 1324b02..a8380ad 100644
---- a/include/uapi/asm-generic/unistd.h
-+++ b/include/uapi/asm-generic/unistd.h
-@@ -29,6 +29,10 @@
- #define __SC_COMP_3264(_nr, _32, _64, _comp) __SC_3264(_nr, _32, _64)
- #endif
- 
-+#ifndef __SC_WRAP
-+#define __SC_WRAP __SYSCALL
-+#endif
-+
- #define __NR_io_setup 0
- __SC_COMP(__NR_io_setup, sys_io_setup, compat_sys_io_setup)
- #define __NR_io_destroy 1
--- 
-1.9.1
-
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0003-asm-generic-Drop-getrlimit-and-setrlimit-syscalls-fr.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0003-asm-generic-Drop-getrlimit-and-setrlimit-syscalls-fr.patch
new file mode 100644
index 0000000..ff59e8d
--- /dev/null
+++ b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0003-asm-generic-Drop-getrlimit-and-setrlimit-syscalls-fr.patch
@@ -0,0 +1,215 @@
+From 20e9e88834d21e4989813efe9fda08b83fff8c6e Mon Sep 17 00:00:00 2001
+From: Yury Norov <ynorov@caviumnetworks.com>
+Date: Sat, 22 Oct 2016 13:45:06 +0300
+Subject: [PATCH 03/20] asm-generic: Drop getrlimit and setrlimit syscalls from
+ default list
+
+The newer prlimit64 syscall provides all the functionality provided by
+the getrlimit and setrlimit syscalls and adds the pid of target process,
+so future architectures won't need to include getrlimit and setrlimit.
+
+Therefore drop getrlimit and setrlimit syscalls from the generic syscall
+list unless __ARCH_WANT_SET_GET_RLIMIT is defined by the architecture's
+unistd.h prior to including asm-generic/unistd.h, and adjust all architectures
+using the generic syscall list to define it so that no in-tree architectures
+are affected.
+
+Cc: Arnd Bergmann <arnd@arndb.de>
+Cc: James Hogan <james.hogan@imgtec.com>
+Cc: linux-arch@vger.kernel.org
+Cc: linux-snps-arc@lists.infradead.org
+Cc: Catalin Marinas <catalin.marinas@arm.com>
+Cc: Will Deacon <will.deacon@arm.com>
+Cc: linux-arm-kernel@lists.infradead.org
+Cc: Mark Salter <msalter@redhat.com>
+Cc: Aurelien Jacquiot <a-jacquiot@ti.com>
+Cc: linux-c6x-dev@linux-c6x.org
+Cc: Richard Kuo <rkuo@codeaurora.org>
+Cc: linux-hexagon@vger.kernel.org
+Cc: linux-metag@vger.kernel.org
+Cc: Jonas Bonn <jonas@southpole.se>
+Cc: linux@lists.openrisc.net
+Cc: Chen Liqin <liqin.linux@gmail.com>
+Cc: Lennox Wu <lennox.wu@gmail.com>
+Cc: Chris Metcalf <cmetcalf@mellanox.com>
+Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>
+Cc: Ley Foon Tan <lftan@altera.com>
+Cc: nios2-dev@lists.rocketboards.org
+Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
+Cc: uclinux-h8-devel@lists.sourceforge.jp
+Acked-by: Arnd Bergmann <arnd@arndb.de>
+Acked-by: Mark Salter <msalter@redhat.com> [c6x]
+Acked-by: James Hogan <james.hogan@imgtec.com> [metag]
+Acked-by: Ley Foon Tan <lftan@altera.com> [nios2]
+Acked-by: Stafford Horne <shorne@gmail.com> [openrisc]
+Acked-by: Vineet Gupta <vgupta@synopsys.com> #arch/arc bits
+Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
+---
+ arch/arc/include/uapi/asm/unistd.h       | 1 +
+ arch/arm64/include/uapi/asm/unistd.h     | 2 ++
+ arch/c6x/include/uapi/asm/unistd.h       | 1 +
+ arch/h8300/include/uapi/asm/unistd.h     | 2 ++
+ arch/hexagon/include/uapi/asm/unistd.h   | 1 +
+ arch/metag/include/uapi/asm/unistd.h     | 2 ++
+ arch/nios2/include/uapi/asm/unistd.h     | 2 ++
+ arch/openrisc/include/uapi/asm/unistd.h  | 1 +
+ arch/score/include/uapi/asm/unistd.h     | 1 +
+ arch/tile/include/uapi/asm/unistd.h      | 1 +
+ arch/unicore32/include/uapi/asm/unistd.h | 2 ++
+ include/uapi/asm-generic/unistd.h        | 5 +++++
+ 12 files changed, 21 insertions(+)
+
+diff --git a/arch/arc/include/uapi/asm/unistd.h b/arch/arc/include/uapi/asm/unistd.h
+index 39e58d1..c8016f2 100644
+--- a/arch/arc/include/uapi/asm/unistd.h
++++ b/arch/arc/include/uapi/asm/unistd.h
+@@ -15,6 +15,7 @@
+ #if !defined(_UAPI_ASM_ARC_UNISTD_H) || defined(__SYSCALL)
+ #define _UAPI_ASM_ARC_UNISTD_H
+ 
++#define __ARCH_WANT_SET_GET_RLIMIT
+ #define __ARCH_WANT_SYS_EXECVE
+ #define __ARCH_WANT_SYS_CLONE
+ #define __ARCH_WANT_SYS_VFORK
+diff --git a/arch/arm64/include/uapi/asm/unistd.h b/arch/arm64/include/uapi/asm/unistd.h
+index 1caadc2..3faca2c 100644
+--- a/arch/arm64/include/uapi/asm/unistd.h
++++ b/arch/arm64/include/uapi/asm/unistd.h
+@@ -13,4 +13,6 @@
+  * You should have received a copy of the GNU General Public License
+  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+  */
++#define __ARCH_WANT_SET_GET_RLIMIT
++
+ #include <asm-generic/unistd.h>
+diff --git a/arch/c6x/include/uapi/asm/unistd.h b/arch/c6x/include/uapi/asm/unistd.h
+index e7d09a6..afa8ddee 100644
+--- a/arch/c6x/include/uapi/asm/unistd.h
++++ b/arch/c6x/include/uapi/asm/unistd.h
+@@ -14,6 +14,7 @@
+  *   more details.
+  */
+ 
++#define __ARCH_WANT_SET_GET_RLIMIT
+ #define __ARCH_WANT_SYS_CLONE
+ 
+ /* Use the standard ABI for syscalls. */
+diff --git a/arch/h8300/include/uapi/asm/unistd.h b/arch/h8300/include/uapi/asm/unistd.h
+index 7a2eb69..a4d9e0d 100644
+--- a/arch/h8300/include/uapi/asm/unistd.h
++++ b/arch/h8300/include/uapi/asm/unistd.h
+@@ -1,3 +1,5 @@
+ #define __ARCH_NOMMU
+ 
++#define __ARCH_WANT_SET_GET_RLIMIT
++
+ #include <asm-generic/unistd.h>
+diff --git a/arch/hexagon/include/uapi/asm/unistd.h b/arch/hexagon/include/uapi/asm/unistd.h
+index ffee405d..0f8a513 100644
+--- a/arch/hexagon/include/uapi/asm/unistd.h
++++ b/arch/hexagon/include/uapi/asm/unistd.h
+@@ -27,6 +27,7 @@
+  */
+ 
+ #define sys_mmap2 sys_mmap_pgoff
++#define __ARCH_WANT_SET_GET_RLIMIT
+ #define __ARCH_WANT_SYS_EXECVE
+ #define __ARCH_WANT_SYS_CLONE
+ #define __ARCH_WANT_SYS_VFORK
+diff --git a/arch/metag/include/uapi/asm/unistd.h b/arch/metag/include/uapi/asm/unistd.h
+index b80b8e8..34eaa7e 100644
+--- a/arch/metag/include/uapi/asm/unistd.h
++++ b/arch/metag/include/uapi/asm/unistd.h
+@@ -7,6 +7,8 @@
+  * (at your option) any later version.
+  */
+ 
++#define __ARCH_WANT_SET_GET_RLIMIT
++
+ /* Use the standard ABI for syscalls. */
+ #include <asm-generic/unistd.h>
+ 
+diff --git a/arch/nios2/include/uapi/asm/unistd.h b/arch/nios2/include/uapi/asm/unistd.h
+index c4bf795..a13e0f7 100644
+--- a/arch/nios2/include/uapi/asm/unistd.h
++++ b/arch/nios2/include/uapi/asm/unistd.h
+@@ -17,6 +17,8 @@
+ 
+  #define sys_mmap2 sys_mmap_pgoff
+ 
++#define __ARCH_WANT_SET_GET_RLIMIT
++
+ /* Use the standard ABI for syscalls */
+ #include <asm-generic/unistd.h>
+ 
+diff --git a/arch/openrisc/include/uapi/asm/unistd.h b/arch/openrisc/include/uapi/asm/unistd.h
+index ce40b71..1b3684b 100644
+--- a/arch/openrisc/include/uapi/asm/unistd.h
++++ b/arch/openrisc/include/uapi/asm/unistd.h
+@@ -20,6 +20,7 @@
+ 
+ #define sys_mmap2 sys_mmap_pgoff
+ 
++#define __ARCH_WANT_SET_GET_RLIMIT
+ #define __ARCH_WANT_SYS_FORK
+ #define __ARCH_WANT_SYS_CLONE
+ 
+diff --git a/arch/score/include/uapi/asm/unistd.h b/arch/score/include/uapi/asm/unistd.h
+index 9cb4260..e066e12 100644
+--- a/arch/score/include/uapi/asm/unistd.h
++++ b/arch/score/include/uapi/asm/unistd.h
+@@ -1,5 +1,6 @@
+ #define __ARCH_HAVE_MMU
+ 
++#define __ARCH_WANT_SET_GET_RLIMIT
+ #define __ARCH_WANT_SYSCALL_NO_AT
+ #define __ARCH_WANT_SYSCALL_NO_FLAGS
+ #define __ARCH_WANT_SYSCALL_OFF_T
+diff --git a/arch/tile/include/uapi/asm/unistd.h b/arch/tile/include/uapi/asm/unistd.h
+index 3866397..cb7b762 100644
+--- a/arch/tile/include/uapi/asm/unistd.h
++++ b/arch/tile/include/uapi/asm/unistd.h
+@@ -12,6 +12,7 @@
+  *   more details.
+  */
+ 
++#define __ARCH_WANT_SET_GET_RLIMIT
+ #if !defined(__LP64__) || defined(__SYSCALL_COMPAT)
+ /* Use the flavor of this syscall that matches the 32-bit API better. */
+ #define __ARCH_WANT_SYNC_FILE_RANGE2
+diff --git a/arch/unicore32/include/uapi/asm/unistd.h b/arch/unicore32/include/uapi/asm/unistd.h
+index d4cc455..38c4114 100644
+--- a/arch/unicore32/include/uapi/asm/unistd.h
++++ b/arch/unicore32/include/uapi/asm/unistd.h
+@@ -10,6 +10,8 @@
+  * published by the Free Software Foundation.
+  */
+ 
++#define __ARCH_WANT_SET_GET_RLIMIT
++
+ /* Use the standard ABI for syscalls. */
+ #include <asm-generic/unistd.h>
+ #define __ARCH_WANT_SYS_CLONE
+diff --git a/include/uapi/asm-generic/unistd.h b/include/uapi/asm-generic/unistd.h
+index 07761e5..7091186 100644
+--- a/include/uapi/asm-generic/unistd.h
++++ b/include/uapi/asm-generic/unistd.h
+@@ -462,10 +462,15 @@ __SYSCALL(__NR_uname, sys_newuname)
+ __SYSCALL(__NR_sethostname, sys_sethostname)
+ #define __NR_setdomainname 162
+ __SYSCALL(__NR_setdomainname, sys_setdomainname)
++
++#ifdef __ARCH_WANT_SET_GET_RLIMIT
++/* getrlimit and setrlimit are superseded with prlimit64 */
+ #define __NR_getrlimit 163
+ __SC_COMP(__NR_getrlimit, sys_getrlimit, compat_sys_getrlimit)
+ #define __NR_setrlimit 164
+ __SC_COMP(__NR_setrlimit, sys_setrlimit, compat_sys_setrlimit)
++#endif
++
+ #define __NR_getrusage 165
+ __SC_COMP(__NR_getrusage, sys_getrusage, compat_sys_getrusage)
+ #define __NR_umask 166
+-- 
+2.5.0
+
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0004-all-s390-move-compat_wrappers.c-from-arch-s390-kerne.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0004-all-s390-move-compat_wrappers.c-from-arch-s390-kerne.patch
deleted file mode 100644
index 11e053b..0000000
--- a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0004-all-s390-move-compat_wrappers.c-from-arch-s390-kerne.patch
+++ /dev/null
@@ -1,335 +0,0 @@
-From fe333224dad834ef4031cbe8d554031b8e1bccc0 Mon Sep 17 00:00:00 2001
-From: Yury Norov <ynorov@caviumnetworks.com>
-Date: Tue, 24 May 2016 03:04:33 +0300
-Subject: [PATCH 04/24] all: s390: move compat_wrappers.c from arch/s390/kernel
- to kernel/
-
-Some syscalls are declared conditionally, so corresponding wrappers
-are conditional accordingly.
-
-Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
----
- arch/s390/kernel/compat_wrapper.c | 128 ----------------------------
- kernel/compat_wrapper.c           | 175 ++++++++++++++++++++++++++++++++++++++
- 2 files changed, 175 insertions(+), 128 deletions(-)
- delete mode 100644 arch/s390/kernel/compat_wrapper.c
- create mode 100644 kernel/compat_wrapper.c
-
-diff --git a/arch/s390/kernel/compat_wrapper.c b/arch/s390/kernel/compat_wrapper.c
-deleted file mode 100644
-index 527f75d..0000000
---- a/arch/s390/kernel/compat_wrapper.c
-+++ /dev/null
-@@ -1,128 +0,0 @@
--/*
-- *  Compat system call wrappers.
-- *
-- *    Copyright IBM Corp. 2014
-- */
--
--#include <linux/syscalls.h>
--#include <linux/compat.h>
--#include "entry.h"
--
--COMPAT_SYSCALL_WRAP2(creat, const char __user *, pathname, umode_t, mode);
--COMPAT_SYSCALL_WRAP2(link, const char __user *, oldname, const char __user *, newname);
--COMPAT_SYSCALL_WRAP1(unlink, const char __user *, pathname);
--COMPAT_SYSCALL_WRAP1(chdir, const char __user *, filename);
--COMPAT_SYSCALL_WRAP3(mknod, const char __user *, filename, umode_t, mode, unsigned, dev);
--COMPAT_SYSCALL_WRAP2(chmod, const char __user *, filename, umode_t, mode);
--COMPAT_SYSCALL_WRAP1(oldumount, char __user *, name);
--COMPAT_SYSCALL_WRAP2(access, const char __user *, filename, int, mode);
--COMPAT_SYSCALL_WRAP2(rename, const char __user *, oldname, const char __user *, newname);
--COMPAT_SYSCALL_WRAP2(mkdir, const char __user *, pathname, umode_t, mode);
--COMPAT_SYSCALL_WRAP1(rmdir, const char __user *, pathname);
--COMPAT_SYSCALL_WRAP1(pipe, int __user *, fildes);
--COMPAT_SYSCALL_WRAP1(brk, unsigned long, brk);
--COMPAT_SYSCALL_WRAP2(signal, int, sig, __sighandler_t, handler);
--COMPAT_SYSCALL_WRAP1(acct, const char __user *, name);
--COMPAT_SYSCALL_WRAP2(umount, char __user *, name, int, flags);
--COMPAT_SYSCALL_WRAP1(chroot, const char __user *, filename);
--COMPAT_SYSCALL_WRAP3(sigsuspend, int, unused1, int, unused2, old_sigset_t, mask);
--COMPAT_SYSCALL_WRAP2(sethostname, char __user *, name, int, len);
--COMPAT_SYSCALL_WRAP2(symlink, const char __user *, old, const char __user *, new);
--COMPAT_SYSCALL_WRAP3(readlink, const char __user *, path, char __user *, buf, int, bufsiz);
--COMPAT_SYSCALL_WRAP1(uselib, const char __user *, library);
--COMPAT_SYSCALL_WRAP2(swapon, const char __user *, specialfile, int, swap_flags);
--COMPAT_SYSCALL_WRAP4(reboot, int, magic1, int, magic2, unsigned int, cmd, void __user *, arg);
--COMPAT_SYSCALL_WRAP2(munmap, unsigned long, addr, size_t, len);
--COMPAT_SYSCALL_WRAP3(syslog, int, type, char __user *, buf, int, len);
--COMPAT_SYSCALL_WRAP1(swapoff, const char __user *, specialfile);
--COMPAT_SYSCALL_WRAP2(setdomainname, char __user *, name, int, len);
--COMPAT_SYSCALL_WRAP1(newuname, struct new_utsname __user *, name);
--COMPAT_SYSCALL_WRAP3(mprotect, unsigned long, start, size_t, len, unsigned long, prot);
--COMPAT_SYSCALL_WRAP3(init_module, void __user *, umod, unsigned long, len, const char __user *, uargs);
--COMPAT_SYSCALL_WRAP2(delete_module, const char __user *, name_user, unsigned int, flags);
--COMPAT_SYSCALL_WRAP4(quotactl, unsigned int, cmd, const char __user *, special, qid_t, id, void __user *, addr);
--COMPAT_SYSCALL_WRAP2(bdflush, int, func, long, data);
--COMPAT_SYSCALL_WRAP3(sysfs, int, option, unsigned long, arg1, unsigned long, arg2);
--COMPAT_SYSCALL_WRAP5(llseek, unsigned int, fd, unsigned long, high, unsigned long, low, loff_t __user *, result, unsigned int, whence);
--COMPAT_SYSCALL_WRAP3(msync, unsigned long, start, size_t, len, int, flags);
--COMPAT_SYSCALL_WRAP2(mlock, unsigned long, start, size_t, len);
--COMPAT_SYSCALL_WRAP2(munlock, unsigned long, start, size_t, len);
--COMPAT_SYSCALL_WRAP2(sched_setparam, pid_t, pid, struct sched_param __user *, param);
--COMPAT_SYSCALL_WRAP2(sched_getparam, pid_t, pid, struct sched_param __user *, param);
--COMPAT_SYSCALL_WRAP3(sched_setscheduler, pid_t, pid, int, policy, struct sched_param __user *, param);
--COMPAT_SYSCALL_WRAP5(mremap, unsigned long, addr, unsigned long, old_len, unsigned long, new_len, unsigned long, flags, unsigned long, new_addr);
--COMPAT_SYSCALL_WRAP3(poll, struct pollfd __user *, ufds, unsigned int, nfds, int, timeout);
--COMPAT_SYSCALL_WRAP5(prctl, int, option, unsigned long, arg2, unsigned long, arg3, unsigned long, arg4, unsigned long, arg5);
--COMPAT_SYSCALL_WRAP2(getcwd, char __user *, buf, unsigned long, size);
--COMPAT_SYSCALL_WRAP2(capget, cap_user_header_t, header, cap_user_data_t, dataptr);
--COMPAT_SYSCALL_WRAP2(capset, cap_user_header_t, header, const cap_user_data_t, data);
--COMPAT_SYSCALL_WRAP3(lchown, const char __user *, filename, uid_t, user, gid_t, group);
--COMPAT_SYSCALL_WRAP2(getgroups, int, gidsetsize, gid_t __user *, grouplist);
--COMPAT_SYSCALL_WRAP2(setgroups, int, gidsetsize, gid_t __user *, grouplist);
--COMPAT_SYSCALL_WRAP3(getresuid, uid_t __user *, ruid, uid_t __user *, euid, uid_t __user *, suid);
--COMPAT_SYSCALL_WRAP3(getresgid, gid_t __user *, rgid, gid_t __user *, egid, gid_t __user *, sgid);
--COMPAT_SYSCALL_WRAP3(chown, const char __user *, filename, uid_t, user, gid_t, group);
--COMPAT_SYSCALL_WRAP2(pivot_root, const char __user *, new_root, const char __user *, put_old);
--COMPAT_SYSCALL_WRAP3(mincore, unsigned long, start, size_t, len, unsigned char __user *, vec);
--COMPAT_SYSCALL_WRAP3(madvise, unsigned long, start, size_t, len, int, behavior);
--COMPAT_SYSCALL_WRAP5(setxattr, const char __user *, path, const char __user *, name, const void __user *, value, size_t, size, int, flags);
--COMPAT_SYSCALL_WRAP5(lsetxattr, const char __user *, path, const char __user *, name, const void __user *, value, size_t, size, int, flags);
--COMPAT_SYSCALL_WRAP5(fsetxattr, int, fd, const char __user *, name, const void __user *, value, size_t, size, int, flags);
--COMPAT_SYSCALL_WRAP3(getdents64, unsigned int, fd, struct linux_dirent64 __user *, dirent, unsigned int, count);
--COMPAT_SYSCALL_WRAP4(getxattr, const char __user *, path, const char __user *, name, void __user *, value, size_t, size);
--COMPAT_SYSCALL_WRAP4(lgetxattr, const char __user *, path, const char __user *, name, void __user *, value, size_t, size);
--COMPAT_SYSCALL_WRAP4(fgetxattr, int, fd, const char __user *, name, void __user *, value, size_t, size);
--COMPAT_SYSCALL_WRAP3(listxattr, const char __user *, path, char __user *, list, size_t, size);
--COMPAT_SYSCALL_WRAP3(llistxattr, const char __user *, path, char __user *, list, size_t, size);
--COMPAT_SYSCALL_WRAP3(flistxattr, int, fd, char __user *, list, size_t, size);
--COMPAT_SYSCALL_WRAP2(removexattr, const char __user *, path, const char __user *, name);
--COMPAT_SYSCALL_WRAP2(lremovexattr, const char __user *, path, const char __user *, name);
--COMPAT_SYSCALL_WRAP2(fremovexattr, int, fd, const char __user *, name);
--COMPAT_SYSCALL_WRAP1(set_tid_address, int __user *, tidptr);
--COMPAT_SYSCALL_WRAP4(epoll_ctl, int, epfd, int, op, int, fd, struct epoll_event __user *, event);
--COMPAT_SYSCALL_WRAP4(epoll_wait, int, epfd, struct epoll_event __user *, events, int, maxevents, int, timeout);
--COMPAT_SYSCALL_WRAP1(io_destroy, aio_context_t, ctx);
--COMPAT_SYSCALL_WRAP3(io_cancel, aio_context_t, ctx_id, struct iocb __user *, iocb, struct io_event __user *, result);
--COMPAT_SYSCALL_WRAP1(mq_unlink, const char __user *, name);
--COMPAT_SYSCALL_WRAP5(add_key, const char __user *, tp, const char __user *, dsc, const void __user *, pld, size_t, len, key_serial_t, id);
--COMPAT_SYSCALL_WRAP4(request_key, const char __user *, tp, const char __user *, dsc, const char __user *, info, key_serial_t, id);
--COMPAT_SYSCALL_WRAP5(remap_file_pages, unsigned long, start, unsigned long, size, unsigned long, prot, unsigned long, pgoff, unsigned long, flags);
--COMPAT_SYSCALL_WRAP3(inotify_add_watch, int, fd, const char __user *, path, u32, mask);
--COMPAT_SYSCALL_WRAP3(mkdirat, int, dfd, const char __user *, pathname, umode_t, mode);
--COMPAT_SYSCALL_WRAP4(mknodat, int, dfd, const char __user *, filename, umode_t, mode, unsigned, dev);
--COMPAT_SYSCALL_WRAP5(fchownat, int, dfd, const char __user *, filename, uid_t, user, gid_t, group, int, flag);
--COMPAT_SYSCALL_WRAP3(unlinkat, int, dfd, const char __user *, pathname, int, flag);
--COMPAT_SYSCALL_WRAP4(renameat, int, olddfd, const char __user *, oldname, int, newdfd, const char __user *, newname);
--COMPAT_SYSCALL_WRAP5(linkat, int, olddfd, const char __user *, oldname, int, newdfd, const char __user *, newname, int, flags);
--COMPAT_SYSCALL_WRAP3(symlinkat, const char __user *, oldname, int, newdfd, const char __user *, newname);
--COMPAT_SYSCALL_WRAP4(readlinkat, int, dfd, const char __user *, path, char __user *, buf, int, bufsiz);
--COMPAT_SYSCALL_WRAP3(fchmodat, int, dfd, const char __user *, filename, umode_t, mode);
--COMPAT_SYSCALL_WRAP3(faccessat, int, dfd, const char __user *, filename, int, mode);
--COMPAT_SYSCALL_WRAP1(unshare, unsigned long, unshare_flags);
--COMPAT_SYSCALL_WRAP6(splice, int, fd_in, loff_t __user *, off_in, int, fd_out, loff_t __user *, off_out, size_t, len, unsigned int, flags);
--COMPAT_SYSCALL_WRAP4(tee, int, fdin, int, fdout, size_t, len, unsigned int, flags);
--COMPAT_SYSCALL_WRAP3(getcpu, unsigned __user *, cpu, unsigned __user *, node, struct getcpu_cache __user *, cache);
--COMPAT_SYSCALL_WRAP2(pipe2, int __user *, fildes, int, flags);
--COMPAT_SYSCALL_WRAP5(perf_event_open, struct perf_event_attr __user *, attr_uptr, pid_t, pid, int, cpu, int, group_fd, unsigned long, flags);
--COMPAT_SYSCALL_WRAP5(clone, unsigned long, newsp, unsigned long, clone_flags, int __user *, parent_tidptr, int __user *, child_tidptr, unsigned long, tls);
--COMPAT_SYSCALL_WRAP4(prlimit64, pid_t, pid, unsigned int, resource, const struct rlimit64 __user *, new_rlim, struct rlimit64 __user *, old_rlim);
--COMPAT_SYSCALL_WRAP5(name_to_handle_at, int, dfd, const char __user *, name, struct file_handle __user *, handle, int __user *, mnt_id, int, flag);
--COMPAT_SYSCALL_WRAP5(kcmp, pid_t, pid1, pid_t, pid2, int, type, unsigned long, idx1, unsigned long, idx2);
--COMPAT_SYSCALL_WRAP3(finit_module, int, fd, const char __user *, uargs, int, flags);
--COMPAT_SYSCALL_WRAP3(sched_setattr, pid_t, pid, struct sched_attr __user *, attr, unsigned int, flags);
--COMPAT_SYSCALL_WRAP4(sched_getattr, pid_t, pid, struct sched_attr __user *, attr, unsigned int, size, unsigned int, flags);
--COMPAT_SYSCALL_WRAP5(renameat2, int, olddfd, const char __user *, oldname, int, newdfd, const char __user *, newname, unsigned int, flags);
--COMPAT_SYSCALL_WRAP3(seccomp, unsigned int, op, unsigned int, flags, const char __user *, uargs)
--COMPAT_SYSCALL_WRAP3(getrandom, char __user *, buf, size_t, count, unsigned int, flags)
--COMPAT_SYSCALL_WRAP2(memfd_create, const char __user *, uname, unsigned int, flags)
--COMPAT_SYSCALL_WRAP3(bpf, int, cmd, union bpf_attr *, attr, unsigned int, size);
--COMPAT_SYSCALL_WRAP3(s390_pci_mmio_write, const unsigned long, mmio_addr, const void __user *, user_buffer, const size_t, length);
--COMPAT_SYSCALL_WRAP3(s390_pci_mmio_read, const unsigned long, mmio_addr, void __user *, user_buffer, const size_t, length);
--COMPAT_SYSCALL_WRAP4(socketpair, int, family, int, type, int, protocol, int __user *, usockvec);
--COMPAT_SYSCALL_WRAP3(bind, int, fd, struct sockaddr __user *, umyaddr, int, addrlen);
--COMPAT_SYSCALL_WRAP3(connect, int, fd, struct sockaddr __user *, uservaddr, int, addrlen);
--COMPAT_SYSCALL_WRAP4(accept4, int, fd, struct sockaddr __user *, upeer_sockaddr, int __user *, upeer_addrlen, int, flags);
--COMPAT_SYSCALL_WRAP3(getsockname, int, fd, struct sockaddr __user *, usockaddr, int __user *, usockaddr_len);
--COMPAT_SYSCALL_WRAP3(getpeername, int, fd, struct sockaddr __user *, usockaddr, int __user *, usockaddr_len);
--COMPAT_SYSCALL_WRAP6(sendto, int, fd, void __user *, buff, size_t, len, unsigned int, flags, struct sockaddr __user *, addr, int, addr_len);
--COMPAT_SYSCALL_WRAP3(mlock2, unsigned long, start, size_t, len, int, flags);
-diff --git a/kernel/compat_wrapper.c b/kernel/compat_wrapper.c
-new file mode 100644
-index 0000000..b6c050e
---- /dev/null
-+++ b/kernel/compat_wrapper.c
-@@ -0,0 +1,175 @@
-+/*
-+ *  Compat system call wrappers.
-+ *
-+ *    Copyright IBM Corp. 2014
-+ */
-+
-+#include <linux/syscalls.h>
-+#include <linux/compat.h>
-+
-+COMPAT_SYSCALL_WRAP2(creat, const char __user *, pathname, umode_t, mode);
-+COMPAT_SYSCALL_WRAP2(link, const char __user *, oldname, const char __user *, newname);
-+COMPAT_SYSCALL_WRAP1(unlink, const char __user *, pathname);
-+COMPAT_SYSCALL_WRAP1(chdir, const char __user *, filename);
-+COMPAT_SYSCALL_WRAP3(mknod, const char __user *, filename, umode_t, mode, unsigned, dev);
-+COMPAT_SYSCALL_WRAP2(chmod, const char __user *, filename, umode_t, mode);
-+
-+#ifdef __ARCH_WANT_SYS_OLDUMOUNT
-+COMPAT_SYSCALL_WRAP1(oldumount, char __user *, name);
-+#endif
-+
-+COMPAT_SYSCALL_WRAP2(access, const char __user *, filename, int, mode);
-+COMPAT_SYSCALL_WRAP2(rename, const char __user *, oldname, const char __user *, newname);
-+COMPAT_SYSCALL_WRAP2(mkdir, const char __user *, pathname, umode_t, mode);
-+COMPAT_SYSCALL_WRAP1(rmdir, const char __user *, pathname);
-+COMPAT_SYSCALL_WRAP1(pipe, int __user *, fildes);
-+COMPAT_SYSCALL_WRAP1(brk, unsigned long, brk);
-+
-+#ifdef __ARCH_WANT_SYS_SIGNAL
-+COMPAT_SYSCALL_WRAP2(signal, int, sig, __sighandler_t, handler);
-+#endif
-+
-+COMPAT_SYSCALL_WRAP1(acct, const char __user *, name);
-+COMPAT_SYSCALL_WRAP2(umount, char __user *, name, int, flags);
-+COMPAT_SYSCALL_WRAP1(chroot, const char __user *, filename);
-+
-+#ifdef CONFIG_OLD_SIGSUSPEND
-+SYSCALL_DEFINE1(sigsuspend, old_sigset_t, mask);
-+#endif
-+
-+#ifdef CONFIG_OLD_SIGSUSPEND3
-+COMPAT_SYSCALL_WRAP3(sigsuspend, int, unused1, int, unused2, old_sigset_t, mask);
-+#endif
-+
-+COMPAT_SYSCALL_WRAP2(sethostname, char __user *, name, int, len);
-+COMPAT_SYSCALL_WRAP2(symlink, const char __user *, old, const char __user *, new);
-+COMPAT_SYSCALL_WRAP3(readlink, const char __user *, path, char __user *, buf, int, bufsiz);
-+COMPAT_SYSCALL_WRAP1(uselib, const char __user *, library);
-+COMPAT_SYSCALL_WRAP2(swapon, const char __user *, specialfile, int, swap_flags);
-+COMPAT_SYSCALL_WRAP4(reboot, int, magic1, int, magic2, unsigned int, cmd, void __user *, arg);
-+COMPAT_SYSCALL_WRAP2(munmap, unsigned long, addr, size_t, len);
-+COMPAT_SYSCALL_WRAP3(syslog, int, type, char __user *, buf, int, len);
-+COMPAT_SYSCALL_WRAP1(swapoff, const char __user *, specialfile);
-+COMPAT_SYSCALL_WRAP2(setdomainname, char __user *, name, int, len);
-+COMPAT_SYSCALL_WRAP1(newuname, struct new_utsname __user *, name);
-+COMPAT_SYSCALL_WRAP3(mprotect, unsigned long, start, size_t, len, unsigned long, prot);
-+COMPAT_SYSCALL_WRAP3(init_module, void __user *, umod, unsigned long, len, const char __user *, uargs);
-+COMPAT_SYSCALL_WRAP2(delete_module, const char __user *, name_user, unsigned int, flags);
-+COMPAT_SYSCALL_WRAP4(quotactl, unsigned int, cmd, const char __user *, special, qid_t, id, void __user *, addr);
-+COMPAT_SYSCALL_WRAP2(bdflush, int, func, long, data);
-+COMPAT_SYSCALL_WRAP3(sysfs, int, option, unsigned long, arg1, unsigned long, arg2);
-+
-+#ifdef __ARCH_WANT_SYS_LLSEEK
-+COMPAT_SYSCALL_WRAP5(llseek, unsigned int, fd, unsigned long, high, unsigned long, low, loff_t __user *, result, unsigned int, whence);
-+#endif
-+
-+COMPAT_SYSCALL_WRAP3(msync, unsigned long, start, size_t, len, int, flags);
-+COMPAT_SYSCALL_WRAP2(mlock, unsigned long, start, size_t, len);
-+COMPAT_SYSCALL_WRAP2(munlock, unsigned long, start, size_t, len);
-+COMPAT_SYSCALL_WRAP2(sched_setparam, pid_t, pid, struct sched_param __user *, param);
-+COMPAT_SYSCALL_WRAP2(sched_getparam, pid_t, pid, struct sched_param __user *, param);
-+COMPAT_SYSCALL_WRAP3(sched_setscheduler, pid_t, pid, int, policy, struct sched_param __user *, param);
-+COMPAT_SYSCALL_WRAP5(mremap, unsigned long, addr, unsigned long, old_len, unsigned long, new_len, unsigned long, flags, unsigned long, new_addr);
-+COMPAT_SYSCALL_WRAP3(poll, struct pollfd __user *, ufds, unsigned int, nfds, int, timeout);
-+COMPAT_SYSCALL_WRAP5(prctl, int, option, unsigned long, arg2, unsigned long, arg3, unsigned long, arg4, unsigned long, arg5);
-+COMPAT_SYSCALL_WRAP2(getcwd, char __user *, buf, unsigned long, size);
-+COMPAT_SYSCALL_WRAP2(capget, cap_user_header_t, header, cap_user_data_t, dataptr);
-+COMPAT_SYSCALL_WRAP2(capset, cap_user_header_t, header, const cap_user_data_t, data);
-+COMPAT_SYSCALL_WRAP3(lchown, const char __user *, filename, uid_t, user, gid_t, group);
-+COMPAT_SYSCALL_WRAP2(getgroups, int, gidsetsize, gid_t __user *, grouplist);
-+COMPAT_SYSCALL_WRAP2(setgroups, int, gidsetsize, gid_t __user *, grouplist);
-+COMPAT_SYSCALL_WRAP3(getresuid, uid_t __user *, ruid, uid_t __user *, euid, uid_t __user *, suid);
-+COMPAT_SYSCALL_WRAP3(getresgid, gid_t __user *, rgid, gid_t __user *, egid, gid_t __user *, sgid);
-+COMPAT_SYSCALL_WRAP3(chown, const char __user *, filename, uid_t, user, gid_t, group);
-+COMPAT_SYSCALL_WRAP2(pivot_root, const char __user *, new_root, const char __user *, put_old);
-+COMPAT_SYSCALL_WRAP3(mincore, unsigned long, start, size_t, len, unsigned char __user *, vec);
-+COMPAT_SYSCALL_WRAP3(madvise, unsigned long, start, size_t, len, int, behavior);
-+COMPAT_SYSCALL_WRAP5(setxattr, const char __user *, path, const char __user *, name, const void __user *, value, size_t, size, int, flags);
-+COMPAT_SYSCALL_WRAP5(lsetxattr, const char __user *, path, const char __user *, name, const void __user *, value, size_t, size, int, flags);
-+COMPAT_SYSCALL_WRAP5(fsetxattr, int, fd, const char __user *, name, const void __user *, value, size_t, size, int, flags);
-+
-+#ifndef __ARCH_WANT_COMPAT_SYS_GETDENTS64
-+COMPAT_SYSCALL_WRAP3(getdents64, unsigned int, fd, struct linux_dirent64 __user *, dirent, unsigned int, count);
-+#endif
-+
-+COMPAT_SYSCALL_WRAP4(getxattr, const char __user *, path, const char __user *, name, void __user *, value, size_t, size);
-+COMPAT_SYSCALL_WRAP4(lgetxattr, const char __user *, path, const char __user *, name, void __user *, value, size_t, size);
-+COMPAT_SYSCALL_WRAP4(fgetxattr, int, fd, const char __user *, name, void __user *, value, size_t, size);
-+COMPAT_SYSCALL_WRAP3(listxattr, const char __user *, path, char __user *, list, size_t, size);
-+COMPAT_SYSCALL_WRAP3(llistxattr, const char __user *, path, char __user *, list, size_t, size);
-+COMPAT_SYSCALL_WRAP3(flistxattr, int, fd, char __user *, list, size_t, size);
-+COMPAT_SYSCALL_WRAP2(removexattr, const char __user *, path, const char __user *, name);
-+COMPAT_SYSCALL_WRAP2(lremovexattr, const char __user *, path, const char __user *, name);
-+COMPAT_SYSCALL_WRAP2(fremovexattr, int, fd, const char __user *, name);
-+COMPAT_SYSCALL_WRAP1(set_tid_address, int __user *, tidptr);
-+COMPAT_SYSCALL_WRAP4(epoll_ctl, int, epfd, int, op, int, fd, struct epoll_event __user *, event);
-+COMPAT_SYSCALL_WRAP4(epoll_wait, int, epfd, struct epoll_event __user *, events, int, maxevents, int, timeout);
-+COMPAT_SYSCALL_WRAP1(io_destroy, aio_context_t, ctx);
-+COMPAT_SYSCALL_WRAP3(io_cancel, aio_context_t, ctx_id, struct iocb __user *, iocb, struct io_event __user *, result);
-+COMPAT_SYSCALL_WRAP1(mq_unlink, const char __user *, name);
-+COMPAT_SYSCALL_WRAP5(add_key, const char __user *, tp, const char __user *, dsc, const void __user *, pld, size_t, len, key_serial_t, id);
-+COMPAT_SYSCALL_WRAP4(request_key, const char __user *, tp, const char __user *, dsc, const char __user *, info, key_serial_t, id);
-+COMPAT_SYSCALL_WRAP5(remap_file_pages, unsigned long, start, unsigned long, size, unsigned long, prot, unsigned long, pgoff, unsigned long, flags);
-+COMPAT_SYSCALL_WRAP3(inotify_add_watch, int, fd, const char __user *, path, u32, mask);
-+COMPAT_SYSCALL_WRAP3(mkdirat, int, dfd, const char __user *, pathname, umode_t, mode);
-+COMPAT_SYSCALL_WRAP4(mknodat, int, dfd, const char __user *, filename, umode_t, mode, unsigned, dev);
-+COMPAT_SYSCALL_WRAP5(fchownat, int, dfd, const char __user *, filename, uid_t, user, gid_t, group, int, flag);
-+COMPAT_SYSCALL_WRAP3(unlinkat, int, dfd, const char __user *, pathname, int, flag);
-+COMPAT_SYSCALL_WRAP4(renameat, int, olddfd, const char __user *, oldname, int, newdfd, const char __user *, newname);
-+COMPAT_SYSCALL_WRAP5(linkat, int, olddfd, const char __user *, oldname, int, newdfd, const char __user *, newname, int, flags);
-+COMPAT_SYSCALL_WRAP3(symlinkat, const char __user *, oldname, int, newdfd, const char __user *, newname);
-+COMPAT_SYSCALL_WRAP4(readlinkat, int, dfd, const char __user *, path, char __user *, buf, int, bufsiz);
-+COMPAT_SYSCALL_WRAP3(fchmodat, int, dfd, const char __user *, filename, umode_t, mode);
-+COMPAT_SYSCALL_WRAP3(faccessat, int, dfd, const char __user *, filename, int, mode);
-+COMPAT_SYSCALL_WRAP1(unshare, unsigned long, unshare_flags);
-+COMPAT_SYSCALL_WRAP6(splice, int, fd_in, loff_t __user *, off_in, int, fd_out, loff_t __user *, off_out, size_t, len, unsigned int, flags);
-+COMPAT_SYSCALL_WRAP4(tee, int, fdin, int, fdout, size_t, len, unsigned int, flags);
-+COMPAT_SYSCALL_WRAP3(getcpu, unsigned __user *, cpu, unsigned __user *, node, struct getcpu_cache __user *, cache);
-+COMPAT_SYSCALL_WRAP2(pipe2, int __user *, fildes, int, flags);
-+COMPAT_SYSCALL_WRAP5(perf_event_open, struct perf_event_attr __user *, attr_uptr, pid_t, pid, int, cpu, int, group_fd, unsigned long, flags);
-+
-+#ifdef __ARCH_WANT_SYS_CLONE
-+#ifdef CONFIG_CLONE_BACKWARDS
-+COMPAT_SYSCALL_WRAP5(clone, unsigned long, clone_flags, unsigned long, newsp,
-+                int __user *, parent_tidptr,
-+                unsigned long, tls,
-+                int __user *, child_tidptr);
-+#elif defined(CONFIG_CLONE_BACKWARDS2)
-+       COMPAT_SYSCALL_WRAP5(clone, unsigned long, newsp, unsigned long, clone_flags,
-+               int __user *, parent_tidptr,
-+               int __user *, child_tidptr,
-+               unsigned long, tls);
-+#elif defined(CONFIG_CLONE_BACKWARDS3)
-+       COMPAT_SYSCALL_WRAP6(clone, unsigned long, clone_flags, unsigned long, newsp,
-+              int, stack_size,
-+              int __user *, parent_tidptr,
-+              int __user *, child_tidptr,
-+               unsigned long, tls);
-+#else
-+COMPAT_SYSCALL_WRAP5(clone, unsigned long, clone_flags, unsigned long, newsp,
-+       int __user *, parent_tidptr,
-+       int __user *, child_tidptr,
-+       unsigned long, tls);
-+#endif
-+#endif
-+
-+COMPAT_SYSCALL_WRAP4(prlimit64, pid_t, pid, unsigned int, resource, const struct rlimit64 __user *, new_rlim, struct rlimit64 __user *, old_rlim);
-+COMPAT_SYSCALL_WRAP5(name_to_handle_at, int, dfd, const char __user *, name, struct file_handle __user *, handle, int __user *, mnt_id, int, flag);
-+COMPAT_SYSCALL_WRAP5(kcmp, pid_t, pid1, pid_t, pid2, int, type, unsigned long, idx1, unsigned long, idx2);
-+COMPAT_SYSCALL_WRAP3(finit_module, int, fd, const char __user *, uargs, int, flags);
-+COMPAT_SYSCALL_WRAP3(sched_setattr, pid_t, pid, struct sched_attr __user *, attr, unsigned int, flags);
-+COMPAT_SYSCALL_WRAP4(sched_getattr, pid_t, pid, struct sched_attr __user *, attr, unsigned int, size, unsigned int, flags);
-+COMPAT_SYSCALL_WRAP5(renameat2, int, olddfd, const char __user *, oldname, int, newdfd, const char __user *, newname, unsigned int, flags);
-+COMPAT_SYSCALL_WRAP3(seccomp, unsigned int, op, unsigned int, flags, const char __user *, uargs)
-+COMPAT_SYSCALL_WRAP3(getrandom, char __user *, buf, size_t, count, unsigned int, flags)
-+COMPAT_SYSCALL_WRAP2(memfd_create, const char __user *, uname, unsigned int, flags)
-+COMPAT_SYSCALL_WRAP3(bpf, int, cmd, union bpf_attr *, attr, unsigned int, size);
-+COMPAT_SYSCALL_WRAP4(socketpair, int, family, int, type, int, protocol, int __user *, usockvec);
-+COMPAT_SYSCALL_WRAP3(bind, int, fd, struct sockaddr __user *, umyaddr, int, addrlen);
-+COMPAT_SYSCALL_WRAP3(connect, int, fd, struct sockaddr __user *, uservaddr, int, addrlen);
-+COMPAT_SYSCALL_WRAP4(accept4, int, fd, struct sockaddr __user *, upeer_sockaddr, int __user *, upeer_addrlen, int, flags);
-+COMPAT_SYSCALL_WRAP3(getsockname, int, fd, struct sockaddr __user *, usockaddr, int __user *, usockaddr_len);
-+COMPAT_SYSCALL_WRAP3(getpeername, int, fd, struct sockaddr __user *, usockaddr, int __user *, usockaddr_len);
-+COMPAT_SYSCALL_WRAP6(sendto, int, fd, void __user *, buff, size_t, len, unsigned int, flags, struct sockaddr __user *, addr, int, addr_len);
-+COMPAT_SYSCALL_WRAP3(mlock2, unsigned long, start, size_t, len, int, flags);
-+COMPAT_SYSCALL_WRAP6(copy_file_range, int, fd_in, loff_t __user *, off_in, int, fd_out, loff_t __user *, off_out, size_t, len, unsigned int, flags);
--- 
-1.9.1
-
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0004-arm64-ilp32-add-documentation-on-the-ILP32-ABI-for-A.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0004-arm64-ilp32-add-documentation-on-the-ILP32-ABI-for-A.patch
new file mode 100644
index 0000000..93419bf
--- /dev/null
+++ b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0004-arm64-ilp32-add-documentation-on-the-ILP32-ABI-for-A.patch
@@ -0,0 +1,68 @@
+From 589771d789b1931444cb423859b478858f9f84bb Mon Sep 17 00:00:00 2001
+From: Yury Norov <ynorov@caviumnetworks.com>
+Date: Tue, 24 May 2016 03:04:37 +0300
+Subject: [PATCH 04/20] arm64: ilp32: add documentation on the ILP32 ABI for
+ ARM64
+
+Based on Andrew Pinski's patch-series.
+
+Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
+---
+ Documentation/arm64/ilp32.txt | 45 +++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 45 insertions(+)
+ create mode 100644 Documentation/arm64/ilp32.txt
+
+diff --git a/Documentation/arm64/ilp32.txt b/Documentation/arm64/ilp32.txt
+new file mode 100644
+index 0000000..08935a3
+--- /dev/null
++++ b/Documentation/arm64/ilp32.txt
+@@ -0,0 +1,45 @@
++ILP32 AARCH64 SYSCALL ABI
++=========================
++
++This document describes the ILP32 syscall ABI and where it differs
++from the generic compat linux syscall interface.
++
++AARCH64/ILP32 userspace can pass garbage in the top halve of w0-w7 registers
++(syscall arguments). So top 32 bits are zeroed for them.
++
++Comparing to AARCH32, AARCH64/ILP32 has 64-bit length of following types:
++ino_t       is u64 type.
++off_t       is s64 type.
++blkcnt_t    is s64 type.
++fsblkcnt_t  is u64 type.
++fsfilcnt_t  is u64 type.
++rlim_t      is u64 type.
++
++AARCH64/ILP32 ABI uses standard syscall table which can be found at
++include/uapi/asm-generic/unistd.h, with the exceptions listed below.
++
++Syscalls which pass 64-bit values are handled by the code shared from
++AARCH32 and pass that value as a pair. Next syscalls are affected:
++fadvise64_64()
++fallocate()
++ftruncate64()
++pread64()
++pwrite64()
++readahead()
++sync_file_range()
++truncate64()
++
++ptrace() syscall is handled by compat version.
++
++shmat() syscall is handled by non-compat handler as aarch64/ilp32 has no
++limitation on 4-pages alignement for shared memory.
++
++statfs() and fstatfs() take the size of struct statfs as an argument.
++It is calculated differently in kernel and user spaces. So AARCH32 handlers
++are taken to handle it.
++
++struct rt_sigframe is redefined and contains struct compat_siginfo,
++as compat syscalls expects, and struct ilp32_sigframe, to handle
++AARCH64 register set and 32-bit userspace register representation.
++
++elf_gregset_t is taken from lp64 to handle registers properly.
+-- 
+2.5.0
+
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0005-all-wrap-needed-syscalls-in-generic-unistd.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0005-all-wrap-needed-syscalls-in-generic-unistd.patch
deleted file mode 100644
index f12af55..0000000
--- a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0005-all-wrap-needed-syscalls-in-generic-unistd.patch
+++ /dev/null
@@ -1,866 +0,0 @@
-From aadecd5d49d3e5ca010fcde91bd50e9cf9ab777f Mon Sep 17 00:00:00 2001
-From: Yury Norov <ynorov@caviumnetworks.com>
-Date: Tue, 24 May 2016 03:04:34 +0300
-Subject: [PATCH 05/24] all: wrap needed syscalls in generic unistd
-
-As generic unistd syscall table is written in C, syscall
-prototypes declaration is needed. It's added to compat header.
-
-Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
----
- arch/s390/kernel/Makefile         |   2 +-
- arch/s390/kernel/compat_linux.c   |   4 +
- include/linux/compat.h            | 221 +++++++++++++++++++++++++++++++++++++
- include/uapi/asm-generic/unistd.h | 225 +++++++++++++++++++-------------------
- kernel/Makefile                   |   1 +
- kernel/compat_wrapper.c           |   1 -
- 6 files changed, 339 insertions(+), 115 deletions(-)
-
-diff --git a/arch/s390/kernel/Makefile b/arch/s390/kernel/Makefile
-index dc167a2..185cd88 100644
---- a/arch/s390/kernel/Makefile
-+++ b/arch/s390/kernel/Makefile
-@@ -55,7 +55,7 @@ obj-$(CONFIG_HIBERNATION)	+= suspend.o swsusp.o
- obj-$(CONFIG_AUDIT)		+= audit.o
- compat-obj-$(CONFIG_AUDIT)	+= compat_audit.o
- obj-$(CONFIG_COMPAT)		+= compat_linux.o compat_signal.o
--obj-$(CONFIG_COMPAT)		+= compat_wrapper.o $(compat-obj-y)
-+obj-$(CONFIG_COMPAT)		+= $(compat-obj-y)
- 
- obj-$(CONFIG_STACKTRACE)	+= stacktrace.o
- obj-$(CONFIG_KPROBES)		+= kprobes.o
-diff --git a/arch/s390/kernel/compat_linux.c b/arch/s390/kernel/compat_linux.c
-index 437e611..783c208 100644
---- a/arch/s390/kernel/compat_linux.c
-+++ b/arch/s390/kernel/compat_linux.c
-@@ -86,6 +86,10 @@
- #define SET_STAT_UID(stat, uid)		(stat).st_uid = high2lowuid(uid)
- #define SET_STAT_GID(stat, gid)		(stat).st_gid = high2lowgid(gid)
- 
-+COMPAT_SYSCALL_WRAP3(s390_pci_mmio_write, const unsigned long, mmio_addr, const void __user *, user_buffer, const size_t, length);
-+
-+COMPAT_SYSCALL_WRAP3(s390_pci_mmio_read, const unsigned long, mmio_addr, void __user *, user_buffer, const size_t, length);
-+
- COMPAT_SYSCALL_DEFINE3(s390_chown16, const char __user *, filename,
- 		       u16, user, u16, group)
- {
-diff --git a/include/linux/compat.h b/include/linux/compat.h
-index 72ef245..0ea5587 100644
---- a/include/linux/compat.h
-+++ b/include/linux/compat.h
-@@ -769,6 +769,227 @@ asmlinkage long notrace compat_SyS##name(__MAP(x,__SC_COMPAT_TYPE,__VA_ARGS__))
- }
- #endif /* COMPAT_SYSCALL_WRAPx */
- 
-+/* Compat wrappers */
-+#include <linux/syscalls_structs.h>
-+asmlinkage long compat_sys_creat(const char __user *pathname, umode_t mode);
-+asmlinkage long compat_sys_link(const char __user *oldname,
-+				const char __user *newname);
-+asmlinkage long compat_sys_chdir(const char __user *filename);
-+asmlinkage long compat_sys_mknod(const char __user *filename, umode_t mode,
-+				unsigned dev);
-+asmlinkage long compat_sys_chmod(const char __user *filename, umode_t mode);
-+asmlinkage long compat_sys_oldumount(char __user *name);
-+asmlinkage long compat_sys_access(const char __user *filename, int mode);
-+asmlinkage long compat_sys_rename(const char __user *oldname,
-+				const char __user *newname);
-+asmlinkage long compat_sys_mkdir(const char __user *pathname, umode_t mode);
-+asmlinkage long compat_sys_rmdir(const char __user *pathname);
-+asmlinkage long compat_sys_pipe(int __user *fildes);
-+asmlinkage long compat_sys_brk(unsigned long brk);
-+asmlinkage long compat_sys_signal(int sig, __sighandler_t handler);
-+asmlinkage long compat_sys_acct(const char __user *name);
-+asmlinkage long compat_sys_umount(char __user *name, int flags);
-+asmlinkage long compat_sys_chroot(const char __user *filename);
-+
-+#ifdef CONFIG_OLD_SIGSUSPEND
-+asmlinkage long compat_sys_sigsuspend(old_sigset_t mask);
-+#endif
-+
-+#ifdef CONFIG_OLD_SIGSUSPEND3
-+asmlinkage long compat_sys_sigsuspend(int unused1, int unused2, old_sigset_t mask);
-+#endif
-+
-+asmlinkage long compat_sys_sethostname(char __user *name, int len);
-+asmlinkage long compat_sys_symlink(const char __user *old, const char __user *new);
-+asmlinkage long compat_sys_readlink(const char __user *path,
-+				char __user *buf, int bufsiz);
-+asmlinkage long compat_sys_uselib(const char __user *library);
-+asmlinkage long compat_sys_swapon(const char __user *specialfile, int swap_flags);
-+asmlinkage long compat_sys_reboot(int magic1, int magic2, unsigned int cmd,
-+				void __user *arg);
-+asmlinkage long compat_sys_munmap(unsigned long addr, size_t len);
-+asmlinkage long compat_sys_munmap(unsigned long addr, size_t len);
-+asmlinkage long compat_sys_syslog(int type, char __user *buf, int len);
-+asmlinkage long compat_sys_swapoff(const char __user *specialfile);
-+asmlinkage long compat_sys_setdomainname(char __user *name, int len);
-+asmlinkage long compat_sys_newuname(struct new_utsname __user *name);
-+asmlinkage long compat_sys_mprotect(unsigned long start, size_t len,
-+				unsigned long prot);
-+asmlinkage long compat_sys_init_module(void __user *umod, unsigned long len,
-+				const char __user *uargs);
-+asmlinkage long compat_sys_delete_module(const char __user *name_user,
-+				unsigned int flags);
-+asmlinkage long compat_sys_quotactl(unsigned int cmd, const char __user *special,
-+				qid_t id, void __user *addr);
-+asmlinkage long compat_sys_bdflush(int func, long data);
-+asmlinkage long compat_sys_sysfs(int option,
-+				unsigned long arg1, unsigned long arg2);
-+asmlinkage long compat_sys_llseek(unsigned int fd, unsigned long offset_high,
-+			unsigned long offset_low, loff_t __user *result,
-+			unsigned int whence);
-+asmlinkage long compat_sys_msync(unsigned long start, size_t len, int flags);
-+asmlinkage long compat_sys_mlock(unsigned long start, size_t len);
-+asmlinkage long compat_sys_munlock(unsigned long start, size_t len);
-+asmlinkage long compat_sys_sched_setparam(pid_t pid,
-+					struct sched_param __user *param);
-+asmlinkage long compat_sys_sched_getparam(pid_t pid,
-+					struct sched_param __user *param);
-+asmlinkage long compat_sys_sched_setscheduler(pid_t pid, int policy,
-+					struct sched_param __user *param);
-+asmlinkage long compat_sys_mremap(unsigned long addr,
-+			   unsigned long old_len, unsigned long new_len,
-+			   unsigned long flags, unsigned long new_addr);
-+asmlinkage long compat_sys_poll(struct pollfd __user *ufds, unsigned int nfds,
-+				int timeout);
-+asmlinkage long compat_sys_prctl(int option, unsigned long arg2, unsigned long arg3,
-+			unsigned long arg4, unsigned long arg5);
-+asmlinkage long compat_sys_getcwd(char __user *buf, unsigned long size);
-+asmlinkage long compat_sys_capget(cap_user_header_t header,
-+				cap_user_data_t dataptr);
-+asmlinkage long compat_sys_capset(cap_user_header_t header,
-+				const cap_user_data_t data);
-+asmlinkage long compat_sys_lchown(const char __user *filename,
-+				uid_t user, gid_t group);
-+asmlinkage long compat_sys_getgroups(int gidsetsize, gid_t __user *grouplist);
-+asmlinkage long compat_sys_setgroups(int gidsetsize, gid_t __user *grouplist);
-+asmlinkage long compat_sys_getresuid(uid_t __user *ruid, uid_t __user *euid, uid_t __user *suid);
-+asmlinkage long compat_sys_getresgid(gid_t __user *rgid, gid_t __user *egid, gid_t __user *sgid);
-+asmlinkage long compat_sys_chown(const char __user *filename,
-+				uid_t user, gid_t group);
-+asmlinkage long compat_sys_pivot_root(const char __user *new_root,
-+				const char __user *put_old);
-+asmlinkage long compat_sys_mincore(unsigned long start, size_t len,
-+				unsigned char __user * vec);
-+asmlinkage long compat_sys_madvise(unsigned long start, size_t len, int behavior);
-+asmlinkage long compat_sys_setxattr(const char __user *path, const char __user *name,
-+			     const void __user *value, size_t size, int flags);
-+asmlinkage long compat_sys_lsetxattr(const char __user *path, const char __user *name,
-+			      const void __user *value, size_t size, int flags);
-+asmlinkage long compat_sys_fsetxattr(int fd, const char __user *name,
-+			      const void __user *value, size_t size, int flags);
-+asmlinkage long compat_sys_getdents64(unsigned int fd,
-+				struct linux_dirent64 __user *dirent,
-+				unsigned int count);
-+asmlinkage long compat_sys_getxattr(const char __user *path, const char __user *name,
-+			     void __user *value, size_t size);
-+asmlinkage long compat_sys_lgetxattr(const char __user *path, const char __user *name,
-+			      void __user *value, size_t size);
-+asmlinkage long compat_sys_fgetxattr(int fd, const char __user *name,
-+			      void __user *value, size_t size);
-+asmlinkage long compat_sys_listxattr(const char __user *path, char __user *list,
-+			      size_t size);
-+asmlinkage long compat_sys_llistxattr(const char __user *path, char __user *list,
-+			       size_t size);
-+asmlinkage long compat_sys_flistxattr(int fd, char __user *list, size_t size);
-+asmlinkage long compat_sys_listxattr(const char __user *path, char __user *list,
-+			      size_t size);
-+asmlinkage long compat_sys_llistxattr(const char __user *path, char __user *list,
-+			       size_t size);
-+asmlinkage long compat_sys_flistxattr(int fd, char __user *list, size_t size);
-+asmlinkage long compat_sys_removexattr(const char __user *path,
-+				const char __user *name);
-+asmlinkage long compat_sys_lremovexattr(const char __user *path,
-+				 const char __user *name);
-+asmlinkage long compat_sys_fremovexattr(int fd, const char __user *name);
-+asmlinkage long compat_sys_set_tid_address(int __user *tidptr);
-+asmlinkage long compat_sys_epoll_ctl(int epfd, int op, int fd,
-+				struct epoll_event __user *event);
-+asmlinkage long compat_sys_epoll_wait(int epfd, struct epoll_event __user *events,
-+				int maxevents, int timeout);
-+asmlinkage long compat_sys_io_destroy(aio_context_t ctx);
-+asmlinkage long compat_sys_io_cancel(aio_context_t ctx_id, struct iocb __user *iocb,
-+			      struct io_event __user *result);
-+asmlinkage long compat_sys_mq_unlink(const char __user *name);
-+asmlinkage long compat_sys_add_key(const char __user *_type,
-+			    const char __user *_description,
-+			    const void __user *_payload,
-+			    size_t plen,
-+			    key_serial_t destringid);
-+asmlinkage long compat_sys_request_key(const char __user *_type,
-+				const char __user *_description,
-+				const char __user *_callout_info,
-+				key_serial_t destringid);
-+asmlinkage long compat_sys_remap_file_pages(unsigned long start, unsigned long size,
-+			unsigned long prot, unsigned long pgoff,
-+			unsigned long flags);
-+asmlinkage long compat_sys_inotify_add_watch(int fd, const char __user *path,
-+					u32 mask);
-+asmlinkage long compat_sys_mknodat(int dfd, const char __user * filename, umode_t mode,
-+			    unsigned dev);
-+asmlinkage long compat_sys_mkdirat(int dfd, const char __user * pathname, umode_t mode);
-+asmlinkage long compat_sys_fchownat(int dfd, const char __user *filename, uid_t user,
-+			     gid_t group, int flag);
-+asmlinkage long compat_sys_unlinkat(int dfd, const char __user * pathname, int flag);
-+asmlinkage long compat_sys_renameat(int olddfd, const char __user * oldname,
-+			     int newdfd, const char __user * newname);
-+asmlinkage long compat_sys_symlinkat(const char __user * oldname,
-+			      int newdfd, const char __user * newname);
-+asmlinkage long compat_sys_linkat(int olddfd, const char __user *oldname,
-+			   int newdfd, const char __user *newname, int flags);
-+asmlinkage long compat_sys_readlinkat(int dfd, const char __user *path, char __user *buf,
-+			       int bufsiz);
-+asmlinkage long compat_sys_fchmodat(int dfd, const char __user * filename,
-+			     umode_t mode);
-+asmlinkage long compat_sys_faccessat(int dfd, const char __user *filename, int mode);
-+asmlinkage long compat_sys_unshare(unsigned long unshare_flags);
-+asmlinkage long compat_sys_splice(int fd_in, loff_t __user *off_in,
-+			   int fd_out, loff_t __user *off_out,
-+			   size_t len, unsigned int flags);
-+asmlinkage long compat_sys_tee(int fdin, int fdout, size_t len, unsigned int flags);
-+asmlinkage long compat_sys_getcpu(unsigned __user *cpu, unsigned __user *node, struct getcpu_cache __user *cache);
-+asmlinkage long compat_sys_pipe2(int __user *fildes, int flags);
-+asmlinkage long compat_sys_perf_event_open(
-+		struct perf_event_attr __user *attr_uptr,
-+		pid_t pid, int cpu, int group_fd, unsigned long flags);
-+
-+#ifdef CONFIG_CLONE_BACKWARDS
-+asmlinkage long compat_sys_clone(unsigned long, unsigned long, int __user *, unsigned long,
-+	       int __user *);
-+#else
-+#ifdef CONFIG_CLONE_BACKWARDS3
-+asmlinkage long compat_sys_clone(unsigned long, unsigned long, int, int __user *,
-+			  int __user *, unsigned long);
-+#else
-+asmlinkage long compat_sys_clone(unsigned long, unsigned long, int __user *,
-+	       int __user *, unsigned long);
-+#endif
-+#endif
-+
-+asmlinkage long compat_sys_prlimit64(pid_t pid, unsigned int resource,
-+				const struct rlimit64 __user *new_rlim,
-+				struct rlimit64 __user *old_rlim);
-+asmlinkage long compat_sys_name_to_handle_at(int dfd, const char __user *name,
-+				      struct file_handle __user *handle,
-+				      int __user *mnt_id, int flag);
-+asmlinkage long compat_sys_kcmp(pid_t pid1, pid_t pid2, int type,
-+			 unsigned long idx1, unsigned long idx2);
-+asmlinkage long compat_sys_finit_module(int fd, const char __user *uargs, int flags);
-+asmlinkage long compat_sys_sched_setattr(pid_t pid,
-+					struct sched_attr __user *attr,
-+					unsigned int flags);
-+asmlinkage long compat_sys_sched_getattr(pid_t pid,
-+					struct sched_attr __user *attr,
-+					unsigned int size,
-+					unsigned int flags);
-+asmlinkage long compat_sys_renameat2(int olddfd, const char __user *oldname,
-+			      int newdfd, const char __user *newname,
-+			      unsigned int flags);
-+asmlinkage long compat_sys_seccomp(unsigned int op, unsigned int flags,
-+			    const char __user *uargs);
-+asmlinkage long compat_sys_getrandom(char __user *buf, size_t count,
-+			      unsigned int flags);
-+asmlinkage long compat_sys_memfd_create(const char __user *uname_ptr, unsigned int flags);
-+asmlinkage long compat_sys_bpf(int cmd, union bpf_attr *attr, unsigned int size);
-+asmlinkage long compat_sys_socketpair(int, int, int, int __user *);
-+asmlinkage long compat_sys_bind(int, struct sockaddr __user *, int);
-+asmlinkage long compat_sys_connect(int, struct sockaddr __user *, int);
-+asmlinkage long compat_sys_accept4(int, struct sockaddr __user *, int __user *, int);
-+asmlinkage long compat_sys_getsockname(int, struct sockaddr __user *, int __user *);
-+asmlinkage long compat_sys_getpeername(int, struct sockaddr __user *, int __user *);
-+asmlinkage long compat_sys_sendto(int, void __user *, size_t, unsigned,
-+				struct sockaddr __user *, int);
-+asmlinkage long compat_sys_mlock2(unsigned long start, size_t len, int flags);
-+
- #endif /* CONFIG_COMPAT_WRAPPER */
- 
- #endif /* _LINUX_COMPAT_H */
-diff --git a/include/uapi/asm-generic/unistd.h b/include/uapi/asm-generic/unistd.h
-index a8380ad..c054def 100644
---- a/include/uapi/asm-generic/unistd.h
-+++ b/include/uapi/asm-generic/unistd.h
-@@ -36,43 +36,43 @@
- #define __NR_io_setup 0
- __SC_COMP(__NR_io_setup, sys_io_setup, compat_sys_io_setup)
- #define __NR_io_destroy 1
--__SYSCALL(__NR_io_destroy, sys_io_destroy)
-+__SC_WRAP(__NR_io_destroy, sys_io_destroy)
- #define __NR_io_submit 2
- __SC_COMP(__NR_io_submit, sys_io_submit, compat_sys_io_submit)
- #define __NR_io_cancel 3
--__SYSCALL(__NR_io_cancel, sys_io_cancel)
-+__SC_WRAP(__NR_io_cancel, sys_io_cancel)
- #define __NR_io_getevents 4
- __SC_COMP(__NR_io_getevents, sys_io_getevents, compat_sys_io_getevents)
- 
- /* fs/xattr.c */
- #define __NR_setxattr 5
--__SYSCALL(__NR_setxattr, sys_setxattr)
-+__SC_WRAP(__NR_setxattr, sys_setxattr)
- #define __NR_lsetxattr 6
--__SYSCALL(__NR_lsetxattr, sys_lsetxattr)
-+__SC_WRAP(__NR_lsetxattr, sys_lsetxattr)
- #define __NR_fsetxattr 7
--__SYSCALL(__NR_fsetxattr, sys_fsetxattr)
-+__SC_WRAP(__NR_fsetxattr, sys_fsetxattr)
- #define __NR_getxattr 8
--__SYSCALL(__NR_getxattr, sys_getxattr)
-+__SC_WRAP(__NR_getxattr, sys_getxattr)
- #define __NR_lgetxattr 9
--__SYSCALL(__NR_lgetxattr, sys_lgetxattr)
-+__SC_WRAP(__NR_lgetxattr, sys_lgetxattr)
- #define __NR_fgetxattr 10
--__SYSCALL(__NR_fgetxattr, sys_fgetxattr)
-+__SC_WRAP(__NR_fgetxattr, sys_fgetxattr)
- #define __NR_listxattr 11
--__SYSCALL(__NR_listxattr, sys_listxattr)
-+__SC_WRAP(__NR_listxattr, sys_listxattr)
- #define __NR_llistxattr 12
--__SYSCALL(__NR_llistxattr, sys_llistxattr)
-+__SC_WRAP(__NR_llistxattr, sys_llistxattr)
- #define __NR_flistxattr 13
--__SYSCALL(__NR_flistxattr, sys_flistxattr)
-+__SC_WRAP(__NR_flistxattr, sys_flistxattr)
- #define __NR_removexattr 14
--__SYSCALL(__NR_removexattr, sys_removexattr)
-+__SC_WRAP(__NR_removexattr, sys_removexattr)
- #define __NR_lremovexattr 15
--__SYSCALL(__NR_lremovexattr, sys_lremovexattr)
-+__SC_WRAP(__NR_lremovexattr, sys_lremovexattr)
- #define __NR_fremovexattr 16
--__SYSCALL(__NR_fremovexattr, sys_fremovexattr)
-+__SC_WRAP(__NR_fremovexattr, sys_fremovexattr)
- 
- /* fs/dcache.c */
- #define __NR_getcwd 17
--__SYSCALL(__NR_getcwd, sys_getcwd)
-+__SC_WRAP(__NR_getcwd, sys_getcwd)
- 
- /* fs/cookies.c */
- #define __NR_lookup_dcookie 18
-@@ -86,7 +86,7 @@ __SYSCALL(__NR_eventfd2, sys_eventfd2)
- #define __NR_epoll_create1 20
- __SYSCALL(__NR_epoll_create1, sys_epoll_create1)
- #define __NR_epoll_ctl 21
--__SYSCALL(__NR_epoll_ctl, sys_epoll_ctl)
-+__SC_WRAP(__NR_epoll_ctl, sys_epoll_ctl)
- #define __NR_epoll_pwait 22
- __SC_COMP(__NR_epoll_pwait, sys_epoll_pwait, compat_sys_epoll_pwait)
- 
-@@ -102,7 +102,7 @@ __SC_COMP_3264(__NR3264_fcntl, sys_fcntl64, sys_fcntl, compat_sys_fcntl64)
- #define __NR_inotify_init1 26
- __SYSCALL(__NR_inotify_init1, sys_inotify_init1)
- #define __NR_inotify_add_watch 27
--__SYSCALL(__NR_inotify_add_watch, sys_inotify_add_watch)
-+__SC_WRAP(__NR_inotify_add_watch, sys_inotify_add_watch)
- #define __NR_inotify_rm_watch 28
- __SYSCALL(__NR_inotify_rm_watch, sys_inotify_rm_watch)
- 
-@@ -122,17 +122,17 @@ __SYSCALL(__NR_flock, sys_flock)
- 
- /* fs/namei.c */
- #define __NR_mknodat 33
--__SYSCALL(__NR_mknodat, sys_mknodat)
-+__SC_WRAP(__NR_mknodat, sys_mknodat)
- #define __NR_mkdirat 34
--__SYSCALL(__NR_mkdirat, sys_mkdirat)
-+__SC_WRAP(__NR_mkdirat, sys_mkdirat)
- #define __NR_unlinkat 35
--__SYSCALL(__NR_unlinkat, sys_unlinkat)
-+__SC_WRAP(__NR_unlinkat, sys_unlinkat)
- #define __NR_symlinkat 36
--__SYSCALL(__NR_symlinkat, sys_symlinkat)
-+__SC_WRAP(__NR_symlinkat, sys_symlinkat)
- #define __NR_linkat 37
--__SYSCALL(__NR_linkat, sys_linkat)
-+__SC_WRAP(__NR_linkat, sys_linkat)
- #define __NR_renameat 38
--__SYSCALL(__NR_renameat, sys_renameat)
-+__SC_WRAP(__NR_renameat, sys_renameat)
- 
- /* fs/namespace.c */
- #define __NR_umount2 39
-@@ -140,7 +140,7 @@ __SYSCALL(__NR_umount2, sys_umount)
- #define __NR_mount 40
- __SC_COMP(__NR_mount, sys_mount, compat_sys_mount)
- #define __NR_pivot_root 41
--__SYSCALL(__NR_pivot_root, sys_pivot_root)
-+__SC_WRAP(__NR_pivot_root, sys_pivot_root)
- 
- /* fs/nfsctl.c */
- #define __NR_nfsservctl 42
-@@ -163,23 +163,23 @@ __SC_COMP_3264(__NR3264_ftruncate, sys_ftruncate64, sys_ftruncate, \
- #define __NR_fallocate 47
- __SC_COMP(__NR_fallocate, sys_fallocate, compat_sys_fallocate)
- #define __NR_faccessat 48
--__SYSCALL(__NR_faccessat, sys_faccessat)
-+__SC_WRAP(__NR_faccessat, sys_faccessat)
- #define __NR_chdir 49
--__SYSCALL(__NR_chdir, sys_chdir)
-+__SC_WRAP(__NR_chdir, sys_chdir)
- #define __NR_fchdir 50
- __SYSCALL(__NR_fchdir, sys_fchdir)
- #define __NR_chroot 51
--__SYSCALL(__NR_chroot, sys_chroot)
-+__SC_WRAP(__NR_chroot, sys_chroot)
- #define __NR_fchmod 52
- __SYSCALL(__NR_fchmod, sys_fchmod)
- #define __NR_fchmodat 53
--__SYSCALL(__NR_fchmodat, sys_fchmodat)
-+__SC_WRAP(__NR_fchmodat, sys_fchmodat)
- #define __NR_fchownat 54
--__SYSCALL(__NR_fchownat, sys_fchownat)
-+__SC_WRAP(__NR_fchownat, sys_fchownat)
- #define __NR_fchown 55
- __SYSCALL(__NR_fchown, sys_fchown)
- #define __NR_openat 56
--__SC_COMP(__NR_openat, sys_openat, compat_sys_openat)
-+__SYSCALL(__NR_openat, sys_openat)
- #define __NR_close 57
- __SYSCALL(__NR_close, sys_close)
- #define __NR_vhangup 58
-@@ -187,11 +187,11 @@ __SYSCALL(__NR_vhangup, sys_vhangup)
- 
- /* fs/pipe.c */
- #define __NR_pipe2 59
--__SYSCALL(__NR_pipe2, sys_pipe2)
-+__SC_WRAP(__NR_pipe2, sys_pipe2)
- 
- /* fs/quota.c */
- #define __NR_quotactl 60
--__SYSCALL(__NR_quotactl, sys_quotactl)
-+__SC_WRAP(__NR_quotactl, sys_quotactl)
- 
- /* fs/readdir.c */
- #define __NR_getdents64 61
-@@ -236,13 +236,13 @@ __SC_COMP(__NR_signalfd4, sys_signalfd4, compat_sys_signalfd4)
- #define __NR_vmsplice 75
- __SC_COMP(__NR_vmsplice, sys_vmsplice, compat_sys_vmsplice)
- #define __NR_splice 76
--__SYSCALL(__NR_splice, sys_splice)
-+__SC_WRAP(__NR_splice, sys_splice)
- #define __NR_tee 77
--__SYSCALL(__NR_tee, sys_tee)
-+__SC_WRAP(__NR_tee, sys_tee)
- 
- /* fs/stat.c */
- #define __NR_readlinkat 78
--__SYSCALL(__NR_readlinkat, sys_readlinkat)
-+__SC_WRAP(__NR_readlinkat, sys_readlinkat)
- #define __NR3264_fstatat 79
- __SC_3264(__NR3264_fstatat, sys_fstatat64, sys_newfstatat)
- #define __NR3264_fstat 80
-@@ -281,13 +281,13 @@ __SC_COMP(__NR_utimensat, sys_utimensat, compat_sys_utimensat)
- 
- /* kernel/acct.c */
- #define __NR_acct 89
--__SYSCALL(__NR_acct, sys_acct)
-+__SC_WRAP(__NR_acct, sys_acct)
- 
- /* kernel/capability.c */
- #define __NR_capget 90
--__SYSCALL(__NR_capget, sys_capget)
-+__SC_WRAP(__NR_capget, sys_capget)
- #define __NR_capset 91
--__SYSCALL(__NR_capset, sys_capset)
-+__SC_WRAP(__NR_capset, sys_capset)
- 
- /* kernel/exec_domain.c */
- #define __NR_personality 92
-@@ -303,9 +303,9 @@ __SC_COMP(__NR_waitid, sys_waitid, compat_sys_waitid)
- 
- /* kernel/fork.c */
- #define __NR_set_tid_address 96
--__SYSCALL(__NR_set_tid_address, sys_set_tid_address)
-+__SC_WRAP(__NR_set_tid_address, sys_set_tid_address)
- #define __NR_unshare 97
--__SYSCALL(__NR_unshare, sys_unshare)
-+__SC_WRAP(__NR_unshare, sys_unshare)
- 
- /* kernel/futex.c */
- #define __NR_futex 98
-@@ -333,9 +333,9 @@ __SC_COMP(__NR_kexec_load, sys_kexec_load, compat_sys_kexec_load)
- 
- /* kernel/module.c */
- #define __NR_init_module 105
--__SYSCALL(__NR_init_module, sys_init_module)
-+__SC_WRAP(__NR_init_module, sys_init_module)
- #define __NR_delete_module 106
--__SYSCALL(__NR_delete_module, sys_delete_module)
-+__SC_WRAP(__NR_delete_module, sys_delete_module)
- 
- /* kernel/posix-timers.c */
- #define __NR_timer_create 107
-@@ -360,7 +360,7 @@ __SC_COMP(__NR_clock_nanosleep, sys_clock_nanosleep, \
- 
- /* kernel/printk.c */
- #define __NR_syslog 116
--__SYSCALL(__NR_syslog, sys_syslog)
-+__SC_WRAP(__NR_syslog, sys_syslog)
- 
- /* kernel/ptrace.c */
- #define __NR_ptrace 117
-@@ -368,13 +368,13 @@ __SYSCALL(__NR_ptrace, sys_ptrace)
- 
- /* kernel/sched/core.c */
- #define __NR_sched_setparam 118
--__SYSCALL(__NR_sched_setparam, sys_sched_setparam)
-+__SC_WRAP(__NR_sched_setparam, sys_sched_setparam)
- #define __NR_sched_setscheduler 119
--__SYSCALL(__NR_sched_setscheduler, sys_sched_setscheduler)
-+__SC_WRAP(__NR_sched_setscheduler, sys_sched_setscheduler)
- #define __NR_sched_getscheduler 120
- __SYSCALL(__NR_sched_getscheduler, sys_sched_getscheduler)
- #define __NR_sched_getparam 121
--__SYSCALL(__NR_sched_getparam, sys_sched_getparam)
-+__SC_WRAP(__NR_sched_getparam, sys_sched_getparam)
- #define __NR_sched_setaffinity 122
- __SC_COMP(__NR_sched_setaffinity, sys_sched_setaffinity, \
- 	  compat_sys_sched_setaffinity)
-@@ -425,7 +425,7 @@ __SYSCALL(__NR_setpriority, sys_setpriority)
- #define __NR_getpriority 141
- __SYSCALL(__NR_getpriority, sys_getpriority)
- #define __NR_reboot 142
--__SYSCALL(__NR_reboot, sys_reboot)
-+__SC_WRAP(__NR_reboot, sys_reboot)
- #define __NR_setregid 143
- __SYSCALL(__NR_setregid, sys_setregid)
- #define __NR_setgid 144
-@@ -437,11 +437,11 @@ __SYSCALL(__NR_setuid, sys_setuid)
- #define __NR_setresuid 147
- __SYSCALL(__NR_setresuid, sys_setresuid)
- #define __NR_getresuid 148
--__SYSCALL(__NR_getresuid, sys_getresuid)
-+__SC_WRAP(__NR_getresuid, sys_getresuid)
- #define __NR_setresgid 149
- __SYSCALL(__NR_setresgid, sys_setresgid)
- #define __NR_getresgid 150
--__SYSCALL(__NR_getresgid, sys_getresgid)
-+__SC_WRAP(__NR_getresgid, sys_getresgid)
- #define __NR_setfsuid 151
- __SYSCALL(__NR_setfsuid, sys_setfsuid)
- #define __NR_setfsgid 152
-@@ -457,15 +457,15 @@ __SYSCALL(__NR_getsid, sys_getsid)
- #define __NR_setsid 157
- __SYSCALL(__NR_setsid, sys_setsid)
- #define __NR_getgroups 158
--__SYSCALL(__NR_getgroups, sys_getgroups)
-+__SC_WRAP(__NR_getgroups, sys_getgroups)
- #define __NR_setgroups 159
--__SYSCALL(__NR_setgroups, sys_setgroups)
-+__SC_WRAP(__NR_setgroups, sys_setgroups)
- #define __NR_uname 160
--__SYSCALL(__NR_uname, sys_newuname)
-+__SC_WRAP(__NR_uname, sys_newuname)
- #define __NR_sethostname 161
--__SYSCALL(__NR_sethostname, sys_sethostname)
-+__SC_WRAP(__NR_sethostname, sys_sethostname)
- #define __NR_setdomainname 162
--__SYSCALL(__NR_setdomainname, sys_setdomainname)
-+__SC_WRAP(__NR_setdomainname, sys_setdomainname)
- #define __NR_getrlimit 163
- __SC_COMP(__NR_getrlimit, sys_getrlimit, compat_sys_getrlimit)
- #define __NR_setrlimit 164
-@@ -475,9 +475,9 @@ __SC_COMP(__NR_getrusage, sys_getrusage, compat_sys_getrusage)
- #define __NR_umask 166
- __SYSCALL(__NR_umask, sys_umask)
- #define __NR_prctl 167
--__SYSCALL(__NR_prctl, sys_prctl)
-+__SC_WRAP(__NR_prctl, sys_prctl)
- #define __NR_getcpu 168
--__SYSCALL(__NR_getcpu, sys_getcpu)
-+__SC_WRAP(__NR_getcpu, sys_getcpu)
- 
- /* kernel/time.c */
- #define __NR_gettimeofday 169
-@@ -509,7 +509,7 @@ __SC_COMP(__NR_sysinfo, sys_sysinfo, compat_sys_sysinfo)
- #define __NR_mq_open 180
- __SC_COMP(__NR_mq_open, sys_mq_open, compat_sys_mq_open)
- #define __NR_mq_unlink 181
--__SYSCALL(__NR_mq_unlink, sys_mq_unlink)
-+__SC_WRAP(__NR_mq_unlink, sys_mq_unlink)
- #define __NR_mq_timedsend 182
- __SC_COMP(__NR_mq_timedsend, sys_mq_timedsend, compat_sys_mq_timedsend)
- #define __NR_mq_timedreceive 183
-@@ -554,21 +554,21 @@ __SYSCALL(__NR_shmdt, sys_shmdt)
- #define __NR_socket 198
- __SYSCALL(__NR_socket, sys_socket)
- #define __NR_socketpair 199
--__SYSCALL(__NR_socketpair, sys_socketpair)
-+__SC_WRAP(__NR_socketpair, sys_socketpair)
- #define __NR_bind 200
--__SYSCALL(__NR_bind, sys_bind)
-+__SC_WRAP(__NR_bind, sys_bind)
- #define __NR_listen 201
- __SYSCALL(__NR_listen, sys_listen)
- #define __NR_accept 202
- __SYSCALL(__NR_accept, sys_accept)
- #define __NR_connect 203
--__SYSCALL(__NR_connect, sys_connect)
-+__SC_WRAP(__NR_connect, sys_connect)
- #define __NR_getsockname 204
--__SYSCALL(__NR_getsockname, sys_getsockname)
-+__SC_WRAP(__NR_getsockname, sys_getsockname)
- #define __NR_getpeername 205
--__SYSCALL(__NR_getpeername, sys_getpeername)
-+__SC_WRAP(__NR_getpeername, sys_getpeername)
- #define __NR_sendto 206
--__SYSCALL(__NR_sendto, sys_sendto)
-+__SC_WRAP(__NR_sendto, sys_sendto)
- #define __NR_recvfrom 207
- __SC_COMP(__NR_recvfrom, sys_recvfrom, compat_sys_recvfrom)
- #define __NR_setsockopt 208
-@@ -588,23 +588,23 @@ __SC_COMP(__NR_readahead, sys_readahead, compat_sys_readahead)
- 
- /* mm/nommu.c, also with MMU */
- #define __NR_brk 214
--__SYSCALL(__NR_brk, sys_brk)
-+__SC_WRAP(__NR_brk, sys_brk)
- #define __NR_munmap 215
--__SYSCALL(__NR_munmap, sys_munmap)
-+__SC_WRAP(__NR_munmap, sys_munmap)
- #define __NR_mremap 216
--__SYSCALL(__NR_mremap, sys_mremap)
-+__SC_WRAP(__NR_mremap, sys_mremap)
- 
- /* security/keys/keyctl.c */
- #define __NR_add_key 217
--__SYSCALL(__NR_add_key, sys_add_key)
-+__SC_WRAP(__NR_add_key, sys_add_key)
- #define __NR_request_key 218
--__SYSCALL(__NR_request_key, sys_request_key)
-+__SC_WRAP(__NR_request_key, sys_request_key)
- #define __NR_keyctl 219
- __SC_COMP(__NR_keyctl, sys_keyctl, compat_sys_keyctl)
- 
- /* arch/example/kernel/sys_example.c */
- #define __NR_clone 220
--__SYSCALL(__NR_clone, sys_clone)
-+__SC_WRAP(__NR_clone, sys_clone)
- #define __NR_execve 221
- __SC_COMP(__NR_execve, sys_execve, compat_sys_execve)
- 
-@@ -617,27 +617,27 @@ __SC_COMP(__NR3264_fadvise64, sys_fadvise64_64, compat_sys_fadvise64_64)
- /* mm/, CONFIG_MMU only */
- #ifndef __ARCH_NOMMU
- #define __NR_swapon 224
--__SYSCALL(__NR_swapon, sys_swapon)
-+__SC_WRAP(__NR_swapon, sys_swapon)
- #define __NR_swapoff 225
--__SYSCALL(__NR_swapoff, sys_swapoff)
-+__SC_WRAP(__NR_swapoff, sys_swapoff)
- #define __NR_mprotect 226
--__SYSCALL(__NR_mprotect, sys_mprotect)
-+__SC_WRAP(__NR_mprotect, sys_mprotect)
- #define __NR_msync 227
--__SYSCALL(__NR_msync, sys_msync)
-+__SC_WRAP(__NR_msync, sys_msync)
- #define __NR_mlock 228
--__SYSCALL(__NR_mlock, sys_mlock)
-+__SC_WRAP(__NR_mlock, sys_mlock)
- #define __NR_munlock 229
--__SYSCALL(__NR_munlock, sys_munlock)
-+__SC_WRAP(__NR_munlock, sys_munlock)
- #define __NR_mlockall 230
- __SYSCALL(__NR_mlockall, sys_mlockall)
- #define __NR_munlockall 231
- __SYSCALL(__NR_munlockall, sys_munlockall)
- #define __NR_mincore 232
--__SYSCALL(__NR_mincore, sys_mincore)
-+__SC_WRAP(__NR_mincore, sys_mincore)
- #define __NR_madvise 233
--__SYSCALL(__NR_madvise, sys_madvise)
-+__SC_WRAP(__NR_madvise, sys_madvise)
- #define __NR_remap_file_pages 234
--__SYSCALL(__NR_remap_file_pages, sys_remap_file_pages)
-+__SC_WRAP(__NR_remap_file_pages, sys_remap_file_pages)
- #define __NR_mbind 235
- __SC_COMP(__NR_mbind, sys_mbind, compat_sys_mbind)
- #define __NR_get_mempolicy 236
-@@ -654,9 +654,9 @@ __SC_COMP(__NR_move_pages, sys_move_pages, compat_sys_move_pages)
- __SC_COMP(__NR_rt_tgsigqueueinfo, sys_rt_tgsigqueueinfo, \
- 	  compat_sys_rt_tgsigqueueinfo)
- #define __NR_perf_event_open 241
--__SYSCALL(__NR_perf_event_open, sys_perf_event_open)
-+__SC_WRAP(__NR_perf_event_open, sys_perf_event_open)
- #define __NR_accept4 242
--__SYSCALL(__NR_accept4, sys_accept4)
-+__SC_WRAP(__NR_accept4, sys_accept4)
- #define __NR_recvmmsg 243
- __SC_COMP(__NR_recvmmsg, sys_recvmmsg, compat_sys_recvmmsg)
- 
-@@ -669,16 +669,15 @@ __SC_COMP(__NR_recvmmsg, sys_recvmmsg, compat_sys_recvmmsg)
- #define __NR_wait4 260
- __SC_COMP(__NR_wait4, sys_wait4, compat_sys_wait4)
- #define __NR_prlimit64 261
--__SYSCALL(__NR_prlimit64, sys_prlimit64)
-+__SC_WRAP(__NR_prlimit64, sys_prlimit64)
- #define __NR_fanotify_init 262
- __SYSCALL(__NR_fanotify_init, sys_fanotify_init)
- #define __NR_fanotify_mark 263
- __SYSCALL(__NR_fanotify_mark, sys_fanotify_mark)
- #define __NR_name_to_handle_at         264
--__SYSCALL(__NR_name_to_handle_at, sys_name_to_handle_at)
-+__SC_WRAP(__NR_name_to_handle_at, sys_name_to_handle_at)
- #define __NR_open_by_handle_at         265
--__SC_COMP(__NR_open_by_handle_at, sys_open_by_handle_at, \
--	  compat_sys_open_by_handle_at)
-+__SYSCALL(__NR_open_by_handle_at, sys_open_by_handle_at)
- #define __NR_clock_adjtime 266
- __SC_COMP(__NR_clock_adjtime, sys_clock_adjtime, compat_sys_clock_adjtime)
- #define __NR_syncfs 267
-@@ -694,23 +693,23 @@ __SC_COMP(__NR_process_vm_readv, sys_process_vm_readv, \
- __SC_COMP(__NR_process_vm_writev, sys_process_vm_writev, \
-           compat_sys_process_vm_writev)
- #define __NR_kcmp 272
--__SYSCALL(__NR_kcmp, sys_kcmp)
-+__SC_WRAP(__NR_kcmp, sys_kcmp)
- #define __NR_finit_module 273
--__SYSCALL(__NR_finit_module, sys_finit_module)
-+__SC_WRAP(__NR_finit_module, sys_finit_module)
- #define __NR_sched_setattr 274
--__SYSCALL(__NR_sched_setattr, sys_sched_setattr)
-+__SC_WRAP(__NR_sched_setattr, sys_sched_setattr)
- #define __NR_sched_getattr 275
--__SYSCALL(__NR_sched_getattr, sys_sched_getattr)
-+__SC_WRAP(__NR_sched_getattr, sys_sched_getattr)
- #define __NR_renameat2 276
--__SYSCALL(__NR_renameat2, sys_renameat2)
-+__SC_WRAP(__NR_renameat2, sys_renameat2)
- #define __NR_seccomp 277
--__SYSCALL(__NR_seccomp, sys_seccomp)
-+__SC_WRAP(__NR_seccomp, sys_seccomp)
- #define __NR_getrandom 278
--__SYSCALL(__NR_getrandom, sys_getrandom)
-+__SC_WRAP(__NR_getrandom, sys_getrandom)
- #define __NR_memfd_create 279
--__SYSCALL(__NR_memfd_create, sys_memfd_create)
-+__SC_WRAP(__NR_memfd_create, sys_memfd_create)
- #define __NR_bpf 280
--__SYSCALL(__NR_bpf, sys_bpf)
-+__SC_WRAP(__NR_bpf, sys_bpf)
- #define __NR_execveat 281
- __SC_COMP(__NR_execveat, sys_execveat, compat_sys_execveat)
- #define __NR_userfaultfd 282
-@@ -718,7 +717,7 @@ __SYSCALL(__NR_userfaultfd, sys_userfaultfd)
- #define __NR_membarrier 283
- __SYSCALL(__NR_membarrier, sys_membarrier)
- #define __NR_mlock2 284
--__SYSCALL(__NR_mlock2, sys_mlock2)
-+__SC_WRAP(__NR_mlock2, sys_mlock2)
- 
- #undef __NR_syscalls
- #define __NR_syscalls 285
-@@ -735,29 +734,29 @@ __SYSCALL(__NR_mlock2, sys_mlock2)
- #define __NR_open 1024
- __SYSCALL(__NR_open, sys_open)
- #define __NR_link 1025
--__SYSCALL(__NR_link, sys_link)
-+__SC_WRAP(__NR_link, sys_link)
- #define __NR_unlink 1026
--__SYSCALL(__NR_unlink, sys_unlink)
-+__SC_WRAP(__NR_unlink, sys_unlink)
- #define __NR_mknod 1027
--__SYSCALL(__NR_mknod, sys_mknod)
-+__SC_WRAP(__NR_mknod, sys_mknod)
- #define __NR_chmod 1028
--__SYSCALL(__NR_chmod, sys_chmod)
-+__SC_WRAP(__NR_chmod, sys_chmod)
- #define __NR_chown 1029
--__SYSCALL(__NR_chown, sys_chown)
-+__SC_WRAP(__NR_chown, sys_chown)
- #define __NR_mkdir 1030
--__SYSCALL(__NR_mkdir, sys_mkdir)
-+__SC_WRAP(__NR_mkdir, sys_mkdir)
- #define __NR_rmdir 1031
--__SYSCALL(__NR_rmdir, sys_rmdir)
-+__SC_WRAP(__NR_rmdir, sys_rmdir)
- #define __NR_lchown 1032
--__SYSCALL(__NR_lchown, sys_lchown)
-+__SC_WRAP(__NR_lchown, sys_lchown)
- #define __NR_access 1033
--__SYSCALL(__NR_access, sys_access)
-+__SC_WRAP(__NR_access, sys_access)
- #define __NR_rename 1034
--__SYSCALL(__NR_rename, sys_rename)
-+__SC_WRAP(__NR_rename, sys_rename)
- #define __NR_readlink 1035
--__SYSCALL(__NR_readlink, sys_readlink)
-+__SC_WRAP(__NR_readlink, sys_readlink)
- #define __NR_symlink 1036
--__SYSCALL(__NR_symlink, sys_symlink)
-+__SC_WRAP(__NR_symlink, sys_symlink)
- #define __NR_utimes 1037
- __SYSCALL(__NR_utimes, sys_utimes)
- #define __NR3264_stat 1038
-@@ -771,7 +770,7 @@ __SC_3264(__NR3264_lstat, sys_lstat64, sys_newlstat)
- 
- #ifdef __ARCH_WANT_SYSCALL_NO_FLAGS
- #define __NR_pipe 1040
--__SYSCALL(__NR_pipe, sys_pipe)
-+__SC_WRAP(__NR_pipe, sys_pipe)
- #define __NR_dup2 1041
- __SYSCALL(__NR_dup2, sys_dup2)
- #define __NR_epoll_create 1042
-@@ -841,7 +840,7 @@ __SYSCALL(__NR_time, sys_time)
- __SYSCALL(__NR_utime, sys_utime)
- 
- #define __NR_creat 1064
--__SYSCALL(__NR_creat, sys_creat)
-+__SC_WRAP(__NR_creat, sys_creat)
- #define __NR_getdents 1065
- #define __ARCH_WANT_SYS_GETDENTS
- __SYSCALL(__NR_getdents, sys_getdents)
-@@ -851,9 +850,9 @@ __SYSCALL(__NR_futimesat, sys_futimesat)
- #define __ARCH_WANT_SYS_SELECT
- __SYSCALL(__NR_select, sys_select)
- #define __NR_poll 1068
--__SYSCALL(__NR_poll, sys_poll)
-+__SC_WRAP(__NR_poll, sys_poll)
- #define __NR_epoll_wait 1069
--__SYSCALL(__NR_epoll_wait, sys_epoll_wait)
-+__SC_WRAP(__NR_epoll_wait, sys_epoll_wait)
- #define __NR_ustat 1070
- __SYSCALL(__NR_ustat, sys_ustat)
- #define __NR_vfork 1071
-@@ -865,12 +864,12 @@ __SYSCALL(__NR_recv, sys_recv)
- #define __NR_send 1074
- __SYSCALL(__NR_send, sys_send)
- #define __NR_bdflush 1075
--__SYSCALL(__NR_bdflush, sys_bdflush)
-+__SC_WRAP(__NR_bdflush, sys_bdflush)
- #define __NR_umount 1076
--__SYSCALL(__NR_umount, sys_oldumount)
-+__SC_WRAP(__NR_umount, sys_oldumount)
- #define __ARCH_WANT_SYS_OLDUMOUNT
- #define __NR_uselib 1077
--__SYSCALL(__NR_uselib, sys_uselib)
-+__SC_WRAP(__NR_uselib, sys_uselib)
- #define __NR__sysctl 1078
- __SYSCALL(__NR__sysctl, sys_sysctl)
- 
-diff --git a/kernel/Makefile b/kernel/Makefile
-index 53abf00..208906e 100644
---- a/kernel/Makefile
-+++ b/kernel/Makefile
-@@ -54,6 +54,7 @@ obj-$(CONFIG_KEXEC) += kexec.o
- obj-$(CONFIG_KEXEC_FILE) += kexec_file.o
- obj-$(CONFIG_BACKTRACE_SELF_TEST) += backtracetest.o
- obj-$(CONFIG_COMPAT) += compat.o
-+obj-$(CONFIG_COMPAT_WRAPPER) += compat_wrapper.o
- obj-$(CONFIG_CGROUPS) += cgroup.o
- obj-$(CONFIG_CGROUP_FREEZER) += cgroup_freezer.o
- obj-$(CONFIG_CGROUP_PIDS) += cgroup_pids.o
-diff --git a/kernel/compat_wrapper.c b/kernel/compat_wrapper.c
-index b6c050e..2fdd84b 100644
---- a/kernel/compat_wrapper.c
-+++ b/kernel/compat_wrapper.c
-@@ -172,4 +172,3 @@ COMPAT_SYSCALL_WRAP3(getsockname, int, fd, struct sockaddr __user *, usockaddr,
- COMPAT_SYSCALL_WRAP3(getpeername, int, fd, struct sockaddr __user *, usockaddr, int __user *, usockaddr_len);
- COMPAT_SYSCALL_WRAP6(sendto, int, fd, void __user *, buff, size_t, len, unsigned int, flags, struct sockaddr __user *, addr, int, addr_len);
- COMPAT_SYSCALL_WRAP3(mlock2, unsigned long, start, size_t, len, int, flags);
--COMPAT_SYSCALL_WRAP6(copy_file_range, int, fd_in, loff_t __user *, off_in, int, fd_out, loff_t __user *, off_out, size_t, len, unsigned int, flags);
--- 
-1.9.1
-
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0005-arm64-rename-COMPAT-to-AARCH32_EL0-in-Kconfig.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0005-arm64-rename-COMPAT-to-AARCH32_EL0-in-Kconfig.patch
new file mode 100644
index 0000000..30c86e5
--- /dev/null
+++ b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0005-arm64-rename-COMPAT-to-AARCH32_EL0-in-Kconfig.patch
@@ -0,0 +1,425 @@
+From 48ca7c1a8a1589dc7952a1e49041fa4a6ab8c0ac Mon Sep 17 00:00:00 2001
+From: Andrew Pinski <apinski@cavium.com>
+Date: Tue, 24 May 2016 03:04:39 +0300
+Subject: [PATCH 05/20] arm64: rename COMPAT to AARCH32_EL0 in Kconfig
+
+In this patchset  ILP32 ABI support is added. Additionally to AARCH32,
+which is binary-compatible with ARM, ILP32 is (mostly) ABI-compatible.
+
+From now, AARCH32_EL0 (former COMPAT) config option means the support of
+AARCH32 userspace, ARM64_ILP32 - support of ILP32 ABI (see next patches),
+and COMPAT indicates that one of them, or both, is enabled.
+
+Where needed, CONFIG_COMPAT is changed over to use CONFIG_AARCH32_EL0 instead
+
+Reviewed-by: David Daney <ddaney@caviumnetworks.com>
+Signed-off-by: Andrew Pinski <Andrew.Pinski@caviumnetworks.com>
+Signed-off-by: Philipp Tomsich <philipp.tomsich@theobroma-systems.com>
+Signed-off-by: Christoph Muellner <christoph.muellner@theobroma-systems.com>
+Signed-off-by: Bamvor Jian Zhang <bamvor.zhangjian@linaro.org>
+Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
+---
+ arch/arm64/Kconfig                   | 10 ++++++++--
+ arch/arm64/include/asm/fpsimd.h      |  2 +-
+ arch/arm64/include/asm/hwcap.h       |  4 ++--
+ arch/arm64/include/asm/processor.h   |  6 +++---
+ arch/arm64/include/asm/ptrace.h      |  2 +-
+ arch/arm64/include/asm/seccomp.h     |  2 +-
+ arch/arm64/include/asm/signal32.h    |  6 ++++--
+ arch/arm64/include/asm/unistd.h      |  2 +-
+ arch/arm64/kernel/Makefile           |  2 +-
+ arch/arm64/kernel/asm-offsets.c      |  2 +-
+ arch/arm64/kernel/cpufeature.c       |  8 ++++----
+ arch/arm64/kernel/cpuinfo.c          |  4 ++--
+ arch/arm64/kernel/entry.S            |  6 +++---
+ arch/arm64/kernel/head.S             |  2 +-
+ arch/arm64/kernel/ptrace.c           |  8 ++++----
+ arch/arm64/kernel/traps.c            |  2 +-
+ arch/arm64/kernel/vdso.c             |  4 ++--
+ drivers/clocksource/arm_arch_timer.c |  2 +-
+ 18 files changed, 41 insertions(+), 33 deletions(-)
+
+diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
+index 975baad..32ef499 100644
+--- a/arch/arm64/Kconfig
++++ b/arch/arm64/Kconfig
+@@ -343,7 +343,7 @@ config ARM64_ERRATUM_834220
+ 
+ config ARM64_ERRATUM_845719
+ 	bool "Cortex-A53: 845719: a load might read incorrect data"
+-	depends on COMPAT
++	depends on AARCH32_EL0
+ 	default y
+ 	help
+ 	  This option adds an alternative code sequence to work around ARM
+@@ -641,7 +641,7 @@ config FORCE_MAX_ZONEORDER
+ 
+ menuconfig ARMV8_DEPRECATED
+ 	bool "Emulate deprecated/obsolete ARMv8 instructions"
+-	depends on COMPAT
++	depends on AARCH32_EL0
+ 	help
+ 	  Legacy software support may require certain instructions
+ 	  that have been deprecated or obsoleted in the architecture.
+@@ -833,8 +833,14 @@ menu "Userspace binary formats"
+ source "fs/Kconfig.binfmt"
+ 
+ config COMPAT
++	bool
++	depends on AARCH32_EL0
++
++config AARCH32_EL0
+ 	bool "Kernel support for 32-bit EL0"
++	def_bool y
+ 	depends on ARM64_4K_PAGES || EXPERT
++	select COMPAT
+ 	select COMPAT_BINFMT_ELF
+ 	select HAVE_UID16
+ 	select OLD_SIGSUSPEND3
+diff --git a/arch/arm64/include/asm/fpsimd.h b/arch/arm64/include/asm/fpsimd.h
+index 50f559f..63b19f1 100644
+--- a/arch/arm64/include/asm/fpsimd.h
++++ b/arch/arm64/include/asm/fpsimd.h
+@@ -52,7 +52,7 @@ struct fpsimd_partial_state {
+ };
+ 
+ 
+-#if defined(__KERNEL__) && defined(CONFIG_COMPAT)
++#if defined(__KERNEL__) && defined(CONFIG_AARCH32_EL0)
+ /* Masks for extracting the FPSR and FPCR from the FPSCR */
+ #define VFP_FPSCR_STAT_MASK	0xf800009f
+ #define VFP_FPSCR_CTRL_MASK	0x07f79f00
+diff --git a/arch/arm64/include/asm/hwcap.h b/arch/arm64/include/asm/hwcap.h
+index 400b80b..2c7fc5d 100644
+--- a/arch/arm64/include/asm/hwcap.h
++++ b/arch/arm64/include/asm/hwcap.h
+@@ -46,7 +46,7 @@
+  */
+ #define ELF_HWCAP		(elf_hwcap)
+ 
+-#ifdef CONFIG_COMPAT
++#ifdef CONFIG_AARCH32_EL0
+ #define COMPAT_ELF_HWCAP	(compat_elf_hwcap)
+ #define COMPAT_ELF_HWCAP2	(compat_elf_hwcap2)
+ extern unsigned int compat_elf_hwcap, compat_elf_hwcap2;
+@@ -54,7 +54,7 @@ extern unsigned int compat_elf_hwcap, compat_elf_hwcap2;
+ 
+ enum {
+ 	CAP_HWCAP = 1,
+-#ifdef CONFIG_COMPAT
++#ifdef CONFIG_AARCH32_EL0
+ 	CAP_COMPAT_HWCAP,
+ 	CAP_COMPAT_HWCAP2,
+ #endif
+diff --git a/arch/arm64/include/asm/processor.h b/arch/arm64/include/asm/processor.h
+index 5bb1d76..ba48561 100644
+--- a/arch/arm64/include/asm/processor.h
++++ b/arch/arm64/include/asm/processor.h
+@@ -81,7 +81,7 @@ struct cpu_context {
+ struct thread_struct {
+ 	struct cpu_context	cpu_context;	/* cpu context */
+ 	unsigned long		tp_value;	/* TLS register */
+-#ifdef CONFIG_COMPAT
++#ifdef CONFIG_AARCH32_EL0
+ 	unsigned long		tp2_value;
+ #endif
+ 	struct fpsimd_state	fpsimd_state;
+@@ -90,7 +90,7 @@ struct thread_struct {
+ 	struct debug_info	debug;		/* debugging */
+ };
+ 
+-#ifdef CONFIG_COMPAT
++#ifdef CONFIG_AARCH32_EL0
+ #define task_user_tls(t)						\
+ ({									\
+ 	unsigned long *__tls;						\
+@@ -121,7 +121,7 @@ static inline void start_thread(struct pt_regs *regs, unsigned long pc,
+ 	regs->sp = sp;
+ }
+ 
+-#ifdef CONFIG_COMPAT
++#ifdef CONFIG_AARCH32_EL0
+ static inline void compat_start_thread(struct pt_regs *regs, unsigned long pc,
+ 				       unsigned long sp)
+ {
+diff --git a/arch/arm64/include/asm/ptrace.h b/arch/arm64/include/asm/ptrace.h
+index e9e5467..95eff51 100644
+--- a/arch/arm64/include/asm/ptrace.h
++++ b/arch/arm64/include/asm/ptrace.h
+@@ -120,7 +120,7 @@ struct pt_regs {
+ 
+ #define arch_has_single_step()	(1)
+ 
+-#ifdef CONFIG_COMPAT
++#ifdef CONFIG_AARCH32_EL0
+ #define compat_thumb_mode(regs) \
+ 	(((regs)->pstate & COMPAT_PSR_T_BIT))
+ #else
+diff --git a/arch/arm64/include/asm/seccomp.h b/arch/arm64/include/asm/seccomp.h
+index c76fac9..00ef0bf 100644
+--- a/arch/arm64/include/asm/seccomp.h
++++ b/arch/arm64/include/asm/seccomp.h
+@@ -13,7 +13,7 @@
+ 
+ #include <asm/unistd.h>
+ 
+-#ifdef CONFIG_COMPAT
++#ifdef CONFIG_AARCH32_EL0
+ #define __NR_seccomp_read_32		__NR_compat_read
+ #define __NR_seccomp_write_32		__NR_compat_write
+ #define __NR_seccomp_exit_32		__NR_compat_exit
+diff --git a/arch/arm64/include/asm/signal32.h b/arch/arm64/include/asm/signal32.h
+index eeaa975..e68fcce 100644
+--- a/arch/arm64/include/asm/signal32.h
++++ b/arch/arm64/include/asm/signal32.h
+@@ -17,7 +17,9 @@
+ #define __ASM_SIGNAL32_H
+ 
+ #ifdef __KERNEL__
+-#ifdef CONFIG_COMPAT
++
++#ifdef CONFIG_AARCH32_EL0
++
+ #include <linux/compat.h>
+ 
+ #define AARCH32_KERN_SIGRET_CODE_OFFSET	0x500
+@@ -47,6 +49,6 @@ static inline int compat_setup_rt_frame(int usig, struct ksignal *ksig, sigset_t
+ static inline void compat_setup_restart_syscall(struct pt_regs *regs)
+ {
+ }
+-#endif /* CONFIG_COMPAT */
++#endif /* CONFIG_AARCH32_EL0 */
+ #endif /* __KERNEL__ */
+ #endif /* __ASM_SIGNAL32_H */
+diff --git a/arch/arm64/include/asm/unistd.h b/arch/arm64/include/asm/unistd.h
+index 41e58fe..2971dea 100644
+--- a/arch/arm64/include/asm/unistd.h
++++ b/arch/arm64/include/asm/unistd.h
+@@ -13,7 +13,7 @@
+  * You should have received a copy of the GNU General Public License
+  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+  */
+-#ifdef CONFIG_COMPAT
++#ifdef CONFIG_AARCH32_EL0
+ #define __ARCH_WANT_COMPAT_SYS_GETDENTS64
+ #define __ARCH_WANT_COMPAT_STAT64
+ #define __ARCH_WANT_SYS_GETHOSTNAME
+diff --git a/arch/arm64/kernel/Makefile b/arch/arm64/kernel/Makefile
+index 21d197a..3b5b293 100644
+--- a/arch/arm64/kernel/Makefile
++++ b/arch/arm64/kernel/Makefile
+@@ -25,7 +25,7 @@ OBJCOPYFLAGS := --prefix-symbols=__efistub_
+ $(obj)/%.stub.o: $(obj)/%.o FORCE
+ 	$(call if_changed,objcopy)
+ 
+-arm64-obj-$(CONFIG_COMPAT)		+= sys32.o kuser32.o signal32.o 	\
++arm64-obj-$(CONFIG_AARCH32_EL0)		+= sys32.o kuser32.o signal32.o 	\
+ 					   sys_compat.o entry32.o		\
+ 					   ../../arm/kernel/opcodes.o
+ arm64-obj-$(CONFIG_FUNCTION_TRACER)	+= ftrace.o entry-ftrace.o
+diff --git a/arch/arm64/kernel/asm-offsets.c b/arch/arm64/kernel/asm-offsets.c
+index b0ab4e9..e2414ab 100644
+--- a/arch/arm64/kernel/asm-offsets.c
++++ b/arch/arm64/kernel/asm-offsets.c
+@@ -52,7 +52,7 @@ int main(void)
+   DEFINE(S_X7,			offsetof(struct pt_regs, regs[7]));
+   DEFINE(S_LR,			offsetof(struct pt_regs, regs[30]));
+   DEFINE(S_SP,			offsetof(struct pt_regs, sp));
+-#ifdef CONFIG_COMPAT
++#ifdef CONFIG_AARCH32_EL0
+   DEFINE(S_COMPAT_SP,		offsetof(struct pt_regs, compat_sp));
+ #endif
+   DEFINE(S_PSTATE,		offsetof(struct pt_regs, pstate));
+diff --git a/arch/arm64/kernel/cpufeature.c b/arch/arm64/kernel/cpufeature.c
+index 37b3ec4..5ce8185 100644
+--- a/arch/arm64/kernel/cpufeature.c
++++ b/arch/arm64/kernel/cpufeature.c
+@@ -31,7 +31,7 @@
+ unsigned long elf_hwcap __read_mostly;
+ EXPORT_SYMBOL_GPL(elf_hwcap);
+ 
+-#ifdef CONFIG_COMPAT
++#ifdef CONFIG_AARCH32_EL0
+ #define COMPAT_ELF_HWCAP_DEFAULT	\
+ 				(COMPAT_HWCAP_HALF|COMPAT_HWCAP_THUMB|\
+ 				 COMPAT_HWCAP_FAST_MULT|COMPAT_HWCAP_EDSP|\
+@@ -702,7 +702,7 @@ static const struct arm64_cpu_capabilities arm64_hwcaps[] = {
+ 	HWCAP_CAP(SYS_ID_AA64ISAR0_EL1, ID_AA64ISAR0_ATOMICS_SHIFT, 2, CAP_HWCAP, HWCAP_ATOMICS),
+ 	HWCAP_CAP(SYS_ID_AA64PFR0_EL1, ID_AA64PFR0_FP_SHIFT, 0, CAP_HWCAP, HWCAP_FP),
+ 	HWCAP_CAP(SYS_ID_AA64PFR0_EL1, ID_AA64PFR0_ASIMD_SHIFT, 0, CAP_HWCAP, HWCAP_ASIMD),
+-#ifdef CONFIG_COMPAT
++#ifdef CONFIG_AARCH32_EL0
+ 	HWCAP_CAP(SYS_ID_ISAR5_EL1, ID_ISAR5_AES_SHIFT, 2, CAP_COMPAT_HWCAP2, COMPAT_HWCAP2_PMULL),
+ 	HWCAP_CAP(SYS_ID_ISAR5_EL1, ID_ISAR5_AES_SHIFT, 1, CAP_COMPAT_HWCAP2, COMPAT_HWCAP2_AES),
+ 	HWCAP_CAP(SYS_ID_ISAR5_EL1, ID_ISAR5_SHA1_SHIFT, 1, CAP_COMPAT_HWCAP2, COMPAT_HWCAP2_SHA1),
+@@ -718,7 +718,7 @@ static void cap_set_hwcap(const struct arm64_cpu_capabilities *cap)
+ 	case CAP_HWCAP:
+ 		elf_hwcap |= cap->hwcap;
+ 		break;
+-#ifdef CONFIG_COMPAT
++#ifdef CONFIG_AARCH32_EL0
+ 	case CAP_COMPAT_HWCAP:
+ 		compat_elf_hwcap |= (u32)cap->hwcap;
+ 		break;
+@@ -741,7 +741,7 @@ static bool __maybe_unused cpus_have_hwcap(const struct arm64_cpu_capabilities *
+ 	case CAP_HWCAP:
+ 		rc = (elf_hwcap & cap->hwcap) != 0;
+ 		break;
+-#ifdef CONFIG_COMPAT
++#ifdef CONFIG_AARCH32_EL0
+ 	case CAP_COMPAT_HWCAP:
+ 		rc = (compat_elf_hwcap & (u32)cap->hwcap) != 0;
+ 		break;
+diff --git a/arch/arm64/kernel/cpuinfo.c b/arch/arm64/kernel/cpuinfo.c
+index c6254fc..aa94e5f 100644
+--- a/arch/arm64/kernel/cpuinfo.c
++++ b/arch/arm64/kernel/cpuinfo.c
+@@ -126,7 +126,7 @@ static int c_show(struct seq_file *m, void *v)
+ 		 */
+ 		seq_puts(m, "Features\t:");
+ 		if (personality(current->personality) == PER_LINUX32) {
+-#ifdef CONFIG_COMPAT
++#ifdef CONFIG_AARCH32_EL0
+ 			for (j = 0; compat_hwcap_str[j]; j++)
+ 				if (compat_elf_hwcap & (1 << j))
+ 					seq_printf(m, " %s", compat_hwcap_str[j]);
+@@ -134,7 +134,7 @@ static int c_show(struct seq_file *m, void *v)
+ 			for (j = 0; compat_hwcap2_str[j]; j++)
+ 				if (compat_elf_hwcap2 & (1 << j))
+ 					seq_printf(m, " %s", compat_hwcap2_str[j]);
+-#endif /* CONFIG_COMPAT */
++#endif /* CONFIG_AARCH32_EL0 */
+ 		} else {
+ 			for (j = 0; hwcap_str[j]; j++)
+ 				if (elf_hwcap & (1 << j))
+diff --git a/arch/arm64/kernel/entry.S b/arch/arm64/kernel/entry.S
+index e5b2538..d782d2a 100644
+--- a/arch/arm64/kernel/entry.S
++++ b/arch/arm64/kernel/entry.S
+@@ -212,7 +212,7 @@ ENTRY(vectors)
+ 	ventry	el0_fiq_invalid			// FIQ 64-bit EL0
+ 	ventry	el0_error_invalid		// Error 64-bit EL0
+ 
+-#ifdef CONFIG_COMPAT
++#ifdef CONFIG_AARCH32_EL0
+ 	ventry	el0_sync_compat			// Synchronous 32-bit EL0
+ 	ventry	el0_irq_compat			// IRQ 32-bit EL0
+ 	ventry	el0_fiq_invalid_compat		// FIQ 32-bit EL0
+@@ -252,7 +252,7 @@ el0_error_invalid:
+ 	inv_entry 0, BAD_ERROR
+ ENDPROC(el0_error_invalid)
+ 
+-#ifdef CONFIG_COMPAT
++#ifdef CONFIG_AARCH32_EL0
+ el0_fiq_invalid_compat:
+ 	inv_entry 0, BAD_FIQ, 32
+ ENDPROC(el0_fiq_invalid_compat)
+@@ -414,7 +414,7 @@ el0_sync:
+ 	b.ge	el0_dbg
+ 	b	el0_inv
+ 
+-#ifdef CONFIG_COMPAT
++#ifdef CONFIG_AARCH32_EL0
+ 	.align	6
+ el0_sync_compat:
+ 	kernel_entry 0, 32
+diff --git a/arch/arm64/kernel/head.S b/arch/arm64/kernel/head.S
+index db9501b..f60ed1e 100644
+--- a/arch/arm64/kernel/head.S
++++ b/arch/arm64/kernel/head.S
+@@ -526,7 +526,7 @@ CPU_LE(	movk	x0, #0x30d0, lsl #16	)	// Clear EE and E0E on LE systems
+ 	mov	x0, #0x33ff
+ 	msr	cptr_el2, x0			// Disable copro. traps to EL2
+ 
+-#ifdef CONFIG_COMPAT
++#ifdef CONFIG_AARCH32_EL0
+ 	msr	hstr_el2, xzr			// Disable CP15 traps to EL2
+ #endif
+ 
+diff --git a/arch/arm64/kernel/ptrace.c b/arch/arm64/kernel/ptrace.c
+index ff7f132..16ed9fd 100644
+--- a/arch/arm64/kernel/ptrace.c
++++ b/arch/arm64/kernel/ptrace.c
+@@ -82,7 +82,7 @@ static void ptrace_hbptriggered(struct perf_event *bp,
+ 		.si_addr	= (void __user *)(bkpt->trigger),
+ 	};
+ 
+-#ifdef CONFIG_COMPAT
++#ifdef CONFIG_AARCH32_EL0
+ 	int i;
+ 
+ 	if (!is_compat_task())
+@@ -657,7 +657,7 @@ static const struct user_regset_view user_aarch64_view = {
+ 	.regsets = aarch64_regsets, .n = ARRAY_SIZE(aarch64_regsets)
+ };
+ 
+-#ifdef CONFIG_COMPAT
++#ifdef CONFIG_AARCH32_EL0
+ #include <linux/compat.h>
+ 
+ enum compat_regset {
+@@ -1192,11 +1192,11 @@ long compat_arch_ptrace(struct task_struct *child, compat_long_t request,
+ 
+ 	return ret;
+ }
+-#endif /* CONFIG_COMPAT */
++#endif /* CONFIG_AARCH32_EL0 */
+ 
+ const struct user_regset_view *task_user_regset_view(struct task_struct *task)
+ {
+-#ifdef CONFIG_COMPAT
++#ifdef CONFIG_AARCH32_EL0
+ 	/*
+ 	 * Core dumping of 32-bit tasks or compat ptrace requests must use the
+ 	 * user_aarch32_view compatible with arm32. Native ptrace requests on
+diff --git a/arch/arm64/kernel/traps.c b/arch/arm64/kernel/traps.c
+index e9b9b53..b50fced 100644
+--- a/arch/arm64/kernel/traps.c
++++ b/arch/arm64/kernel/traps.c
+@@ -368,7 +368,7 @@ long compat_arm_syscall(struct pt_regs *regs);
+ 
+ asmlinkage long do_ni_syscall(struct pt_regs *regs)
+ {
+-#ifdef CONFIG_COMPAT
++#ifdef CONFIG_AARCH32_EL0
+ 	long ret;
+ 	if (is_compat_task()) {
+ 		ret = compat_arm_syscall(regs);
+diff --git a/arch/arm64/kernel/vdso.c b/arch/arm64/kernel/vdso.c
+index 97bc68f..26352a6 100644
+--- a/arch/arm64/kernel/vdso.c
++++ b/arch/arm64/kernel/vdso.c
+@@ -49,7 +49,7 @@ static union {
+ } vdso_data_store __page_aligned_data;
+ struct vdso_data *vdso_data = &vdso_data_store.data;
+ 
+-#ifdef CONFIG_COMPAT
++#ifdef CONFIG_AARCH32_EL0
+ /*
+  * Create and map the vectors page for AArch32 tasks.
+  */
+@@ -107,7 +107,7 @@ int aarch32_setup_vectors_page(struct linux_binprm *bprm, int uses_interp)
+ 
+ 	return PTR_ERR_OR_ZERO(ret);
+ }
+-#endif /* CONFIG_COMPAT */
++#endif /* CONFIG_AARCH32_EL0 */
+ 
+ static struct vm_special_mapping vdso_spec[2];
+ 
+diff --git a/drivers/clocksource/arm_arch_timer.c b/drivers/clocksource/arm_arch_timer.c
+index e425007..5bfd223 100644
+--- a/drivers/clocksource/arm_arch_timer.c
++++ b/drivers/clocksource/arm_arch_timer.c
+@@ -309,7 +309,7 @@ static void arch_timer_evtstrm_enable(int divider)
+ 			| ARCH_TIMER_VIRT_EVT_EN;
+ 	arch_timer_set_cntkctl(cntkctl);
+ 	elf_hwcap |= HWCAP_EVTSTRM;
+-#ifdef CONFIG_COMPAT
++#ifdef CONFIG_AARCH32_EL0
+ 	compat_elf_hwcap |= COMPAT_HWCAP_EVTSTRM;
+ #endif
+ }
+-- 
+2.5.0
+
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0006-arm64-ensure-the-kernel-is-compiled-for-LP64.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0006-arm64-ensure-the-kernel-is-compiled-for-LP64.patch
new file mode 100644
index 0000000..3fb2b82
--- /dev/null
+++ b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0006-arm64-ensure-the-kernel-is-compiled-for-LP64.patch
@@ -0,0 +1,47 @@
+From 9ab9e34b6c72d9263edec223e4ab4fc45e6cf9d6 Mon Sep 17 00:00:00 2001
+From: Manish Jaggi <mjaggi@cavium.com>
+Date: Wed, 29 Mar 2017 17:52:42 -0700
+Subject: [PATCH 06/20] arm64: ensure the kernel is compiled for LP64
+
+The kernel needs to be compiled as a LP64 binary for ARM64, even when
+using a compiler that defaults to code-generation for the ILP32 ABI.
+Consequently, we need to explicitly pass '-mabi=lp64' (supported on
+gcc-4.9 and newer).
+
+Signed-off-by: Andrew Pinski <Andrew.Pinski@caviumnetworks.com>
+Signed-off-by: Philipp Tomsich <philipp.tomsich@theobroma-systems.com>
+Signed-off-by: Christoph Muellner <christoph.muellner@theobroma-systems.com>
+Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
+Reviewed-by: David Daney <ddaney@caviumnetworks.com>
+---
+ arch/arm64/Makefile | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+diff --git a/arch/arm64/Makefile b/arch/arm64/Makefile
+index 9d9301e..7f27a9d 100644
+--- a/arch/arm64/Makefile
++++ b/arch/arm64/Makefile
+@@ -30,15 +30,20 @@ KBUILD_CFLAGS	+= -mgeneral-regs-only $(lseinstr)
+ KBUILD_CFLAGS	+= $(call cc-option, -mpc-relative-literal-loads)
+ KBUILD_AFLAGS	+= $(lseinstr)
+ 
++KBUILD_CFLAGS	+= $(call cc-option,-mabi=lp64)
++KBUILD_AFLAGS	+= $(call cc-option,-mabi=lp64)
++
+ ifeq ($(CONFIG_CPU_BIG_ENDIAN), y)
+ KBUILD_CPPFLAGS	+= -mbig-endian
+ AS		+= -EB
+ LD		+= -EB
+ UTS_MACHINE	:= aarch64_be
++LDFLAGS		+= -maarch64linuxb
+ else
+ KBUILD_CPPFLAGS	+= -mlittle-endian
+ AS		+= -EL
+ LD		+= -EL
++LDFLAGS		+= -maarch64linux
+ UTS_MACHINE	:= aarch64
+ endif
+ 
+-- 
+2.5.0
+
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0006-compat-ABI-use-non-compat-openat-and-open_by_handle_.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0006-compat-ABI-use-non-compat-openat-and-open_by_handle_.patch
deleted file mode 100644
index 57702c9..0000000
--- a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0006-compat-ABI-use-non-compat-openat-and-open_by_handle_.patch
+++ /dev/null
@@ -1,35 +0,0 @@
-From 703e0e164e248df9f4a6d197f938424fe9153381 Mon Sep 17 00:00:00 2001
-From: Yury Norov <ynorov@caviumnetworks.com>
-Date: Tue, 24 May 2016 03:04:35 +0300
-Subject: [PATCH 06/24] compat ABI: use non-compat openat and open_by_handle_at
- variants
-
-The only difference is that non-compat version forces O_LARGEFILE,
-and it should be the default behaviour for all architectures, as
-we don't support 32-bit off_t. The only exception is tile32, that
-continues with compat version of syscalls.
-
-Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
-Acked-by: Arnd Bergmann <arnd@arndb.de>
-Acked-by: Chris Metcalf <cmetcalf@ezchip.com> [for tile]
----
- arch/tile/kernel/compat.c | 3 +++
- 1 file changed, 3 insertions(+)
-
-diff --git a/arch/tile/kernel/compat.c b/arch/tile/kernel/compat.c
-index 4912084..489ae19 100644
---- a/arch/tile/kernel/compat.c
-+++ b/arch/tile/kernel/compat.c
-@@ -94,6 +94,9 @@ COMPAT_SYSCALL_DEFINE5(llseek, unsigned int, fd, unsigned int, offset_high,
- #define compat_sys_readahead sys32_readahead
- #define sys_llseek compat_sys_llseek
- 
-+#define sys_openat		compat_sys_openat
-+#define sys_open_by_handle_at	compat_sys_open_by_handle_at
-+
- /* Call the assembly trampolines where necessary. */
- #define compat_sys_rt_sigreturn _compat_sys_rt_sigreturn
- #define sys_clone _sys_clone
--- 
-1.9.1
-
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0007-32-bit-ABI-introduce-ARCH_32BIT_OFF_T-config-option.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0007-32-bit-ABI-introduce-ARCH_32BIT_OFF_T-config-option.patch
deleted file mode 100644
index 58562ba..0000000
--- a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0007-32-bit-ABI-introduce-ARCH_32BIT_OFF_T-config-option.patch
+++ /dev/null
@@ -1,376 +0,0 @@
-From 555e216fb0e7d3caf30304560c58141287dfaa05 Mon Sep 17 00:00:00 2001
-From: Yury Norov <ynorov@caviumnetworks.com>
-Date: Tue, 24 May 2016 03:04:36 +0300
-Subject: [PATCH 07/24] 32-bit ABI: introduce ARCH_32BIT_OFF_T config option
-
-All new 32-bit architectures should have 64-bit off_t type, but existing
-architectures has 32-bit ones.
-
-To handle it, new config option is added to arch/Kconfig that defaults
-ARCH_32BIT_OFF_T to be disabled for non-64 bit architectures. All existing
-32-bit architectures enable it explicitly here.
-
-New option affects force_o_largefile() behaviour. Namely, if off_t is
-64-bits long, we have no reason to reject user to open big files.
-
-Note that even if architectures has only 64-bit off_t in the kernel
-(arc, c6x, h8300, hexagon, metag, nios2, openrisc, tile32 and unicore32),
-a libc may use 32-bit off_t, and therefore want to limit the file size
-to 4GB unless specified differently in the open flags.
-
-Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
----
- arch/Kconfig            | 4 ++++
- arch/arc/Kconfig        | 1 +
- arch/arm/Kconfig        | 1 +
- arch/blackfin/Kconfig   | 1 +
- arch/cris/Kconfig       | 1 +
- arch/frv/Kconfig        | 1 +
- arch/h8300/Kconfig      | 1 +
- arch/hexagon/Kconfig    | 1 +
- arch/m32r/Kconfig       | 1 +
- arch/m68k/Kconfig       | 1 +
- arch/metag/Kconfig      | 1 +
- arch/microblaze/Kconfig | 1 +
- arch/mips/Kconfig       | 1 +
- arch/mn10300/Kconfig    | 1 +
- arch/nios2/Kconfig      | 1 +
- arch/openrisc/Kconfig   | 1 +
- arch/parisc/Kconfig     | 1 +
- arch/powerpc/Kconfig    | 1 +
- arch/score/Kconfig      | 1 +
- arch/sh/Kconfig         | 1 +
- arch/sparc/Kconfig      | 1 +
- arch/tile/Kconfig       | 1 +
- arch/unicore32/Kconfig  | 1 +
- arch/x86/Kconfig        | 1 +
- arch/x86/um/Kconfig     | 1 +
- arch/xtensa/Kconfig     | 1 +
- include/linux/fcntl.h   | 2 +-
- 27 files changed, 30 insertions(+), 1 deletion(-)
-
-diff --git a/arch/Kconfig b/arch/Kconfig
-index ab7692e..641c1cb 100644
---- a/arch/Kconfig
-+++ b/arch/Kconfig
-@@ -233,6 +233,10 @@ config ARCH_THREAD_INFO_ALLOCATOR
- config ARCH_WANTS_DYNAMIC_TASK_STRUCT
- 	bool
- 
-+config ARCH_32BIT_OFF_T
-+	bool
-+	depends on !64BIT
-+
- config HAVE_REGS_AND_STACK_ACCESS_API
- 	bool
- 	help
-diff --git a/arch/arc/Kconfig b/arch/arc/Kconfig
-index 6312f60..570dc39 100644
---- a/arch/arc/Kconfig
-+++ b/arch/arc/Kconfig
-@@ -9,6 +9,7 @@
- config ARC
- 	def_bool y
- 	select ARCH_SUPPORTS_ATOMIC_RMW if ARC_HAS_LLSC
-+	select ARCH_32BIT_OFF_T
- 	select BUILDTIME_EXTABLE_SORT
- 	select COMMON_CLK
- 	select CLONE_BACKWARDS
-diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
-index ac1bd29..d5e6a08 100644
---- a/arch/arm/Kconfig
-+++ b/arch/arm/Kconfig
-@@ -1,6 +1,7 @@
- config ARM
- 	bool
- 	default y
-+	select ARCH_32BIT_OFF_T
- 	select ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE
- 	select ARCH_HAS_ELF_RANDOMIZE
- 	select ARCH_HAS_TICK_BROADCAST if GENERIC_CLOCKEVENTS_BROADCAST
-diff --git a/arch/blackfin/Kconfig b/arch/blackfin/Kconfig
-index af76634..9b5fc06 100644
---- a/arch/blackfin/Kconfig
-+++ b/arch/blackfin/Kconfig
-@@ -12,6 +12,7 @@ config RWSEM_XCHGADD_ALGORITHM
- 
- config BLACKFIN
- 	def_bool y
-+	select ARCH_32BIT_OFF_T
- 	select HAVE_ARCH_KGDB
- 	select HAVE_ARCH_TRACEHOOK
- 	select HAVE_DYNAMIC_FTRACE
-diff --git a/arch/cris/Kconfig b/arch/cris/Kconfig
-index e086f9e..5bc9203 100644
---- a/arch/cris/Kconfig
-+++ b/arch/cris/Kconfig
-@@ -50,6 +50,7 @@ config LOCKDEP_SUPPORT
- config CRIS
- 	bool
- 	default y
-+	select ARCH_32BIT_OFF_T
- 	select HAVE_IDE
- 	select GENERIC_ATOMIC64
- 	select HAVE_UID16
-diff --git a/arch/frv/Kconfig b/arch/frv/Kconfig
-index 34aa193..09b82fc 100644
---- a/arch/frv/Kconfig
-+++ b/arch/frv/Kconfig
-@@ -1,6 +1,7 @@
- config FRV
- 	bool
- 	default y
-+	select ARCH_32BIT_OFF_T
- 	select HAVE_IDE
- 	select HAVE_ARCH_TRACEHOOK
- 	select HAVE_PERF_EVENTS
-diff --git a/arch/h8300/Kconfig b/arch/h8300/Kconfig
-index dd3ac75..7761f4a 100644
---- a/arch/h8300/Kconfig
-+++ b/arch/h8300/Kconfig
-@@ -1,5 +1,6 @@
- config H8300
-         def_bool y
-+	select ARCH_32BIT_OFF_T
- 	select GENERIC_ATOMIC64
- 	select HAVE_UID16
- 	select VIRT_TO_BUS
-diff --git a/arch/hexagon/Kconfig b/arch/hexagon/Kconfig
-index 4dc89d1..29836fc 100644
---- a/arch/hexagon/Kconfig
-+++ b/arch/hexagon/Kconfig
-@@ -3,6 +3,7 @@ comment "Linux Kernel Configuration for Hexagon"
- 
- config HEXAGON
- 	def_bool y
-+	select ARCH_32BIT_OFF_T
- 	select HAVE_OPROFILE
- 	# Other pending projects/to-do items.
- 	# select HAVE_REGS_AND_STACK_ACCESS_API
-diff --git a/arch/m32r/Kconfig b/arch/m32r/Kconfig
-index 9e44bbd..c6865a9 100644
---- a/arch/m32r/Kconfig
-+++ b/arch/m32r/Kconfig
-@@ -1,6 +1,7 @@
- config M32R
- 	bool
- 	default y
-+	select ARCH_32BIT_OFF_T
- 	select HAVE_IDE
- 	select HAVE_OPROFILE
- 	select INIT_ALL_POSSIBLE
-diff --git a/arch/m68k/Kconfig b/arch/m68k/Kconfig
-index 498b567..e9897e4 100644
---- a/arch/m68k/Kconfig
-+++ b/arch/m68k/Kconfig
-@@ -1,6 +1,7 @@
- config M68K
- 	bool
- 	default y
-+	select ARCH_32BIT_OFF_T
- 	select ARCH_MIGHT_HAVE_PC_PARPORT if ISA
- 	select HAVE_IDE
- 	select HAVE_AOUT if MMU
-diff --git a/arch/metag/Kconfig b/arch/metag/Kconfig
-index 0b389a8..6b44d37 100644
---- a/arch/metag/Kconfig
-+++ b/arch/metag/Kconfig
-@@ -1,5 +1,6 @@
- config METAG
- 	def_bool y
-+	select ARCH_32BIT_OFF_T
- 	select EMBEDDED
- 	select GENERIC_ATOMIC64
- 	select GENERIC_CLOCKEVENTS
-diff --git a/arch/microblaze/Kconfig b/arch/microblaze/Kconfig
-index 0bce820..4b293e5 100644
---- a/arch/microblaze/Kconfig
-+++ b/arch/microblaze/Kconfig
-@@ -1,5 +1,6 @@
- config MICROBLAZE
- 	def_bool y
-+	select ARCH_32BIT_OFF_T
- 	select ARCH_HAS_GCOV_PROFILE_ALL
- 	select ARCH_MIGHT_HAVE_PC_PARPORT
- 	select ARCH_WANT_IPC_PARSE_VERSION
-diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
-index db45961..0ef9d4c 100644
---- a/arch/mips/Kconfig
-+++ b/arch/mips/Kconfig
-@@ -1,6 +1,7 @@
- config MIPS
- 	bool
- 	default y
-+	select ARCH_32BIT_OFF_T if !64BIT
- 	select ARCH_SUPPORTS_UPROBES
- 	select ARCH_MIGHT_HAVE_PC_PARPORT
- 	select ARCH_MIGHT_HAVE_PC_SERIO
-diff --git a/arch/mn10300/Kconfig b/arch/mn10300/Kconfig
-index 78ae555..edf7372 100644
---- a/arch/mn10300/Kconfig
-+++ b/arch/mn10300/Kconfig
-@@ -1,5 +1,6 @@
- config MN10300
- 	def_bool y
-+	select ARCH_32BIT_OFF_T
- 	select HAVE_OPROFILE
- 	select HAVE_UID16
- 	select GENERIC_IRQ_SHOW
-diff --git a/arch/nios2/Kconfig b/arch/nios2/Kconfig
-index 4375554..a38fc38 100644
---- a/arch/nios2/Kconfig
-+++ b/arch/nios2/Kconfig
-@@ -1,5 +1,6 @@
- config NIOS2
- 	def_bool y
-+	select ARCH_32BIT_OFF_T
- 	select ARCH_WANT_OPTIONAL_GPIOLIB
- 	select CLKSRC_OF
- 	select GENERIC_ATOMIC64
-diff --git a/arch/openrisc/Kconfig b/arch/openrisc/Kconfig
-index 443f44d..7bef847 100644
---- a/arch/openrisc/Kconfig
-+++ b/arch/openrisc/Kconfig
-@@ -5,6 +5,7 @@
- 
- config OPENRISC
- 	def_bool y
-+	select ARCH_32BIT_OFF_T
- 	select OF
- 	select OF_EARLY_FLATTREE
- 	select IRQ_DOMAIN
-diff --git a/arch/parisc/Kconfig b/arch/parisc/Kconfig
-index 729f891..8bf0fe2 100644
---- a/arch/parisc/Kconfig
-+++ b/arch/parisc/Kconfig
-@@ -1,5 +1,6 @@
- config PARISC
- 	def_bool y
-+	select ARCH_32BIT_OFF_T if !64BIT
- 	select ARCH_HAS_DEBUG_STRICT_USER_COPY_CHECKS
- 	select ARCH_MIGHT_HAVE_PC_PARPORT
- 	select HAVE_IDE
-diff --git a/arch/powerpc/Kconfig b/arch/powerpc/Kconfig
-index 38220c1..d5e6ec2 100644
---- a/arch/powerpc/Kconfig
-+++ b/arch/powerpc/Kconfig
-@@ -88,6 +88,7 @@ config ARCH_HAS_DMA_SET_COHERENT_MASK
- config PPC
- 	bool
- 	default y
-+	select ARCH_32BIT_OFF_T if PPC32
- 	select ARCH_MIGHT_HAVE_PC_PARPORT
- 	select ARCH_MIGHT_HAVE_PC_SERIO
- 	select BINFMT_ELF
-diff --git a/arch/score/Kconfig b/arch/score/Kconfig
-index 366e1b5..bc7bc7a 100644
---- a/arch/score/Kconfig
-+++ b/arch/score/Kconfig
-@@ -2,6 +2,7 @@ menu "Machine selection"
- 
- config SCORE
-        def_bool y
-+       select ARCH_32BIT_OFF_T
-        select GENERIC_IRQ_SHOW
-        select GENERIC_IOMAP
-        select GENERIC_ATOMIC64
-diff --git a/arch/sh/Kconfig b/arch/sh/Kconfig
-index d514df7e..1e9d63a 100644
---- a/arch/sh/Kconfig
-+++ b/arch/sh/Kconfig
-@@ -52,6 +52,7 @@ config SUPERH
- 
- config SUPERH32
- 	def_bool ARCH = "sh"
-+	select ARCH_32BIT_OFF_T
- 	select HAVE_KPROBES
- 	select HAVE_KRETPROBES
- 	select HAVE_IOREMAP_PROT if MMU && !X2TLB
-diff --git a/arch/sparc/Kconfig b/arch/sparc/Kconfig
-index 56442d2..1268a2a 100644
---- a/arch/sparc/Kconfig
-+++ b/arch/sparc/Kconfig
-@@ -46,6 +46,7 @@ config SPARC
- 
- config SPARC32
- 	def_bool !64BIT
-+	select ARCH_32BIT_OFF_T
- 	select GENERIC_ATOMIC64
- 	select CLZ_TAB
- 	select HAVE_UID16
-diff --git a/arch/tile/Kconfig b/arch/tile/Kconfig
-index 8ec7a45..522cf45 100644
---- a/arch/tile/Kconfig
-+++ b/arch/tile/Kconfig
-@@ -3,6 +3,7 @@
- 
- config TILE
- 	def_bool y
-+	select ARCH_32BIT_OFF_T if !64BIT
- 	select HAVE_PERF_EVENTS
- 	select USE_PMC if PERF_EVENTS
- 	select HAVE_DMA_ATTRS
-diff --git a/arch/unicore32/Kconfig b/arch/unicore32/Kconfig
-index c9faddc..b813ff8 100644
---- a/arch/unicore32/Kconfig
-+++ b/arch/unicore32/Kconfig
-@@ -1,6 +1,7 @@
- config UNICORE32
- 	def_bool y
- 	select ARCH_MIGHT_HAVE_PC_PARPORT
-+	select ARCH_32BIT_OFF_T
- 	select ARCH_MIGHT_HAVE_PC_SERIO
- 	select HAVE_MEMBLOCK
- 	select HAVE_GENERIC_DMA_COHERENT
-diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
-index 03ef954..47c841d 100644
---- a/arch/x86/Kconfig
-+++ b/arch/x86/Kconfig
-@@ -20,6 +20,7 @@ config X86
- 	select ACPI_LEGACY_TABLES_LOOKUP	if ACPI
- 	select ACPI_SYSTEM_POWER_STATES_SUPPORT	if ACPI
- 	select ANON_INODES
-+	select ARCH_32BIT_OFF_T			if X86_32
- 	select ARCH_CLOCKSOURCE_DATA
- 	select ARCH_DISCARD_MEMBLOCK
- 	select ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE
-diff --git a/arch/x86/um/Kconfig b/arch/x86/um/Kconfig
-index ed56a1c..8436bcd 100644
---- a/arch/x86/um/Kconfig
-+++ b/arch/x86/um/Kconfig
-@@ -21,6 +21,7 @@ config 64BIT
- config X86_32
- 	def_bool !64BIT
- 	select HAVE_AOUT
-+	select ARCH_32BIT_OFF_T
- 	select ARCH_WANT_IPC_PARSE_VERSION
- 	select MODULES_USE_ELF_REL
- 	select CLONE_BACKWARDS
-diff --git a/arch/xtensa/Kconfig b/arch/xtensa/Kconfig
-index 82044f7..7ff155a 100644
---- a/arch/xtensa/Kconfig
-+++ b/arch/xtensa/Kconfig
-@@ -3,6 +3,7 @@ config ZONE_DMA
- 
- config XTENSA
- 	def_bool y
-+	select ARCH_32BIT_OFF_T
- 	select ARCH_WANT_FRAME_POINTERS
- 	select ARCH_WANT_IPC_PARSE_VERSION
- 	select ARCH_WANT_OPTIONAL_GPIOLIB
-diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h
-index 76ce329..46960a1 100644
---- a/include/linux/fcntl.h
-+++ b/include/linux/fcntl.h
-@@ -5,7 +5,7 @@
- 
- 
- #ifndef force_o_largefile
--#define force_o_largefile() (BITS_PER_LONG != 32)
-+#define force_o_largefile() (!IS_ENABLED(CONFIG_ARCH_32BIT_OFF_T))
- #endif
- 
- #if BITS_PER_LONG == 32
--- 
-1.9.1
-
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0007-arm64-uapi-set-__BITS_PER_LONG-correctly-for-ILP32-a.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0007-arm64-uapi-set-__BITS_PER_LONG-correctly-for-ILP32-a.patch
new file mode 100644
index 0000000..1f40b30
--- /dev/null
+++ b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0007-arm64-uapi-set-__BITS_PER_LONG-correctly-for-ILP32-a.patch
@@ -0,0 +1,42 @@
+From db06b62c4555eb302c8d5cc9c222187907337c2c Mon Sep 17 00:00:00 2001
+From: Andrew Pinski <apinski@cavium.com>
+Date: Tue, 24 May 2016 03:04:40 +0300
+Subject: [PATCH 07/20] arm64:uapi: set __BITS_PER_LONG correctly for ILP32 and
+ LP64
+
+Define __BITS_PER_LONG depending on the ABI used (i.e. check whether
+__ILP32__ or __LP64__ is defined).  This is necessary for glibc to
+determine the appropriate type definitions for the system call interface.
+
+Signed-off-by: Andrew Pinski <apinski@cavium.com>
+Signed-off-by: Philipp Tomsich <philipp.tomsich@theobroma-systems.com>
+Signed-off-by: Christoph Muellner <christoph.muellner@theobroma-systems.com>
+Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
+Reviewed-by: David Daney <ddaney@caviumnetworks.com>
+---
+ arch/arm64/include/uapi/asm/bitsperlong.h | 9 ++++++++-
+ 1 file changed, 8 insertions(+), 1 deletion(-)
+
+diff --git a/arch/arm64/include/uapi/asm/bitsperlong.h b/arch/arm64/include/uapi/asm/bitsperlong.h
+index fce9c29..4265243 100644
+--- a/arch/arm64/include/uapi/asm/bitsperlong.h
++++ b/arch/arm64/include/uapi/asm/bitsperlong.h
+@@ -16,7 +16,14 @@
+ #ifndef __ASM_BITSPERLONG_H
+ #define __ASM_BITSPERLONG_H
+ 
+-#define __BITS_PER_LONG 64
++#if defined(__LP64__)
++/* Assuming __LP64__ will be defined for native ELF64's and not for ILP32. */
++#  define __BITS_PER_LONG 64
++#elif defined(__ILP32__)
++#  define __BITS_PER_LONG 32
++#else
++#  error "Neither LP64 nor ILP32: unsupported ABI in asm/bitsperlong.h"
++#endif
+ 
+ #include <asm-generic/bitsperlong.h>
+ 
+-- 
+2.5.0
+
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0008-arm64-ilp32-add-documentation-on-the-ILP32-ABI-for-A.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0008-arm64-ilp32-add-documentation-on-the-ILP32-ABI-for-A.patch
deleted file mode 100644
index 1b1a3ef..0000000
--- a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0008-arm64-ilp32-add-documentation-on-the-ILP32-ABI-for-A.patch
+++ /dev/null
@@ -1,48 +0,0 @@
-From 02775c34d1946eaae1508760b11466c13b8b2f80 Mon Sep 17 00:00:00 2001
-From: Yury Norov <ynorov@caviumnetworks.com>
-Date: Tue, 24 May 2016 03:04:37 +0300
-Subject: [PATCH 08/24] arm64: ilp32: add documentation on the ILP32 ABI for
- ARM64
-
-Based on Andrew Pinski's patch-series.
-
-Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
----
- Documentation/arm64/ilp32.txt | 25 +++++++++++++++++++++++++
- 1 file changed, 25 insertions(+)
- create mode 100644 Documentation/arm64/ilp32.txt
-
-diff --git a/Documentation/arm64/ilp32.txt b/Documentation/arm64/ilp32.txt
-new file mode 100644
-index 0000000..8e74d67
---- /dev/null
-+++ b/Documentation/arm64/ilp32.txt
-@@ -0,0 +1,25 @@
-+ILP32 AARCH64 SYSCALL ABI
-+=========================
-+
-+This document describes the ILP32 syscall ABI and where it differs
-+from the generic compat linux syscall interface.
-+
-+Syscalls which normally would pass 64bit values as two arguments;
-+now pass the 64bit value as one argument. Next syscalls are affected:
-+fadvise64_64,
-+fallocate,
-+ftruncate,
-+lookup_dcookie,
-+pread64,
-+pwrite64,
-+readahead,
-+shmat,
-+sync_file_range,
-+truncate,
-+lseek,
-+mmap
-+
-+struct rt_sigframe is redefined and contains struct compat_siginfo,
-+as compat syscalls expects, and struct ilp32_sigframe, to handle
-+AARCH64 register set and 32-bit userspace register representation.
-+
--- 
-1.9.1
-
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0008-thread-move-thread-bits-accessors-to-separated-file.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0008-thread-move-thread-bits-accessors-to-separated-file.patch
new file mode 100644
index 0000000..88cac01
--- /dev/null
+++ b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0008-thread-move-thread-bits-accessors-to-separated-file.patch
@@ -0,0 +1,144 @@
+From 728639626bdd57af565f043776730b4362b68f38 Mon Sep 17 00:00:00 2001
+From: Yury Norov <ynorov@caviumnetworks.com>
+Date: Tue, 24 May 2016 03:04:41 +0300
+Subject: [PATCH 08/20] thread: move thread bits accessors to separated file
+
+They may be accessed from low-level code, so isolating is a measure to
+avoid circular dependencies in header files.
+
+The exact reason for circular dependency is WARN_ON() macro added by Al
+Viro in patch [edd63a27] "set_restore_sigmask() is never called without
+SIGPENDING (and never should be)"
+
+Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
+---
+ include/linux/thread_bits.h | 54 +++++++++++++++++++++++++++++++++++++++++++++
+ include/linux/thread_info.h | 44 +-----------------------------------
+ 2 files changed, 55 insertions(+), 43 deletions(-)
+ create mode 100644 include/linux/thread_bits.h
+
+diff --git a/include/linux/thread_bits.h b/include/linux/thread_bits.h
+new file mode 100644
+index 0000000..ed788b0
+--- /dev/null
++++ b/include/linux/thread_bits.h
+@@ -0,0 +1,54 @@
++
++/* thread_bits.h: common low-level thread bits accessors */
++
++#ifndef _LINUX_THREAD_BITS_H
++#define _LINUX_THREAD_BITS_H
++
++#ifndef __ASSEMBLY__
++
++#include <linux/bitops.h>
++#include <asm/thread_info.h>
++
++/*
++ * flag set/clear/test wrappers
++ * - pass TIF_xxxx constants to these functions
++ */
++
++static inline void set_ti_thread_flag(struct thread_info *ti, int flag)
++{
++	set_bit(flag, (unsigned long *)&ti->flags);
++}
++
++static inline void clear_ti_thread_flag(struct thread_info *ti, int flag)
++{
++	clear_bit(flag, (unsigned long *)&ti->flags);
++}
++
++static inline int test_and_set_ti_thread_flag(struct thread_info *ti, int flag)
++{
++	return test_and_set_bit(flag, (unsigned long *)&ti->flags);
++}
++
++static inline int test_and_clear_ti_thread_flag(struct thread_info *ti, int flag)
++{
++	return test_and_clear_bit(flag, (unsigned long *)&ti->flags);
++}
++
++static inline int test_ti_thread_flag(struct thread_info *ti, int flag)
++{
++	return test_bit(flag, (unsigned long *)&ti->flags);
++}
++
++#define set_thread_flag(flag) \
++	set_ti_thread_flag(current_thread_info(), flag)
++#define clear_thread_flag(flag) \
++	clear_ti_thread_flag(current_thread_info(), flag)
++#define test_and_set_thread_flag(flag) \
++	test_and_set_ti_thread_flag(current_thread_info(), flag)
++#define test_and_clear_thread_flag(flag) \
++	test_and_clear_ti_thread_flag(current_thread_info(), flag)
++#define test_thread_flag(flag) \
++	test_ti_thread_flag(current_thread_info(), flag)
++
++#endif /* !__ASSEMBLY__ */
++#endif /* _LINUX_THREAD_BITS_H */
+diff --git a/include/linux/thread_info.h b/include/linux/thread_info.h
+index ff307b5..c905fec 100644
+--- a/include/linux/thread_info.h
++++ b/include/linux/thread_info.h
+@@ -50,8 +50,7 @@ struct restart_block {
+ 
+ extern long do_no_restart_syscall(struct restart_block *parm);
+ 
+-#include <linux/bitops.h>
+-#include <asm/thread_info.h>
++#include <linux/thread_bits.h>
+ 
+ #ifdef __KERNEL__
+ 
+@@ -61,47 +60,6 @@ extern long do_no_restart_syscall(struct restart_block *parm);
+ # define THREADINFO_GFP		(GFP_KERNEL | __GFP_NOTRACK)
+ #endif
+ 
+-/*
+- * flag set/clear/test wrappers
+- * - pass TIF_xxxx constants to these functions
+- */
+-
+-static inline void set_ti_thread_flag(struct thread_info *ti, int flag)
+-{
+-	set_bit(flag, (unsigned long *)&ti->flags);
+-}
+-
+-static inline void clear_ti_thread_flag(struct thread_info *ti, int flag)
+-{
+-	clear_bit(flag, (unsigned long *)&ti->flags);
+-}
+-
+-static inline int test_and_set_ti_thread_flag(struct thread_info *ti, int flag)
+-{
+-	return test_and_set_bit(flag, (unsigned long *)&ti->flags);
+-}
+-
+-static inline int test_and_clear_ti_thread_flag(struct thread_info *ti, int flag)
+-{
+-	return test_and_clear_bit(flag, (unsigned long *)&ti->flags);
+-}
+-
+-static inline int test_ti_thread_flag(struct thread_info *ti, int flag)
+-{
+-	return test_bit(flag, (unsigned long *)&ti->flags);
+-}
+-
+-#define set_thread_flag(flag) \
+-	set_ti_thread_flag(current_thread_info(), flag)
+-#define clear_thread_flag(flag) \
+-	clear_ti_thread_flag(current_thread_info(), flag)
+-#define test_and_set_thread_flag(flag) \
+-	test_and_set_ti_thread_flag(current_thread_info(), flag)
+-#define test_and_clear_thread_flag(flag) \
+-	test_and_clear_ti_thread_flag(current_thread_info(), flag)
+-#define test_thread_flag(flag) \
+-	test_ti_thread_flag(current_thread_info(), flag)
+-
+ #define tif_need_resched() test_thread_flag(TIF_NEED_RESCHED)
+ 
+ #if defined TIF_RESTORE_SIGMASK && !defined HAVE_SET_RESTORE_SIGMASK
+-- 
+2.5.0
+
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0009-arm64-ensure-the-kernel-is-compiled-for-LP64.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0009-arm64-ensure-the-kernel-is-compiled-for-LP64.patch
deleted file mode 100644
index b99612a..0000000
--- a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0009-arm64-ensure-the-kernel-is-compiled-for-LP64.patch
+++ /dev/null
@@ -1,47 +0,0 @@
-From c9b49342587a234e1d556ba3ad605e6636034c4d Mon Sep 17 00:00:00 2001
-From: Manish Jaggi <mjaggi@cavium.com>
-Date: Wed, 14 Dec 2016 06:01:02 -0800
-Subject: [PATCH]  [PATCH 09/24] arm64: ensure the kernel is compiled for LP64
-
-The kernel needs to be compiled as a LP64 binary for ARM64, even when
-using a compiler that defaults to code-generation for the ILP32 ABI.
-Consequently, we need to explicitly pass '-mabi=lp64' (supported on
-gcc-4.9 and newer).
-
-Signed-off-by: Andrew Pinski <Andrew.Pinski@caviumnetworks.com>
-Signed-off-by: Philipp Tomsich <philipp.tomsich@theobroma-systems.com>
-Signed-off-by: Christoph Muellner <christoph.muellner@theobroma-systems.com>
-Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
-Reviewed-by: David Daney <ddaney@caviumnetworks.com>
----
- arch/arm64/Makefile | 5 +++++
- 1 file changed, 5 insertions(+)
-
-diff --git a/arch/arm64/Makefile b/arch/arm64/Makefile
-index 9d9301e..1c839df 100644
---- a/arch/arm64/Makefile
-+++ b/arch/arm64/Makefile
-@@ -30,15 +30,20 @@ KBUILD_CFLAGS	+= -mgeneral-regs-only $(lseinstr)
- KBUILD_CFLAGS	+= $(call cc-option, -mpc-relative-literal-loads)
- KBUILD_AFLAGS	+= $(lseinstr)
- 
-+KBUILD_CFLAGS	+= $(call cc-option,-mabi=lp64)
-+KBUILD_AFLAGS	+= $(call cc-option,-mabi=lp64)
-+
- ifeq ($(CONFIG_CPU_BIG_ENDIAN), y)
- KBUILD_CPPFLAGS	+= -mbig-endian
- AS		+= -EB
- LD		+= -EB
-+LDFLAGS		+= -maarch64linuxb
- UTS_MACHINE	:= aarch64_be
- else
- KBUILD_CPPFLAGS	+= -mlittle-endian
- AS		+= -EL
- LD		+= -EL
-+LDFLAGS		+= -maarch64linuxb
- UTS_MACHINE	:= aarch64
- endif
- 
--- 
-2.5.0
-
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0009-arm64-introduce-is_a32_task-and-is_a32_thread-for.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0009-arm64-introduce-is_a32_task-and-is_a32_thread-for.patch
new file mode 100644
index 0000000..c278d65
--- /dev/null
+++ b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0009-arm64-introduce-is_a32_task-and-is_a32_thread-for.patch
@@ -0,0 +1,444 @@
+From c369d359f1407fa783dbff66ce6092b1783feb97 Mon Sep 17 00:00:00 2001
+From: Manish Jaggi <mjaggi@cavium.com>
+Date: Wed, 29 Mar 2017 17:55:11 -0700
+Subject: [PATCH 09/20]  arm64: introduce is_a32_task and is_a32_thread (for 
+ AArch32 compat)
+
+Based on patch of Andrew Pinski.
+
+This patch introduces is_a32_compat_task and is_a32_thread so it is
+easier to say this is a a32 specific thread or a generic compat thread/task.
+Corresponding functions are located in <asm/is_compat.h> to avoid mess in
+headers.
+
+Some files include both <linux/compat.h> and <asm/compat.h>,
+and this is wrong because <linux/compat.h> has <asm/compat.h> already
+included. It was fixed too.
+
+Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
+Signed-off-by: Philipp Tomsich <philipp.tomsich@theobroma-systems.com>
+Signed-off-by: Christoph Muellner <christoph.muellner@theobroma-systems.com>
+Signed-off-by: Andrew Pinski <Andrew.Pinski@caviumnetworks.com>
+Reviewed-by: David Daney <ddaney@caviumnetworks.com>
+---
+ arch/arm64/include/asm/compat.h      | 19 ++---------
+ arch/arm64/include/asm/elf.h         | 10 +++---
+ arch/arm64/include/asm/ftrace.h      |  2 +-
+ arch/arm64/include/asm/is_compat.h   | 64 ++++++++++++++++++++++++++++++++++++
+ arch/arm64/include/asm/memory.h      |  5 +--
+ arch/arm64/include/asm/processor.h   |  6 ++--
+ arch/arm64/include/asm/syscall.h     |  2 +-
+ arch/arm64/include/asm/thread_info.h |  2 +-
+ arch/arm64/kernel/hw_breakpoint.c    | 10 +++---
+ arch/arm64/kernel/perf_regs.c        |  2 +-
+ arch/arm64/kernel/process.c          |  6 ++--
+ arch/arm64/kernel/ptrace.c           |  8 ++---
+ arch/arm64/kernel/signal.c           |  4 +--
+ arch/arm64/kernel/traps.c            |  3 +-
+ 14 files changed, 97 insertions(+), 46 deletions(-)
+ create mode 100644 arch/arm64/include/asm/is_compat.h
+
+diff --git a/arch/arm64/include/asm/compat.h b/arch/arm64/include/asm/compat.h
+index eb8432b..df2f72d 100644
+--- a/arch/arm64/include/asm/compat.h
++++ b/arch/arm64/include/asm/compat.h
+@@ -24,6 +24,8 @@
+ #include <linux/types.h>
+ #include <linux/sched.h>
+ 
++#include <asm/is_compat.h>
++
+ #define COMPAT_USER_HZ		100
+ #ifdef __AARCH64EB__
+ #define COMPAT_UTS_MACHINE	"armv8b\0\0"
+@@ -298,23 +300,6 @@ struct compat_shmid64_ds {
+ 	compat_ulong_t __unused5;
+ };
+ 
+-static inline int is_compat_task(void)
+-{
+-	return test_thread_flag(TIF_32BIT);
+-}
+-
+-static inline int is_compat_thread(struct thread_info *thread)
+-{
+-	return test_ti_thread_flag(thread, TIF_32BIT);
+-}
+-
+-#else /* !CONFIG_COMPAT */
+-
+-static inline int is_compat_thread(struct thread_info *thread)
+-{
+-	return 0;
+-}
+-
+ #endif /* CONFIG_COMPAT */
+ #endif /* __KERNEL__ */
+ #endif /* __ASM_COMPAT_H */
+diff --git a/arch/arm64/include/asm/elf.h b/arch/arm64/include/asm/elf.h
+index faad6df..d7e01fe 100644
+--- a/arch/arm64/include/asm/elf.h
++++ b/arch/arm64/include/asm/elf.h
+@@ -16,6 +16,10 @@
+ #ifndef __ASM_ELF_H
+ #define __ASM_ELF_H
+ 
++#ifndef __ASSEMBLY__
++#include <linux/compat.h>
++#endif
++
+ #include <asm/hwcap.h>
+ 
+ /*
+@@ -148,13 +152,9 @@ extern int arch_setup_additional_pages(struct linux_binprm *bprm,
+ 				       int uses_interp);
+ 
+ /* 1GB of VA */
+-#ifdef CONFIG_COMPAT
+-#define STACK_RND_MASK			(test_thread_flag(TIF_32BIT) ? \
++#define STACK_RND_MASK			(is_compat_task() ? \
+ 						0x7ff >> (PAGE_SHIFT - 12) : \
+ 						0x3ffff >> (PAGE_SHIFT - 12))
+-#else
+-#define STACK_RND_MASK			(0x3ffff >> (PAGE_SHIFT - 12))
+-#endif
+ 
+ #ifdef CONFIG_COMPAT
+ 
+diff --git a/arch/arm64/include/asm/ftrace.h b/arch/arm64/include/asm/ftrace.h
+index c5534fa..61cd658 100644
+--- a/arch/arm64/include/asm/ftrace.h
++++ b/arch/arm64/include/asm/ftrace.h
+@@ -52,7 +52,7 @@ static inline unsigned long ftrace_call_adjust(unsigned long addr)
+ #define ARCH_TRACE_IGNORE_COMPAT_SYSCALLS
+ static inline bool arch_trace_is_compat_syscall(struct pt_regs *regs)
+ {
+-	return is_compat_task();
++	return is_a32_compat_task();
+ }
+ #endif /* ifndef __ASSEMBLY__ */
+ 
+diff --git a/arch/arm64/include/asm/is_compat.h b/arch/arm64/include/asm/is_compat.h
+new file mode 100644
+index 0000000..8dba5ca
+--- /dev/null
++++ b/arch/arm64/include/asm/is_compat.h
+@@ -0,0 +1,64 @@
++/*
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
++ */
++
++#ifndef __ASM_IS_COMPAT_H
++#define __ASM_IS_COMPAT_H
++#ifndef __ASSEMBLY__
++
++#include <linux/thread_bits.h>
++
++#ifdef CONFIG_AARCH32_EL0
++
++static inline int is_a32_compat_task(void)
++{
++	return test_thread_flag(TIF_32BIT);
++}
++
++static inline int is_a32_compat_thread(struct thread_info *thread)
++{
++	return test_ti_thread_flag(thread, TIF_32BIT);
++}
++
++#else
++
++static inline int is_a32_compat_task(void)
++
++{
++	return 0;
++}
++
++static inline int is_a32_compat_thread(struct thread_info *thread)
++{
++	return 0;
++}
++
++#endif /* CONFIG_AARCH32_EL0 */
++
++#ifdef CONFIG_COMPAT
++
++static inline int is_compat_task(void)
++{
++	return is_a32_compat_task();
++}
++
++#endif /* CONFIG_COMPAT */
++
++static inline int is_compat_thread(struct thread_info *thread)
++{
++	return is_a32_compat_thread(thread);
++}
++
++
++#endif /* !__ASSEMBLY__ */
++#endif /* __ASM_IS_COMPAT_H */
+diff --git a/arch/arm64/include/asm/memory.h b/arch/arm64/include/asm/memory.h
+index 853953c..a2eccd9 100644
+--- a/arch/arm64/include/asm/memory.h
++++ b/arch/arm64/include/asm/memory.h
+@@ -25,6 +25,7 @@
+ #include <linux/const.h>
+ #include <linux/types.h>
+ #include <asm/sizes.h>
++#include <asm/is_compat.h>
+ 
+ /*
+  * Allow for constants defined here to be used from assembly code
+@@ -60,9 +61,9 @@
+ 
+ #ifdef CONFIG_COMPAT
+ #define TASK_SIZE_32		UL(0x100000000)
+-#define TASK_SIZE		(test_thread_flag(TIF_32BIT) ? \
++#define TASK_SIZE		(is_compat_task() ?		\
+ 				TASK_SIZE_32 : TASK_SIZE_64)
+-#define TASK_SIZE_OF(tsk)	(test_tsk_thread_flag(tsk, TIF_32BIT) ? \
++#define TASK_SIZE_OF(tsk)	(is_compat_thread(tsk) ? \
+ 				TASK_SIZE_32 : TASK_SIZE_64)
+ #else
+ #define TASK_SIZE		TASK_SIZE_64
+diff --git a/arch/arm64/include/asm/processor.h b/arch/arm64/include/asm/processor.h
+index ba48561..fca24a6 100644
+--- a/arch/arm64/include/asm/processor.h
++++ b/arch/arm64/include/asm/processor.h
+@@ -28,7 +28,7 @@
+ #ifdef __KERNEL__
+ 
+ #include <linux/string.h>
+-
++#include <asm/is_compat.h>
+ #include <asm/alternative.h>
+ #include <asm/fpsimd.h>
+ #include <asm/hw_breakpoint.h>
+@@ -41,7 +41,7 @@
+ #define STACK_TOP_MAX		TASK_SIZE_64
+ #ifdef CONFIG_COMPAT
+ #define AARCH32_VECTORS_BASE	0xffff0000
+-#define STACK_TOP		(test_thread_flag(TIF_32BIT) ? \
++#define STACK_TOP		(is_compat_task() ? \
+ 				AARCH32_VECTORS_BASE : STACK_TOP_MAX)
+ #else
+ #define STACK_TOP		STACK_TOP_MAX
+@@ -94,7 +94,7 @@ struct thread_struct {
+ #define task_user_tls(t)						\
+ ({									\
+ 	unsigned long *__tls;						\
+-	if (is_compat_thread(task_thread_info(t)))			\
++	if (is_a32_compat_thread(task_thread_info(t)))			\
+ 		__tls = &(t)->thread.tp2_value;				\
+ 	else								\
+ 		__tls = &(t)->thread.tp_value;				\
+diff --git a/arch/arm64/include/asm/syscall.h b/arch/arm64/include/asm/syscall.h
+index 709a574..ce09641 100644
+--- a/arch/arm64/include/asm/syscall.h
++++ b/arch/arm64/include/asm/syscall.h
+@@ -113,7 +113,7 @@ static inline void syscall_set_arguments(struct task_struct *task,
+  */
+ static inline int syscall_get_arch(void)
+ {
+-	if (is_compat_task())
++	if (is_a32_compat_task())
+ 		return AUDIT_ARCH_ARM;
+ 
+ 	return AUDIT_ARCH_AARCH64;
+diff --git a/arch/arm64/include/asm/thread_info.h b/arch/arm64/include/asm/thread_info.h
+index 90c7ff2..dd046c5 100644
+--- a/arch/arm64/include/asm/thread_info.h
++++ b/arch/arm64/include/asm/thread_info.h
+@@ -112,7 +112,7 @@ static inline struct thread_info *current_thread_info(void)
+ #define TIF_FREEZE		19
+ #define TIF_RESTORE_SIGMASK	20
+ #define TIF_SINGLESTEP		21
+-#define TIF_32BIT		22	/* 32bit process */
++#define TIF_32BIT		22	/* AARCH32 process */
+ 
+ #define _TIF_SIGPENDING		(1 << TIF_SIGPENDING)
+ #define _TIF_NEED_RESCHED	(1 << TIF_NEED_RESCHED)
+diff --git a/arch/arm64/kernel/hw_breakpoint.c b/arch/arm64/kernel/hw_breakpoint.c
+index b45c95d..baa1eba 100644
+--- a/arch/arm64/kernel/hw_breakpoint.c
++++ b/arch/arm64/kernel/hw_breakpoint.c
+@@ -164,7 +164,7 @@ enum hw_breakpoint_ops {
+ 	HW_BREAKPOINT_RESTORE
+ };
+ 
+-static int is_compat_bp(struct perf_event *bp)
++static int is_a32_compat_bp(struct perf_event *bp)
+ {
+ 	struct task_struct *tsk = bp->hw.target;
+ 
+@@ -175,7 +175,7 @@ static int is_compat_bp(struct perf_event *bp)
+ 	 * deprecated behaviour if we use unaligned watchpoints in
+ 	 * AArch64 state.
+ 	 */
+-	return tsk && is_compat_thread(task_thread_info(tsk));
++	return tsk && is_a32_compat_thread(task_thread_info(tsk));
+ }
+ 
+ /**
+@@ -435,7 +435,7 @@ static int arch_build_bp_info(struct perf_event *bp)
+ 	 * Watchpoints can be of length 1, 2, 4 or 8 bytes.
+ 	 */
+ 	if (info->ctrl.type == ARM_BREAKPOINT_EXECUTE) {
+-		if (is_compat_bp(bp)) {
++		if (is_a32_compat_bp(bp)) {
+ 			if (info->ctrl.len != ARM_BREAKPOINT_LEN_2 &&
+ 			    info->ctrl.len != ARM_BREAKPOINT_LEN_4)
+ 				return -EINVAL;
+@@ -492,7 +492,7 @@ int arch_validate_hwbkpt_settings(struct perf_event *bp)
+ 	 * AArch32 tasks expect some simple alignment fixups, so emulate
+ 	 * that here.
+ 	 */
+-	if (is_compat_bp(bp)) {
++	if (is_a32_compat_bp(bp)) {
+ 		if (info->ctrl.len == ARM_BREAKPOINT_LEN_8)
+ 			alignment_mask = 0x7;
+ 		else
+@@ -679,7 +679,7 @@ static int watchpoint_handler(unsigned long addr, unsigned int esr,
+ 
+ 		info = counter_arch_bp(wp);
+ 		/* AArch32 watchpoints are either 4 or 8 bytes aligned. */
+-		if (is_compat_task()) {
++		if (is_a32_compat_task()) {
+ 			if (info->ctrl.len == ARM_BREAKPOINT_LEN_8)
+ 				alignment_mask = 0x7;
+ 			else
+diff --git a/arch/arm64/kernel/perf_regs.c b/arch/arm64/kernel/perf_regs.c
+index 3f62b35..a79058f 100644
+--- a/arch/arm64/kernel/perf_regs.c
++++ b/arch/arm64/kernel/perf_regs.c
+@@ -45,7 +45,7 @@ int perf_reg_validate(u64 mask)
+ 
+ u64 perf_reg_abi(struct task_struct *task)
+ {
+-	if (is_compat_thread(task_thread_info(task)))
++	if (is_a32_compat_thread(task_thread_info(task)))
+ 		return PERF_SAMPLE_REGS_ABI_32;
+ 	else
+ 		return PERF_SAMPLE_REGS_ABI_64;
+diff --git a/arch/arm64/kernel/process.c b/arch/arm64/kernel/process.c
+index f75b540..546070b 100644
+--- a/arch/arm64/kernel/process.c
++++ b/arch/arm64/kernel/process.c
+@@ -210,7 +210,7 @@ static void tls_thread_flush(void)
+ {
+ 	asm ("msr tpidr_el0, xzr");
+ 
+-	if (is_compat_task()) {
++	if (is_a32_compat_task()) {
+ 		current->thread.tp_value = 0;
+ 
+ 		/*
+@@ -262,7 +262,7 @@ int copy_thread(unsigned long clone_flags, unsigned long stack_start,
+ 		asm("mrs %0, tpidr_el0" : "=r" (*task_user_tls(p)));
+ 
+ 		if (stack_start) {
+-			if (is_compat_thread(task_thread_info(p)))
++			if (is_a32_compat_thread(task_thread_info(p)))
+ 				childregs->compat_sp = stack_start;
+ 			/* 16-byte aligned stack mandatory on AArch64 */
+ 			else if (stack_start & 15)
+@@ -299,7 +299,7 @@ static void tls_thread_switch(struct task_struct *next)
+ 	*task_user_tls(current) = tpidr;
+ 
+ 	tpidr = *task_user_tls(next);
+-	tpidrro = is_compat_thread(task_thread_info(next)) ?
++	tpidrro = is_a32_compat_thread(task_thread_info(next)) ?
+ 		  next->thread.tp_value : 0;
+ 
+ 	asm(
+diff --git a/arch/arm64/kernel/ptrace.c b/arch/arm64/kernel/ptrace.c
+index 16ed9fd..2b644c9 100644
+--- a/arch/arm64/kernel/ptrace.c
++++ b/arch/arm64/kernel/ptrace.c
+@@ -85,7 +85,7 @@ static void ptrace_hbptriggered(struct perf_event *bp,
+ #ifdef CONFIG_AARCH32_EL0
+ 	int i;
+ 
+-	if (!is_compat_task())
++	if (!is_a32_compat_task())
+ 		goto send_sig;
+ 
+ 	for (i = 0; i < ARM_MAX_BRP; ++i) {
+@@ -1203,9 +1203,9 @@ const struct user_regset_view *task_user_regset_view(struct task_struct *task)
+ 	 * 32-bit children use an extended user_aarch32_ptrace_view to allow
+ 	 * access to the TLS register.
+ 	 */
+-	if (is_compat_task())
++	if (is_a32_compat_task())
+ 		return &user_aarch32_view;
+-	else if (is_compat_thread(task_thread_info(task)))
++	else if (is_a32_compat_thread(task_thread_info(task)))
+ 		return &user_aarch32_ptrace_view;
+ #endif
+ 	return &user_aarch64_view;
+@@ -1232,7 +1232,7 @@ static void tracehook_report_syscall(struct pt_regs *regs,
+ 	 * A scratch register (ip(r12) on AArch32, x7 on AArch64) is
+ 	 * used to denote syscall entry/exit:
+ 	 */
+-	regno = (is_compat_task() ? 12 : 7);
++	regno = (is_a32_compat_task() ? 12 : 7);
+ 	saved_reg = regs->regs[regno];
+ 	regs->regs[regno] = dir;
+ 
+diff --git a/arch/arm64/kernel/signal.c b/arch/arm64/kernel/signal.c
+index e18c48c..65baaef 100644
+--- a/arch/arm64/kernel/signal.c
++++ b/arch/arm64/kernel/signal.c
+@@ -276,7 +276,7 @@ static int setup_rt_frame(int usig, struct ksignal *ksig, sigset_t *set,
+ 
+ static void setup_restart_syscall(struct pt_regs *regs)
+ {
+-	if (is_compat_task())
++	if (is_a32_compat_task())
+ 		compat_setup_restart_syscall(regs);
+ 	else
+ 		regs->regs[8] = __NR_restart_syscall;
+@@ -295,7 +295,7 @@ static void handle_signal(struct ksignal *ksig, struct pt_regs *regs)
+ 	/*
+ 	 * Set up the stack frame
+ 	 */
+-	if (is_compat_task()) {
++	if (is_a32_compat_task()) {
+ 		if (ksig->ka.sa.sa_flags & SA_SIGINFO)
+ 			ret = compat_setup_rt_frame(usig, ksig, oldset, regs);
+ 		else
+diff --git a/arch/arm64/kernel/traps.c b/arch/arm64/kernel/traps.c
+index b50fced..4115c44 100644
+--- a/arch/arm64/kernel/traps.c
++++ b/arch/arm64/kernel/traps.c
+@@ -18,6 +18,7 @@
+  */
+ 
+ #include <linux/bug.h>
++#include <linux/compat.h>
+ #include <linux/signal.h>
+ #include <linux/personality.h>
+ #include <linux/kallsyms.h>
+@@ -370,7 +371,7 @@ asmlinkage long do_ni_syscall(struct pt_regs *regs)
+ {
+ #ifdef CONFIG_AARCH32_EL0
+ 	long ret;
+-	if (is_compat_task()) {
++	if (is_a32_compat_task()) {
+ 		ret = compat_arm_syscall(regs);
+ 		if (ret != -ENOSYS)
+ 			return ret;
+-- 
+2.5.0
+
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0010-arm64-ilp32-add-is_ilp32_compat_-task-thread-and-TIF.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0010-arm64-ilp32-add-is_ilp32_compat_-task-thread-and-TIF.patch
new file mode 100644
index 0000000..828815e
--- /dev/null
+++ b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0010-arm64-ilp32-add-is_ilp32_compat_-task-thread-and-TIF.patch
@@ -0,0 +1,129 @@
+From aab9b1d615dd3b13f18ba43fa4dc553747119c3e Mon Sep 17 00:00:00 2001
+From: Yury Norov <ynorov@caviumnetworks.com>
+Date: Tue, 24 May 2016 03:04:43 +0300
+Subject: [PATCH 10/20] arm64: ilp32: add is_ilp32_compat_{task,thread} and
+ TIF_32BIT_AARCH64
+
+ILP32 tasks are needed to be distinguished from lp64 and aarch32.
+This patch adds helper functions is_ilp32_compat_{task,thread} and
+thread flag TIF_32BIT_AARCH64 to address it. This is a preparation
+for following patches in ilp32 patchset.
+
+For consistency, SET_PERSONALITY is changed here accordingly.
+
+Signed-off-by: Andrew Pinski <Andrew.Pinski@caviumnetworks.com>
+Signed-off-by: Philipp Tomsich <philipp.tomsich@theobroma-systems.com>
+Signed-off-by: Christoph Muellner <christoph.muellner@theobroma-systems.com>
+Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
+Reviewed-by: David Daney <ddaney@caviumnetworks.com>
+---
+ arch/arm64/include/asm/elf.h         | 13 +++++++++++--
+ arch/arm64/include/asm/is_compat.h   | 30 ++++++++++++++++++++++++++++--
+ arch/arm64/include/asm/thread_info.h |  2 ++
+ 3 files changed, 41 insertions(+), 4 deletions(-)
+
+diff --git a/arch/arm64/include/asm/elf.h b/arch/arm64/include/asm/elf.h
+index d7e01fe..61b844c 100644
+--- a/arch/arm64/include/asm/elf.h
++++ b/arch/arm64/include/asm/elf.h
+@@ -138,7 +138,11 @@ typedef struct user_fpsimd_state elf_fpregset_t;
+  */
+ #define ELF_PLAT_INIT(_r, load_addr)	(_r)->regs[0] = 0
+ 
+-#define SET_PERSONALITY(ex)		clear_thread_flag(TIF_32BIT);
++#define SET_PERSONALITY(ex)		\
++do {						\
++	clear_thread_flag(TIF_32BIT_AARCH64);	\
++	clear_thread_flag(TIF_32BIT);		\
++} while (0)
+ 
+ #define ARCH_DLINFO							\
+ do {									\
+@@ -177,7 +181,12 @@ typedef compat_elf_greg_t		compat_elf_gregset_t[COMPAT_ELF_NGREG];
+ 					 ((x)->e_flags & EF_ARM_EABI_MASK))
+ 
+ #define compat_start_thread		compat_start_thread
+-#define COMPAT_SET_PERSONALITY(ex)	set_thread_flag(TIF_32BIT);
++#define COMPAT_SET_PERSONALITY(ex)		\
++do {						\
++	clear_thread_flag(TIF_32BIT_AARCH64);	\
++	set_thread_flag(TIF_32BIT);		\
++} while (0)
++
+ #define COMPAT_ARCH_DLINFO
+ extern int aarch32_setup_vectors_page(struct linux_binprm *bprm,
+ 				      int uses_interp);
+diff --git a/arch/arm64/include/asm/is_compat.h b/arch/arm64/include/asm/is_compat.h
+index 8dba5ca..7726beb 100644
+--- a/arch/arm64/include/asm/is_compat.h
++++ b/arch/arm64/include/asm/is_compat.h
+@@ -45,18 +45,44 @@ static inline int is_a32_compat_thread(struct thread_info *thread)
+ 
+ #endif /* CONFIG_AARCH32_EL0 */
+ 
++#ifdef CONFIG_ARM64_ILP32
++
++static inline int is_ilp32_compat_task(void)
++{
++	return test_thread_flag(TIF_32BIT_AARCH64);
++}
++
++static inline int is_ilp32_compat_thread(struct thread_info *thread)
++{
++	return test_ti_thread_flag(thread, TIF_32BIT_AARCH64);
++}
++
++#else
++
++static inline int is_ilp32_compat_task(void)
++{
++	return 0;
++}
++
++static inline int is_ilp32_compat_thread(struct thread_info *thread)
++{
++	return 0;
++}
++
++#endif /* CONFIG_ARM64_ILP32 */
++
+ #ifdef CONFIG_COMPAT
+ 
+ static inline int is_compat_task(void)
+ {
+-	return is_a32_compat_task();
++	return is_a32_compat_task() || is_ilp32_compat_task();
+ }
+ 
+ #endif /* CONFIG_COMPAT */
+ 
+ static inline int is_compat_thread(struct thread_info *thread)
+ {
+-	return is_a32_compat_thread(thread);
++	return is_a32_compat_thread(thread) || is_ilp32_compat_thread(thread);
+ }
+ 
+ 
+diff --git a/arch/arm64/include/asm/thread_info.h b/arch/arm64/include/asm/thread_info.h
+index dd046c5..22a07d1 100644
+--- a/arch/arm64/include/asm/thread_info.h
++++ b/arch/arm64/include/asm/thread_info.h
+@@ -113,6 +113,7 @@ static inline struct thread_info *current_thread_info(void)
+ #define TIF_RESTORE_SIGMASK	20
+ #define TIF_SINGLESTEP		21
+ #define TIF_32BIT		22	/* AARCH32 process */
++#define TIF_32BIT_AARCH64	23	/* 32 bit process on AArch64(ILP32) */
+ 
+ #define _TIF_SIGPENDING		(1 << TIF_SIGPENDING)
+ #define _TIF_NEED_RESCHED	(1 << TIF_NEED_RESCHED)
+@@ -124,6 +125,7 @@ static inline struct thread_info *current_thread_info(void)
+ #define _TIF_SYSCALL_TRACEPOINT	(1 << TIF_SYSCALL_TRACEPOINT)
+ #define _TIF_SECCOMP		(1 << TIF_SECCOMP)
+ #define _TIF_32BIT		(1 << TIF_32BIT)
++#define _TIF_32BIT_AARCH64	(1 << TIF_32BIT_AARCH64)
+ 
+ #define _TIF_WORK_MASK		(_TIF_NEED_RESCHED | _TIF_SIGPENDING | \
+ 				 _TIF_NOTIFY_RESUME | _TIF_FOREIGN_FPSTATE)
+-- 
+2.5.0
+
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0010-arm64-rename-COMPAT-to-AARCH32_EL0-in-Kconfig.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0010-arm64-rename-COMPAT-to-AARCH32_EL0-in-Kconfig.patch
deleted file mode 100644
index d0e7d96..0000000
--- a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0010-arm64-rename-COMPAT-to-AARCH32_EL0-in-Kconfig.patch
+++ /dev/null
@@ -1,423 +0,0 @@
-From 2c4a2897b40dd271a0aaecf2634a1e80dfab90bb Mon Sep 17 00:00:00 2001
-From: Andrew Pinski <apinski@cavium.com>
-Date: Tue, 24 May 2016 03:04:39 +0300
-Subject: [PATCH 10/24] arm64: rename COMPAT to AARCH32_EL0 in Kconfig
-
-In this patchset  ILP32 ABI support is added. Additionally to AARCH32,
-which is binary-compatible with ARM, ILP32 is (mostly) ABI-compatible.
-
->From now, AARCH32_EL0 (former COMPAT) config option means the support of
-AARCH32 userspace, ARM64_ILP32 - support of ILP32 ABI (see next patches),
-and COMPAT indicates that one of them, or both, is enabled.
-
-Where needed, CONFIG_COMPAT is changed over to use CONFIG_AARCH32_EL0 instead
-
-Reviewed-by: David Daney <ddaney@caviumnetworks.com>
-Signed-off-by: Andrew Pinski <Andrew.Pinski@caviumnetworks.com>
-Signed-off-by: Philipp Tomsich <philipp.tomsich@theobroma-systems.com>
-Signed-off-by: Christoph Muellner <christoph.muellner@theobroma-systems.com>
-Signed-off-by: Bamvor Jian Zhang <bamvor.zhangjian@linaro.org>
-Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
----
- arch/arm64/Kconfig                   | 9 +++++++--
- arch/arm64/include/asm/fpsimd.h      | 2 +-
- arch/arm64/include/asm/hwcap.h       | 4 ++--
- arch/arm64/include/asm/processor.h   | 6 +++---
- arch/arm64/include/asm/ptrace.h      | 2 +-
- arch/arm64/include/asm/seccomp.h     | 2 +-
- arch/arm64/include/asm/signal32.h    | 6 ++++--
- arch/arm64/include/asm/unistd.h      | 2 +-
- arch/arm64/kernel/Makefile           | 2 +-
- arch/arm64/kernel/asm-offsets.c      | 2 +-
- arch/arm64/kernel/cpufeature.c       | 8 ++++----
- arch/arm64/kernel/cpuinfo.c          | 4 ++--
- arch/arm64/kernel/entry.S            | 6 +++---
- arch/arm64/kernel/head.S             | 2 +-
- arch/arm64/kernel/ptrace.c           | 8 ++++----
- arch/arm64/kernel/traps.c            | 2 +-
- arch/arm64/kernel/vdso.c             | 4 ++--
- drivers/clocksource/arm_arch_timer.c | 2 +-
- 18 files changed, 40 insertions(+), 33 deletions(-)
-
-diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
-index cdf6971..ef8bddf 100644
---- a/arch/arm64/Kconfig
-+++ b/arch/arm64/Kconfig
-@@ -342,7 +342,7 @@ config ARM64_ERRATUM_834220
- 
- config ARM64_ERRATUM_845719
- 	bool "Cortex-A53: 845719: a load might read incorrect data"
--	depends on COMPAT
-+	depends on AARCH32_EL0
- 	default y
- 	help
- 	  This option adds an alternative code sequence to work around ARM
-@@ -640,7 +640,7 @@ config FORCE_MAX_ZONEORDER
- 
- menuconfig ARMV8_DEPRECATED
- 	bool "Emulate deprecated/obsolete ARMv8 instructions"
--	depends on COMPAT
-+	depends on AARCH32_EL0
- 	help
- 	  Legacy software support may require certain instructions
- 	  that have been deprecated or obsoleted in the architecture.
-@@ -819,7 +819,12 @@ menu "Userspace binary formats"
- source "fs/Kconfig.binfmt"
- 
- config COMPAT
-+	bool
-+	depends on AARCH32_EL0
-+
-+config AARCH32_EL0
- 	bool "Kernel support for 32-bit EL0"
-+	def_bool y
- 	depends on ARM64_4K_PAGES || EXPERT
- 	select COMPAT_BINFMT_ELF
- 	select HAVE_UID16
-diff --git a/arch/arm64/include/asm/fpsimd.h b/arch/arm64/include/asm/fpsimd.h
-index 50f559f..63b19f1 100644
---- a/arch/arm64/include/asm/fpsimd.h
-+++ b/arch/arm64/include/asm/fpsimd.h
-@@ -52,7 +52,7 @@ struct fpsimd_partial_state {
- };
- 
- 
--#if defined(__KERNEL__) && defined(CONFIG_COMPAT)
-+#if defined(__KERNEL__) && defined(CONFIG_AARCH32_EL0)
- /* Masks for extracting the FPSR and FPCR from the FPSCR */
- #define VFP_FPSCR_STAT_MASK	0xf800009f
- #define VFP_FPSCR_CTRL_MASK	0x07f79f00
-diff --git a/arch/arm64/include/asm/hwcap.h b/arch/arm64/include/asm/hwcap.h
-index 400b80b..2c7fc5d 100644
---- a/arch/arm64/include/asm/hwcap.h
-+++ b/arch/arm64/include/asm/hwcap.h
-@@ -46,7 +46,7 @@
-  */
- #define ELF_HWCAP		(elf_hwcap)
- 
--#ifdef CONFIG_COMPAT
-+#ifdef CONFIG_AARCH32_EL0
- #define COMPAT_ELF_HWCAP	(compat_elf_hwcap)
- #define COMPAT_ELF_HWCAP2	(compat_elf_hwcap2)
- extern unsigned int compat_elf_hwcap, compat_elf_hwcap2;
-@@ -54,7 +54,7 @@ extern unsigned int compat_elf_hwcap, compat_elf_hwcap2;
- 
- enum {
- 	CAP_HWCAP = 1,
--#ifdef CONFIG_COMPAT
-+#ifdef CONFIG_AARCH32_EL0
- 	CAP_COMPAT_HWCAP,
- 	CAP_COMPAT_HWCAP2,
- #endif
-diff --git a/arch/arm64/include/asm/processor.h b/arch/arm64/include/asm/processor.h
-index 5bb1d76..ba48561 100644
---- a/arch/arm64/include/asm/processor.h
-+++ b/arch/arm64/include/asm/processor.h
-@@ -81,7 +81,7 @@ struct cpu_context {
- struct thread_struct {
- 	struct cpu_context	cpu_context;	/* cpu context */
- 	unsigned long		tp_value;	/* TLS register */
--#ifdef CONFIG_COMPAT
-+#ifdef CONFIG_AARCH32_EL0
- 	unsigned long		tp2_value;
- #endif
- 	struct fpsimd_state	fpsimd_state;
-@@ -90,7 +90,7 @@ struct thread_struct {
- 	struct debug_info	debug;		/* debugging */
- };
- 
--#ifdef CONFIG_COMPAT
-+#ifdef CONFIG_AARCH32_EL0
- #define task_user_tls(t)						\
- ({									\
- 	unsigned long *__tls;						\
-@@ -121,7 +121,7 @@ static inline void start_thread(struct pt_regs *regs, unsigned long pc,
- 	regs->sp = sp;
- }
- 
--#ifdef CONFIG_COMPAT
-+#ifdef CONFIG_AARCH32_EL0
- static inline void compat_start_thread(struct pt_regs *regs, unsigned long pc,
- 				       unsigned long sp)
- {
-diff --git a/arch/arm64/include/asm/ptrace.h b/arch/arm64/include/asm/ptrace.h
-index e9e5467..95eff51 100644
---- a/arch/arm64/include/asm/ptrace.h
-+++ b/arch/arm64/include/asm/ptrace.h
-@@ -120,7 +120,7 @@ struct pt_regs {
- 
- #define arch_has_single_step()	(1)
- 
--#ifdef CONFIG_COMPAT
-+#ifdef CONFIG_AARCH32_EL0
- #define compat_thumb_mode(regs) \
- 	(((regs)->pstate & COMPAT_PSR_T_BIT))
- #else
-diff --git a/arch/arm64/include/asm/seccomp.h b/arch/arm64/include/asm/seccomp.h
-index c76fac9..00ef0bf 100644
---- a/arch/arm64/include/asm/seccomp.h
-+++ b/arch/arm64/include/asm/seccomp.h
-@@ -13,7 +13,7 @@
- 
- #include <asm/unistd.h>
- 
--#ifdef CONFIG_COMPAT
-+#ifdef CONFIG_AARCH32_EL0
- #define __NR_seccomp_read_32		__NR_compat_read
- #define __NR_seccomp_write_32		__NR_compat_write
- #define __NR_seccomp_exit_32		__NR_compat_exit
-diff --git a/arch/arm64/include/asm/signal32.h b/arch/arm64/include/asm/signal32.h
-index eeaa975..e68fcce 100644
---- a/arch/arm64/include/asm/signal32.h
-+++ b/arch/arm64/include/asm/signal32.h
-@@ -17,7 +17,9 @@
- #define __ASM_SIGNAL32_H
- 
- #ifdef __KERNEL__
--#ifdef CONFIG_COMPAT
-+
-+#ifdef CONFIG_AARCH32_EL0
-+
- #include <linux/compat.h>
- 
- #define AARCH32_KERN_SIGRET_CODE_OFFSET	0x500
-@@ -47,6 +49,6 @@ static inline int compat_setup_rt_frame(int usig, struct ksignal *ksig, sigset_t
- static inline void compat_setup_restart_syscall(struct pt_regs *regs)
- {
- }
--#endif /* CONFIG_COMPAT */
-+#endif /* CONFIG_AARCH32_EL0 */
- #endif /* __KERNEL__ */
- #endif /* __ASM_SIGNAL32_H */
-diff --git a/arch/arm64/include/asm/unistd.h b/arch/arm64/include/asm/unistd.h
-index 41e58fe..2971dea 100644
---- a/arch/arm64/include/asm/unistd.h
-+++ b/arch/arm64/include/asm/unistd.h
-@@ -13,7 +13,7 @@
-  * You should have received a copy of the GNU General Public License
-  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
-  */
--#ifdef CONFIG_COMPAT
-+#ifdef CONFIG_AARCH32_EL0
- #define __ARCH_WANT_COMPAT_SYS_GETDENTS64
- #define __ARCH_WANT_COMPAT_STAT64
- #define __ARCH_WANT_SYS_GETHOSTNAME
-diff --git a/arch/arm64/kernel/Makefile b/arch/arm64/kernel/Makefile
-index c4e2f70..4c11256 100644
---- a/arch/arm64/kernel/Makefile
-+++ b/arch/arm64/kernel/Makefile
-@@ -25,7 +25,7 @@ OBJCOPYFLAGS := --prefix-symbols=__efistub_
- $(obj)/%.stub.o: $(obj)/%.o FORCE
- 	$(call if_changed,objcopy)
- 
--arm64-obj-$(CONFIG_COMPAT)		+= sys32.o kuser32.o signal32.o 	\
-+arm64-obj-$(CONFIG_AARCH32_EL0)		+= sys32.o kuser32.o signal32.o 	\
- 					   sys_compat.o entry32.o		\
- 					   ../../arm/kernel/opcodes.o
- arm64-obj-$(CONFIG_FUNCTION_TRACER)	+= ftrace.o entry-ftrace.o
-diff --git a/arch/arm64/kernel/asm-offsets.c b/arch/arm64/kernel/asm-offsets.c
-index 25de8b2..0d4f1e7 100644
---- a/arch/arm64/kernel/asm-offsets.c
-+++ b/arch/arm64/kernel/asm-offsets.c
-@@ -51,7 +51,7 @@ int main(void)
-   DEFINE(S_X7,			offsetof(struct pt_regs, regs[7]));
-   DEFINE(S_LR,			offsetof(struct pt_regs, regs[30]));
-   DEFINE(S_SP,			offsetof(struct pt_regs, sp));
--#ifdef CONFIG_COMPAT
-+#ifdef CONFIG_AARCH32_EL0
-   DEFINE(S_COMPAT_SP,		offsetof(struct pt_regs, compat_sp));
- #endif
-   DEFINE(S_PSTATE,		offsetof(struct pt_regs, pstate));
-diff --git a/arch/arm64/kernel/cpufeature.c b/arch/arm64/kernel/cpufeature.c
-index aaf16c2..21259d9 100644
---- a/arch/arm64/kernel/cpufeature.c
-+++ b/arch/arm64/kernel/cpufeature.c
-@@ -30,7 +30,7 @@
- unsigned long elf_hwcap __read_mostly;
- EXPORT_SYMBOL_GPL(elf_hwcap);
- 
--#ifdef CONFIG_COMPAT
-+#ifdef CONFIG_AARCH32_EL0
- #define COMPAT_ELF_HWCAP_DEFAULT	\
- 				(COMPAT_HWCAP_HALF|COMPAT_HWCAP_THUMB|\
- 				 COMPAT_HWCAP_FAST_MULT|COMPAT_HWCAP_EDSP|\
-@@ -691,7 +691,7 @@ static const struct arm64_cpu_capabilities arm64_hwcaps[] = {
- 	HWCAP_CAP(SYS_ID_AA64ISAR0_EL1, ID_AA64ISAR0_ATOMICS_SHIFT, 2, CAP_HWCAP, HWCAP_ATOMICS),
- 	HWCAP_CAP(SYS_ID_AA64PFR0_EL1, ID_AA64PFR0_FP_SHIFT, 0, CAP_HWCAP, HWCAP_FP),
- 	HWCAP_CAP(SYS_ID_AA64PFR0_EL1, ID_AA64PFR0_ASIMD_SHIFT, 0, CAP_HWCAP, HWCAP_ASIMD),
--#ifdef CONFIG_COMPAT
-+#ifdef CONFIG_AARCH32_EL0
- 	HWCAP_CAP(SYS_ID_ISAR5_EL1, ID_ISAR5_AES_SHIFT, 2, CAP_COMPAT_HWCAP2, COMPAT_HWCAP2_PMULL),
- 	HWCAP_CAP(SYS_ID_ISAR5_EL1, ID_ISAR5_AES_SHIFT, 1, CAP_COMPAT_HWCAP2, COMPAT_HWCAP2_AES),
- 	HWCAP_CAP(SYS_ID_ISAR5_EL1, ID_ISAR5_SHA1_SHIFT, 1, CAP_COMPAT_HWCAP2, COMPAT_HWCAP2_SHA1),
-@@ -707,7 +707,7 @@ static void cap_set_hwcap(const struct arm64_cpu_capabilities *cap)
- 	case CAP_HWCAP:
- 		elf_hwcap |= cap->hwcap;
- 		break;
--#ifdef CONFIG_COMPAT
-+#ifdef CONFIG_AARCH32_EL0
- 	case CAP_COMPAT_HWCAP:
- 		compat_elf_hwcap |= (u32)cap->hwcap;
- 		break;
-@@ -730,7 +730,7 @@ static bool __maybe_unused cpus_have_hwcap(const struct arm64_cpu_capabilities *
- 	case CAP_HWCAP:
- 		rc = (elf_hwcap & cap->hwcap) != 0;
- 		break;
--#ifdef CONFIG_COMPAT
-+#ifdef CONFIG_AARCH32_EL0
- 	case CAP_COMPAT_HWCAP:
- 		rc = (compat_elf_hwcap & (u32)cap->hwcap) != 0;
- 		break;
-diff --git a/arch/arm64/kernel/cpuinfo.c b/arch/arm64/kernel/cpuinfo.c
-index 212ae63..4a4602d 100644
---- a/arch/arm64/kernel/cpuinfo.c
-+++ b/arch/arm64/kernel/cpuinfo.c
-@@ -125,7 +125,7 @@ static int c_show(struct seq_file *m, void *v)
- 		 */
- 		seq_puts(m, "Features\t:");
- 		if (personality(current->personality) == PER_LINUX32) {
--#ifdef CONFIG_COMPAT
-+#ifdef CONFIG_AARCH32_EL0
- 			for (j = 0; compat_hwcap_str[j]; j++)
- 				if (compat_elf_hwcap & (1 << j))
- 					seq_printf(m, " %s", compat_hwcap_str[j]);
-@@ -133,7 +133,7 @@ static int c_show(struct seq_file *m, void *v)
- 			for (j = 0; compat_hwcap2_str[j]; j++)
- 				if (compat_elf_hwcap2 & (1 << j))
- 					seq_printf(m, " %s", compat_hwcap2_str[j]);
--#endif /* CONFIG_COMPAT */
-+#endif /* CONFIG_AARCH32_EL0 */
- 		} else {
- 			for (j = 0; hwcap_str[j]; j++)
- 				if (elf_hwcap & (1 << j))
-diff --git a/arch/arm64/kernel/entry.S b/arch/arm64/kernel/entry.S
-index 7ed3d75..5eb1bb7 100644
---- a/arch/arm64/kernel/entry.S
-+++ b/arch/arm64/kernel/entry.S
-@@ -212,7 +212,7 @@ ENTRY(vectors)
- 	ventry	el0_fiq_invalid			// FIQ 64-bit EL0
- 	ventry	el0_error_invalid		// Error 64-bit EL0
- 
--#ifdef CONFIG_COMPAT
-+#ifdef CONFIG_AARCH32_EL0
- 	ventry	el0_sync_compat			// Synchronous 32-bit EL0
- 	ventry	el0_irq_compat			// IRQ 32-bit EL0
- 	ventry	el0_fiq_invalid_compat		// FIQ 32-bit EL0
-@@ -252,7 +252,7 @@ el0_error_invalid:
- 	inv_entry 0, BAD_ERROR
- ENDPROC(el0_error_invalid)
- 
--#ifdef CONFIG_COMPAT
-+#ifdef CONFIG_AARCH32_EL0
- el0_fiq_invalid_compat:
- 	inv_entry 0, BAD_FIQ, 32
- ENDPROC(el0_fiq_invalid_compat)
-@@ -414,7 +414,7 @@ el0_sync:
- 	b.ge	el0_dbg
- 	b	el0_inv
- 
--#ifdef CONFIG_COMPAT
-+#ifdef CONFIG_AARCH32_EL0
- 	.align	6
- el0_sync_compat:
- 	kernel_entry 0, 32
-diff --git a/arch/arm64/kernel/head.S b/arch/arm64/kernel/head.S
-index b685257..cae4969 100644
---- a/arch/arm64/kernel/head.S
-+++ b/arch/arm64/kernel/head.S
-@@ -507,7 +507,7 @@ CPU_LE(	movk	x0, #0x30d0, lsl #16	)	// Clear EE and E0E on LE systems
- 	mov	x0, #0x33ff
- 	msr	cptr_el2, x0			// Disable copro. traps to EL2
- 
--#ifdef CONFIG_COMPAT
-+#ifdef CONFIG_AARCH32_EL0
- 	msr	hstr_el2, xzr			// Disable CP15 traps to EL2
- #endif
- 
-diff --git a/arch/arm64/kernel/ptrace.c b/arch/arm64/kernel/ptrace.c
-index ff7f132..16ed9fd 100644
---- a/arch/arm64/kernel/ptrace.c
-+++ b/arch/arm64/kernel/ptrace.c
-@@ -82,7 +82,7 @@ static void ptrace_hbptriggered(struct perf_event *bp,
- 		.si_addr	= (void __user *)(bkpt->trigger),
- 	};
- 
--#ifdef CONFIG_COMPAT
-+#ifdef CONFIG_AARCH32_EL0
- 	int i;
- 
- 	if (!is_compat_task())
-@@ -657,7 +657,7 @@ static const struct user_regset_view user_aarch64_view = {
- 	.regsets = aarch64_regsets, .n = ARRAY_SIZE(aarch64_regsets)
- };
- 
--#ifdef CONFIG_COMPAT
-+#ifdef CONFIG_AARCH32_EL0
- #include <linux/compat.h>
- 
- enum compat_regset {
-@@ -1192,11 +1192,11 @@ long compat_arch_ptrace(struct task_struct *child, compat_long_t request,
- 
- 	return ret;
- }
--#endif /* CONFIG_COMPAT */
-+#endif /* CONFIG_AARCH32_EL0 */
- 
- const struct user_regset_view *task_user_regset_view(struct task_struct *task)
- {
--#ifdef CONFIG_COMPAT
-+#ifdef CONFIG_AARCH32_EL0
- 	/*
- 	 * Core dumping of 32-bit tasks or compat ptrace requests must use the
- 	 * user_aarch32_view compatible with arm32. Native ptrace requests on
-diff --git a/arch/arm64/kernel/traps.c b/arch/arm64/kernel/traps.c
-index e9b9b53..b50fced 100644
---- a/arch/arm64/kernel/traps.c
-+++ b/arch/arm64/kernel/traps.c
-@@ -368,7 +368,7 @@ long compat_arm_syscall(struct pt_regs *regs);
- 
- asmlinkage long do_ni_syscall(struct pt_regs *regs)
- {
--#ifdef CONFIG_COMPAT
-+#ifdef CONFIG_AARCH32_EL0
- 	long ret;
- 	if (is_compat_task()) {
- 		ret = compat_arm_syscall(regs);
-diff --git a/arch/arm64/kernel/vdso.c b/arch/arm64/kernel/vdso.c
-index 97bc68f..26352a6 100644
---- a/arch/arm64/kernel/vdso.c
-+++ b/arch/arm64/kernel/vdso.c
-@@ -49,7 +49,7 @@ static union {
- } vdso_data_store __page_aligned_data;
- struct vdso_data *vdso_data = &vdso_data_store.data;
- 
--#ifdef CONFIG_COMPAT
-+#ifdef CONFIG_AARCH32_EL0
- /*
-  * Create and map the vectors page for AArch32 tasks.
-  */
-@@ -107,7 +107,7 @@ int aarch32_setup_vectors_page(struct linux_binprm *bprm, int uses_interp)
- 
- 	return PTR_ERR_OR_ZERO(ret);
- }
--#endif /* CONFIG_COMPAT */
-+#endif /* CONFIG_AARCH32_EL0 */
- 
- static struct vm_special_mapping vdso_spec[2];
- 
-diff --git a/drivers/clocksource/arm_arch_timer.c b/drivers/clocksource/arm_arch_timer.c
-index c64d543..35461e1 100644
---- a/drivers/clocksource/arm_arch_timer.c
-+++ b/drivers/clocksource/arm_arch_timer.c
-@@ -303,7 +303,7 @@ static void arch_timer_evtstrm_enable(int divider)
- 			| ARCH_TIMER_VIRT_EVT_EN;
- 	arch_timer_set_cntkctl(cntkctl);
- 	elf_hwcap |= HWCAP_EVTSTRM;
--#ifdef CONFIG_COMPAT
-+#ifdef CONFIG_AARCH32_EL0
- 	compat_elf_hwcap |= COMPAT_HWCAP_EVTSTRM;
- #endif
- }
--- 
-1.9.1
-
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0011-arm64-introduce-binfmt_elf32.c.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0011-arm64-introduce-binfmt_elf32.c.patch
new file mode 100644
index 0000000..e4ebdac
--- /dev/null
+++ b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0011-arm64-introduce-binfmt_elf32.c.patch
@@ -0,0 +1,130 @@
+From 4487e7e9178765a5b7906db77511fed9a7ca717d Mon Sep 17 00:00:00 2001
+From: Yury Norov <ynorov@caviumnetworks.com>
+Date: Tue, 24 May 2016 03:04:44 +0300
+Subject: [PATCH 11/20] arm64: introduce binfmt_elf32.c
+
+As we support more than one compat formats, it looks more reasonable
+to not use fs/compat_binfmt.c. Custom binfmt_elf32.c allows to move aarch32
+specific definitions there and make code more maintainable and readable.
+
+Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
+---
+ arch/arm64/Kconfig               |  1 -
+ arch/arm64/include/asm/elf.h     | 20 ++------------------
+ arch/arm64/include/asm/hwcap.h   |  2 --
+ arch/arm64/kernel/Makefile       |  2 +-
+ arch/arm64/kernel/binfmt_elf32.c | 28 ++++++++++++++++++++++++++++
+ 5 files changed, 31 insertions(+), 22 deletions(-)
+ create mode 100644 arch/arm64/kernel/binfmt_elf32.c
+
+diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
+index 32ef499..7b3bf7b 100644
+--- a/arch/arm64/Kconfig
++++ b/arch/arm64/Kconfig
+@@ -841,7 +841,6 @@ config AARCH32_EL0
+ 	def_bool y
+ 	depends on ARM64_4K_PAGES || EXPERT
+ 	select COMPAT
+-	select COMPAT_BINFMT_ELF
+ 	select HAVE_UID16
+ 	select OLD_SIGSUSPEND3
+ 	select COMPAT_OLD_SIGACTION
+diff --git a/arch/arm64/include/asm/elf.h b/arch/arm64/include/asm/elf.h
+index 61b844c..154f6c9 100644
+--- a/arch/arm64/include/asm/elf.h
++++ b/arch/arm64/include/asm/elf.h
+@@ -170,29 +170,13 @@ extern int arch_setup_additional_pages(struct linux_binprm *bprm,
+ 
+ #define COMPAT_ELF_ET_DYN_BASE		(2 * TASK_SIZE_32 / 3)
+ 
++#ifdef CONFIG_AARCH32_EL0
+ /* AArch32 registers. */
+ #define COMPAT_ELF_NGREG		18
+ typedef unsigned int			compat_elf_greg_t;
+ typedef compat_elf_greg_t		compat_elf_gregset_t[COMPAT_ELF_NGREG];
+ 
+-/* AArch32 EABI. */
+-#define EF_ARM_EABI_MASK		0xff000000
+-#define compat_elf_check_arch(x)	(((x)->e_machine == EM_ARM) && \
+-					 ((x)->e_flags & EF_ARM_EABI_MASK))
+-
+-#define compat_start_thread		compat_start_thread
+-#define COMPAT_SET_PERSONALITY(ex)		\
+-do {						\
+-	clear_thread_flag(TIF_32BIT_AARCH64);	\
+-	set_thread_flag(TIF_32BIT);		\
+-} while (0)
+-
+-#define COMPAT_ARCH_DLINFO
+-extern int aarch32_setup_vectors_page(struct linux_binprm *bprm,
+-				      int uses_interp);
+-#define compat_arch_setup_additional_pages \
+-					aarch32_setup_vectors_page
+-
++#endif /* CONFIG_AARCH32_EL0 */
+ #endif /* CONFIG_COMPAT */
+ 
+ #endif
+diff --git a/arch/arm64/include/asm/hwcap.h b/arch/arm64/include/asm/hwcap.h
+index 2c7fc5d..99dfd92 100644
+--- a/arch/arm64/include/asm/hwcap.h
++++ b/arch/arm64/include/asm/hwcap.h
+@@ -47,8 +47,6 @@
+ #define ELF_HWCAP		(elf_hwcap)
+ 
+ #ifdef CONFIG_AARCH32_EL0
+-#define COMPAT_ELF_HWCAP	(compat_elf_hwcap)
+-#define COMPAT_ELF_HWCAP2	(compat_elf_hwcap2)
+ extern unsigned int compat_elf_hwcap, compat_elf_hwcap2;
+ #endif
+ 
+diff --git a/arch/arm64/kernel/Makefile b/arch/arm64/kernel/Makefile
+index 3b5b293..771bb97 100644
+--- a/arch/arm64/kernel/Makefile
++++ b/arch/arm64/kernel/Makefile
+@@ -26,7 +26,7 @@ $(obj)/%.stub.o: $(obj)/%.o FORCE
+ 	$(call if_changed,objcopy)
+ 
+ arm64-obj-$(CONFIG_AARCH32_EL0)		+= sys32.o kuser32.o signal32.o 	\
+-					   sys_compat.o entry32.o		\
++					   sys_compat.o entry32.o binfmt_elf32.o\
+ 					   ../../arm/kernel/opcodes.o
+ arm64-obj-$(CONFIG_FUNCTION_TRACER)	+= ftrace.o entry-ftrace.o
+ arm64-obj-$(CONFIG_MODULES)		+= arm64ksyms.o module.o
+diff --git a/arch/arm64/kernel/binfmt_elf32.c b/arch/arm64/kernel/binfmt_elf32.c
+new file mode 100644
+index 0000000..400d10e
+--- /dev/null
++++ b/arch/arm64/kernel/binfmt_elf32.c
+@@ -0,0 +1,28 @@
++/*
++ * Support for AArch32 Linux ELF binaries.
++ */
++
++/* AArch32 EABI. */
++#define EF_ARM_EABI_MASK		0xff000000
++
++#define compat_start_thread		compat_start_thread
++#define COMPAT_SET_PERSONALITY(ex)					\
++({									\
++	clear_thread_flag(TIF_32BIT_AARCH64);				\
++	set_thread_flag(TIF_32BIT);					\
++ })
++
++#define COMPAT_ARCH_DLINFO
++#define COMPAT_ELF_HWCAP		(compat_elf_hwcap)
++#define COMPAT_ELF_HWCAP2		(compat_elf_hwcap2)
++
++#define compat_arch_setup_additional_pages \
++					aarch32_setup_vectors_page
++struct linux_binprm;
++extern int aarch32_setup_vectors_page(struct linux_binprm *bprm,
++				      int uses_interp);
++
++#define compat_elf_check_arch(x)	(((x)->e_machine == EM_ARM) && \
++					 ((x)->e_flags & EF_ARM_EABI_MASK))
++
++#include "../../../fs/compat_binfmt_elf.c"
+-- 
+2.5.0
+
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0011-arm64-uapi-set-__BITS_PER_LONG-correctly-for-ILP32-a.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0011-arm64-uapi-set-__BITS_PER_LONG-correctly-for-ILP32-a.patch
deleted file mode 100644
index 1009e05..0000000
--- a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0011-arm64-uapi-set-__BITS_PER_LONG-correctly-for-ILP32-a.patch
+++ /dev/null
@@ -1,42 +0,0 @@
-From dfa0f95bd124a0a32c4dc92a5fa7b86a217756ad Mon Sep 17 00:00:00 2001
-From: Andrew Pinski <apinski@cavium.com>
-Date: Tue, 24 May 2016 03:04:40 +0300
-Subject: [PATCH 11/24] arm64:uapi: set __BITS_PER_LONG correctly for ILP32 and
- LP64
-
-Define __BITS_PER_LONG depending on the ABI used (i.e. check whether
-__ILP32__ or __LP64__ is defined).  This is necessary for glibc to
-determine the appropriate type definitions for the system call interface.
-
-Signed-off-by: Andrew Pinski <apinski@cavium.com>
-Signed-off-by: Philipp Tomsich <philipp.tomsich@theobroma-systems.com>
-Signed-off-by: Christoph Muellner <christoph.muellner@theobroma-systems.com>
-Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
-Reviewed-by: David Daney <ddaney@caviumnetworks.com>
----
- arch/arm64/include/uapi/asm/bitsperlong.h | 9 ++++++++-
- 1 file changed, 8 insertions(+), 1 deletion(-)
-
-diff --git a/arch/arm64/include/uapi/asm/bitsperlong.h b/arch/arm64/include/uapi/asm/bitsperlong.h
-index fce9c29..4265243 100644
---- a/arch/arm64/include/uapi/asm/bitsperlong.h
-+++ b/arch/arm64/include/uapi/asm/bitsperlong.h
-@@ -16,7 +16,14 @@
- #ifndef __ASM_BITSPERLONG_H
- #define __ASM_BITSPERLONG_H
- 
--#define __BITS_PER_LONG 64
-+#if defined(__LP64__)
-+/* Assuming __LP64__ will be defined for native ELF64's and not for ILP32. */
-+#  define __BITS_PER_LONG 64
-+#elif defined(__ILP32__)
-+#  define __BITS_PER_LONG 32
-+#else
-+#  error "Neither LP64 nor ILP32: unsupported ABI in asm/bitsperlong.h"
-+#endif
- 
- #include <asm-generic/bitsperlong.h>
- 
--- 
-1.9.1
-
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0012-arm64-ilp32-introduce-binfmt_ilp32.c.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0012-arm64-ilp32-introduce-binfmt_ilp32.c.patch
new file mode 100644
index 0000000..1338f2b
--- /dev/null
+++ b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0012-arm64-ilp32-introduce-binfmt_ilp32.c.patch
@@ -0,0 +1,135 @@
+From d09855f301bfc71446a55f5598c69f40508defc6 Mon Sep 17 00:00:00 2001
+From: Yury Norov <ynorov@caviumnetworks.com>
+Date: Tue, 24 May 2016 03:04:45 +0300
+Subject: [PATCH 12/20] arm64: ilp32: introduce binfmt_ilp32.c
+
+Like binfmt_elf32.c, binfmt_ilp32.c is needed to handle ILP32 binaries
+
+Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
+Signed-off-by: Bamvor Jian Zhang <bamvor.zhangjian@linaro.org>
+---
+ arch/arm64/kernel/Makefile       |  1 +
+ arch/arm64/kernel/binfmt_ilp32.c | 99 ++++++++++++++++++++++++++++++++++++++++
+ 2 files changed, 100 insertions(+)
+ create mode 100644 arch/arm64/kernel/binfmt_ilp32.c
+
+diff --git a/arch/arm64/kernel/Makefile b/arch/arm64/kernel/Makefile
+index 771bb97..35a7a03 100644
+--- a/arch/arm64/kernel/Makefile
++++ b/arch/arm64/kernel/Makefile
+@@ -28,6 +28,7 @@ $(obj)/%.stub.o: $(obj)/%.o FORCE
+ arm64-obj-$(CONFIG_AARCH32_EL0)		+= sys32.o kuser32.o signal32.o 	\
+ 					   sys_compat.o entry32.o binfmt_elf32.o\
+ 					   ../../arm/kernel/opcodes.o
++arm64-obj-$(CONFIG_ARM64_ILP32)		+= binfmt_ilp32.o
+ arm64-obj-$(CONFIG_FUNCTION_TRACER)	+= ftrace.o entry-ftrace.o
+ arm64-obj-$(CONFIG_MODULES)		+= arm64ksyms.o module.o
+ arm64-obj-$(CONFIG_PERF_EVENTS)		+= perf_regs.o perf_callchain.o
+diff --git a/arch/arm64/kernel/binfmt_ilp32.c b/arch/arm64/kernel/binfmt_ilp32.c
+new file mode 100644
+index 0000000..70af506
+--- /dev/null
++++ b/arch/arm64/kernel/binfmt_ilp32.c
+@@ -0,0 +1,99 @@
++/*
++ * Support for ILP32 Linux/aarch64 ELF binaries.
++ */
++#undef CONFIG_AARCH32_EL0
++#define compat_elf_gregset_t	elf_gregset_t
++
++#include <linux/elfcore-compat.h>
++#include <linux/time.h>
++
++#undef	ELF_CLASS
++#define ELF_CLASS	ELFCLASS32
++
++#undef	elfhdr
++#undef	elf_phdr
++#undef	elf_shdr
++#undef	elf_note
++#undef	elf_addr_t
++#define elfhdr		elf32_hdr
++#define elf_phdr	elf32_phdr
++#define elf_shdr	elf32_shdr
++#define elf_note	elf32_note
++#define elf_addr_t	Elf32_Addr
++
++/*
++ * Some data types as stored in coredump.
++ */
++#define user_long_t		compat_long_t
++#define user_siginfo_t		compat_siginfo_t
++#define copy_siginfo_to_user	copy_siginfo_to_user32
++
++/*
++ * The machine-dependent core note format types are defined in elfcore-compat.h,
++ * which requires asm/elf.h to define compat_elf_gregset_t et al.
++ */
++#define elf_prstatus	compat_elf_prstatus
++#define elf_prpsinfo	compat_elf_prpsinfo
++
++/*
++ * Compat version of cputime_to_compat_timeval, perhaps this
++ * should be an inline in <linux/compat.h>.
++ */
++static void cputime_to_compat_timeval(const cputime_t cputime,
++                                     struct compat_timeval *value)
++{
++       struct timeval tv;
++
++       cputime_to_timeval(cputime, &tv);
++       value->tv_sec = tv.tv_sec;
++       value->tv_usec = tv.tv_usec;
++}
++
++#undef cputime_to_timeval
++#define cputime_to_timeval cputime_to_compat_timeval
++
++
++/* AARCH64 ILP32 EABI. */
++#undef elf_check_arch
++#define elf_check_arch(x)		(((x)->e_machine == EM_AARCH64)	\
++					&& (x)->e_ident[EI_CLASS] == ELFCLASS32)
++
++#undef SET_PERSONALITY
++#define SET_PERSONALITY(ex)						\
++do {									\
++	set_thread_flag(TIF_32BIT_AARCH64);				\
++	clear_thread_flag(TIF_32BIT);					\
++} while (0)
++
++#undef ARCH_DLINFO
++#define ARCH_DLINFO							\
++do {									\
++	NEW_AUX_ENT(AT_SYSINFO_EHDR,					\
++		    (elf_addr_t)(long)current->mm->context.vdso);	\
++} while (0)
++
++#undef ELF_PLATFORM
++#ifdef __AARCH64EB__
++#define ELF_PLATFORM		("aarch64_be:ilp32")
++#else
++#define ELF_PLATFORM		("aarch64:ilp32")
++#endif
++
++#undef ELF_ET_DYN_BASE
++#define ELF_ET_DYN_BASE COMPAT_ELF_ET_DYN_BASE
++
++#undef ELF_HWCAP
++#undef ELF_HWCAP2
++#define ELF_HWCAP			((u32) elf_hwcap)
++#define ELF_HWCAP2			((u32) (elf_hwcap >> 32))
++
++/*
++ * Rename a few of the symbols that binfmt_elf.c will define.
++ * These are all local so the names don't really matter, but it
++ * might make some debugging less confusing not to duplicate them.
++ */
++#define elf_format		compat_elf_format
++#define init_elf_binfmt		init_compat_elf_binfmt
++#define exit_elf_binfmt		exit_compat_elf_binfmt
++
++#include "../../../fs/binfmt_elf.c"
+-- 
+2.5.0
+
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0012-thread-move-thread-bits-accessors-to-separated-file.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0012-thread-move-thread-bits-accessors-to-separated-file.patch
deleted file mode 100644
index a022079..0000000
--- a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0012-thread-move-thread-bits-accessors-to-separated-file.patch
+++ /dev/null
@@ -1,145 +0,0 @@
-From 424bca6aab79eea983122b934b2c4165cc09a3d0 Mon Sep 17 00:00:00 2001
-From: Yury Norov <ynorov@caviumnetworks.com>
-Date: Tue, 24 May 2016 03:04:41 +0300
-Subject: [PATCH 12/24] thread: move thread bits accessors to separated file
-
-They may be accessed from low-level code, so isolating is a measure to
-avoid circular dependencies in header files.
-
-The exact reason for circular dependency is WARN_ON() macro added by Al
-Viro in patch [edd63a27] "set_restore_sigmask() is never called without
-SIGPENDING (and never should be)"
-
-Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
----
- include/linux/thread_bits.h | 55 +++++++++++++++++++++++++++++++++++++++++++++
- include/linux/thread_info.h | 44 +-----------------------------------
- 2 files changed, 56 insertions(+), 43 deletions(-)
- create mode 100644 include/linux/thread_bits.h
-
-diff --git a/include/linux/thread_bits.h b/include/linux/thread_bits.h
-new file mode 100644
-index 0000000..0d05d16
---- /dev/null
-+++ b/include/linux/thread_bits.h
-@@ -0,0 +1,55 @@
-+
-+/* thread_bits.h: common low-level thread bits accessors */
-+
-+#ifndef _LINUX_THREAD_BITS_H
-+#define _LINUX_THREAD_BITS_H
-+
-+#ifndef __ASSEMBLY__
-+
-+#include <linux/bitops.h>
-+#include <asm/thread_info.h>
-+
-+/*
-+ * flag set/clear/test wrappers
-+ * - pass TIF_xxxx constants to these functions
-+ */
-+
-+static inline void set_ti_thread_flag(struct thread_info *ti, int flag)
-+{
-+	set_bit(flag, (unsigned long *)&ti->flags);
-+}
-+
-+static inline void clear_ti_thread_flag(struct thread_info *ti, int flag)
-+{
-+	clear_bit(flag, (unsigned long *)&ti->flags);
-+}
-+
-+static inline int test_and_set_ti_thread_flag(struct thread_info *ti, int flag)
-+{
-+	return test_and_set_bit(flag, (unsigned long *)&ti->flags);
-+}
-+
-+static inline int test_and_clear_ti_thread_flag(struct thread_info *ti, int flag)
-+{
-+	return test_and_clear_bit(flag, (unsigned long *)&ti->flags);
-+}
-+
-+static inline int test_ti_thread_flag(struct thread_info *ti, int flag)
-+{
-+	return test_bit(flag, (unsigned long *)&ti->flags);
-+}
-+
-+#define set_thread_flag(flag) \
-+	set_ti_thread_flag(current_thread_info(), flag)
-+#define clear_thread_flag(flag) \
-+	clear_ti_thread_flag(current_thread_info(), flag)
-+#define test_and_set_thread_flag(flag) \
-+	test_and_set_ti_thread_flag(current_thread_info(), flag)
-+#define test_and_clear_thread_flag(flag) \
-+	test_and_clear_ti_thread_flag(current_thread_info(), flag)
-+#define test_thread_flag(flag) \
-+	test_ti_thread_flag(current_thread_info(), flag)
-+
-+#endif /* !__ASSEMBLY__ */
-+#endif /* _LINUX_THREAD_BITS_H */
-+
-diff --git a/include/linux/thread_info.h b/include/linux/thread_info.h
-index ff307b5..c905fec 100644
---- a/include/linux/thread_info.h
-+++ b/include/linux/thread_info.h
-@@ -50,8 +50,7 @@ struct restart_block {
- 
- extern long do_no_restart_syscall(struct restart_block *parm);
- 
--#include <linux/bitops.h>
--#include <asm/thread_info.h>
-+#include <linux/thread_bits.h>
- 
- #ifdef __KERNEL__
- 
-@@ -61,47 +60,6 @@ extern long do_no_restart_syscall(struct restart_block *parm);
- # define THREADINFO_GFP		(GFP_KERNEL | __GFP_NOTRACK)
- #endif
- 
--/*
-- * flag set/clear/test wrappers
-- * - pass TIF_xxxx constants to these functions
-- */
--
--static inline void set_ti_thread_flag(struct thread_info *ti, int flag)
--{
--	set_bit(flag, (unsigned long *)&ti->flags);
--}
--
--static inline void clear_ti_thread_flag(struct thread_info *ti, int flag)
--{
--	clear_bit(flag, (unsigned long *)&ti->flags);
--}
--
--static inline int test_and_set_ti_thread_flag(struct thread_info *ti, int flag)
--{
--	return test_and_set_bit(flag, (unsigned long *)&ti->flags);
--}
--
--static inline int test_and_clear_ti_thread_flag(struct thread_info *ti, int flag)
--{
--	return test_and_clear_bit(flag, (unsigned long *)&ti->flags);
--}
--
--static inline int test_ti_thread_flag(struct thread_info *ti, int flag)
--{
--	return test_bit(flag, (unsigned long *)&ti->flags);
--}
--
--#define set_thread_flag(flag) \
--	set_ti_thread_flag(current_thread_info(), flag)
--#define clear_thread_flag(flag) \
--	clear_ti_thread_flag(current_thread_info(), flag)
--#define test_and_set_thread_flag(flag) \
--	test_and_set_ti_thread_flag(current_thread_info(), flag)
--#define test_and_clear_thread_flag(flag) \
--	test_and_clear_ti_thread_flag(current_thread_info(), flag)
--#define test_thread_flag(flag) \
--	test_ti_thread_flag(current_thread_info(), flag)
--
- #define tif_need_resched() test_thread_flag(TIF_NEED_RESCHED)
- 
- #if defined TIF_RESTORE_SIGMASK && !defined HAVE_SET_RESTORE_SIGMASK
--- 
-1.9.1
-
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0013-arm64-ilp32-share-aarch32-syscall-handlers.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0013-arm64-ilp32-share-aarch32-syscall-handlers.patch
new file mode 100644
index 0000000..5952c71
--- /dev/null
+++ b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0013-arm64-ilp32-share-aarch32-syscall-handlers.patch
@@ -0,0 +1,233 @@
+From 50e55f08372866249a2f9cf4d9e11361501740b5 Mon Sep 17 00:00:00 2001
+From: Yury Norov <ynorov@caviumnetworks.com>
+Date: Fri, 17 Jun 2016 01:00:11 +0300
+Subject: [PATCH 13/20] arm64: ilp32: share aarch32 syscall handlers
+
+off_t is  passed in register pair just like in aarch32.
+In this patch corresponding aarch32 handlers are shared to
+ilp32 code.
+
+Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
+---
+ arch/arm64/kernel/Makefile         |   1 +
+ arch/arm64/kernel/entry32.S        |  80 ---------------------------
+ arch/arm64/kernel/entry32_common.S | 107 +++++++++++++++++++++++++++++++++++++
+ 3 files changed, 108 insertions(+), 80 deletions(-)
+ create mode 100644 arch/arm64/kernel/entry32_common.S
+
+diff --git a/arch/arm64/kernel/Makefile b/arch/arm64/kernel/Makefile
+index 35a7a03..c5c361f 100644
+--- a/arch/arm64/kernel/Makefile
++++ b/arch/arm64/kernel/Makefile
+@@ -29,6 +29,7 @@ arm64-obj-$(CONFIG_AARCH32_EL0)		+= sys32.o kuser32.o signal32.o 	\
+ 					   sys_compat.o entry32.o binfmt_elf32.o\
+ 					   ../../arm/kernel/opcodes.o
+ arm64-obj-$(CONFIG_ARM64_ILP32)		+= binfmt_ilp32.o
++arm64-obj-$(CONFIG_COMPAT)		+= entry32_common.o
+ arm64-obj-$(CONFIG_FUNCTION_TRACER)	+= ftrace.o entry-ftrace.o
+ arm64-obj-$(CONFIG_MODULES)		+= arm64ksyms.o module.o
+ arm64-obj-$(CONFIG_PERF_EVENTS)		+= perf_regs.o perf_callchain.o
+diff --git a/arch/arm64/kernel/entry32.S b/arch/arm64/kernel/entry32.S
+index f332d5d..4bede03 100644
+--- a/arch/arm64/kernel/entry32.S
++++ b/arch/arm64/kernel/entry32.S
+@@ -39,83 +39,3 @@ ENTRY(compat_sys_rt_sigreturn_wrapper)
+ 	mov	x0, sp
+ 	b	compat_sys_rt_sigreturn
+ ENDPROC(compat_sys_rt_sigreturn_wrapper)
+-
+-ENTRY(compat_sys_statfs64_wrapper)
+-	mov	w3, #84
+-	cmp	w1, #88
+-	csel	w1, w3, w1, eq
+-	b	compat_sys_statfs64
+-ENDPROC(compat_sys_statfs64_wrapper)
+-
+-ENTRY(compat_sys_fstatfs64_wrapper)
+-	mov	w3, #84
+-	cmp	w1, #88
+-	csel	w1, w3, w1, eq
+-	b	compat_sys_fstatfs64
+-ENDPROC(compat_sys_fstatfs64_wrapper)
+-
+-/*
+- * Note: off_4k (w5) is always in units of 4K. If we can't do the
+- * requested offset because it is not page-aligned, we return -EINVAL.
+- */
+-ENTRY(compat_sys_mmap2_wrapper)
+-#if PAGE_SHIFT > 12
+-	tst	w5, #~PAGE_MASK >> 12
+-	b.ne	1f
+-	lsr	w5, w5, #PAGE_SHIFT - 12
+-#endif
+-	b	sys_mmap_pgoff
+-1:	mov	x0, #-EINVAL
+-	ret
+-ENDPROC(compat_sys_mmap2_wrapper)
+-
+-/*
+- * Wrappers for AArch32 syscalls that either take 64-bit parameters
+- * in registers or that take 32-bit parameters which require sign
+- * extension.
+- */
+-ENTRY(compat_sys_pread64_wrapper)
+-	regs_to_64	x3, x4, x5
+-	b	sys_pread64
+-ENDPROC(compat_sys_pread64_wrapper)
+-
+-ENTRY(compat_sys_pwrite64_wrapper)
+-	regs_to_64	x3, x4, x5
+-	b	sys_pwrite64
+-ENDPROC(compat_sys_pwrite64_wrapper)
+-
+-ENTRY(compat_sys_truncate64_wrapper)
+-	regs_to_64	x1, x2, x3
+-	b	sys_truncate
+-ENDPROC(compat_sys_truncate64_wrapper)
+-
+-ENTRY(compat_sys_ftruncate64_wrapper)
+-	regs_to_64	x1, x2, x3
+-	b	sys_ftruncate
+-ENDPROC(compat_sys_ftruncate64_wrapper)
+-
+-ENTRY(compat_sys_readahead_wrapper)
+-	regs_to_64	x1, x2, x3
+-	mov	w2, w4
+-	b	sys_readahead
+-ENDPROC(compat_sys_readahead_wrapper)
+-
+-ENTRY(compat_sys_fadvise64_64_wrapper)
+-	mov	w6, w1
+-	regs_to_64	x1, x2, x3
+-	regs_to_64	x2, x4, x5
+-	mov	w3, w6
+-	b	sys_fadvise64_64
+-ENDPROC(compat_sys_fadvise64_64_wrapper)
+-
+-ENTRY(compat_sys_sync_file_range2_wrapper)
+-	regs_to_64	x2, x2, x3
+-	regs_to_64	x3, x4, x5
+-	b	sys_sync_file_range2
+-ENDPROC(compat_sys_sync_file_range2_wrapper)
+-
+-ENTRY(compat_sys_fallocate_wrapper)
+-	regs_to_64	x2, x2, x3
+-	regs_to_64	x3, x4, x5
+-	b	sys_fallocate
+-ENDPROC(compat_sys_fallocate_wrapper)
+diff --git a/arch/arm64/kernel/entry32_common.S b/arch/arm64/kernel/entry32_common.S
+new file mode 100644
+index 0000000..f4a5e4d
+--- /dev/null
++++ b/arch/arm64/kernel/entry32_common.S
+@@ -0,0 +1,107 @@
++/*
++ * Compat system call wrappers
++ *
++ * Copyright (C) 2012 ARM Ltd.
++ * Authors: Will Deacon <will.deacon@arm.com>
++ *	    Catalin Marinas <catalin.marinas@arm.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
++ */
++
++#include <linux/linkage.h>
++#include <linux/const.h>
++
++#include <asm/assembler.h>
++#include <asm/asm-offsets.h>
++#include <asm/errno.h>
++#include <asm/page.h>
++
++/*
++ * Note: off_4k (w5) is always in units of 4K. If we can't do the
++ * requested offset because it is not page-aligned, we return -EINVAL.
++ */
++ENTRY(compat_sys_mmap2_wrapper)
++#if PAGE_SHIFT > 12
++	tst	w5, #~PAGE_MASK >> 12
++	b.ne	1f
++	lsr	w5, w5, #PAGE_SHIFT - 12
++#endif
++	b	sys_mmap_pgoff
++1:	mov	x0, #-EINVAL
++	ret
++ENDPROC(compat_sys_mmap2_wrapper)
++
++/*
++ * Wrappers for AArch32 syscalls that either take 64-bit parameters
++ * in registers or that take 32-bit parameters which require sign
++ * extension.
++ */
++ENTRY(compat_sys_pread64_wrapper)
++	regs_to_64	x3, x4, x5
++	b	sys_pread64
++ENDPROC(compat_sys_pread64_wrapper)
++
++ENTRY(compat_sys_pwrite64_wrapper)
++	regs_to_64	x3, x4, x5
++	b	sys_pwrite64
++ENDPROC(compat_sys_pwrite64_wrapper)
++
++ENTRY(compat_sys_truncate64_wrapper)
++	regs_to_64	x1, x2, x3
++	b	sys_truncate
++ENDPROC(compat_sys_truncate64_wrapper)
++
++ENTRY(compat_sys_ftruncate64_wrapper)
++	regs_to_64	x1, x2, x3
++	b	sys_ftruncate
++ENDPROC(compat_sys_ftruncate64_wrapper)
++
++ENTRY(compat_sys_readahead_wrapper)
++	regs_to_64	x1, x2, x3
++	mov	w2, w4
++	b	sys_readahead
++ENDPROC(compat_sys_readahead_wrapper)
++
++ENTRY(compat_sys_fadvise64_64_wrapper)
++	mov	w6, w1
++	regs_to_64	x1, x2, x3
++	regs_to_64	x2, x4, x5
++	mov	w3, w6
++	b	sys_fadvise64_64
++ENDPROC(compat_sys_fadvise64_64_wrapper)
++
++ENTRY(compat_sys_sync_file_range2_wrapper)
++	regs_to_64	x2, x2, x3
++	regs_to_64	x3, x4, x5
++	b	sys_sync_file_range2
++ENDPROC(compat_sys_sync_file_range2_wrapper)
++
++ENTRY(compat_sys_fallocate_wrapper)
++	regs_to_64	x2, x2, x3
++	regs_to_64	x3, x4, x5
++	b	sys_fallocate
++ENDPROC(compat_sys_fallocate_wrapper)
++
++ENTRY(compat_sys_statfs64_wrapper)
++	mov	w3, #84
++	cmp	w1, #88
++	csel	w1, w3, w1, eq
++	b	compat_sys_statfs64
++ENDPROC(compat_sys_statfs64_wrapper)
++
++ENTRY(compat_sys_fstatfs64_wrapper)
++	mov	w3, #84
++	cmp	w1, #88
++	csel	w1, w3, w1, eq
++	b	compat_sys_fstatfs64
++ENDPROC(compat_sys_fstatfs64_wrapper)
+-- 
+2.5.0
+
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0013-arm64-introduce-is_a32_task-and-is_a32_thread-for-AA.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0013-arm64-introduce-is_a32_task-and-is_a32_thread-for-AA.patch
deleted file mode 100644
index d82ba3b..0000000
--- a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0013-arm64-introduce-is_a32_task-and-is_a32_thread-for-AA.patch
+++ /dev/null
@@ -1,450 +0,0 @@
-From f0310d3cbe1f47012d5258f75eb3eee10f7a7e1b Mon Sep 17 00:00:00 2001
-From: Yury Norov <ynorov@caviumnetworks.com>
-Date: Tue, 24 May 2016 03:04:42 +0300
-Subject: [PATCH 13/24] arm64: introduce is_a32_task and is_a32_thread (for
- AArch32 compat)
-
-Based on patch of Andrew Pinski.
-
-This patch introduces is_a32_compat_task and is_a32_thread so it is
-easier to say this is a a32 specific thread or a generic compat thread/task.
-Corresponding functions are located in <asm/is_compat.h> to avoid mess in
-headers.
-
-Some files include both <linux/compat.h> and <asm/compat.h>,
-and this is wrong because <linux/compat.h> has <asm/compat.h> already
-included. It was fixed too.
-
-Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
-Signed-off-by: Philipp Tomsich <philipp.tomsich@theobroma-systems.com>
-Signed-off-by: Christoph Muellner <christoph.muellner@theobroma-systems.com>
-Signed-off-by: Andrew Pinski <Andrew.Pinski@caviumnetworks.com>
-Reviewed-by: David Daney <ddaney@caviumnetworks.com>
----
- arch/arm64/include/asm/compat.h      | 19 ++----------
- arch/arm64/include/asm/elf.h         | 10 +++----
- arch/arm64/include/asm/ftrace.h      |  2 +-
- arch/arm64/include/asm/is_compat.h   | 58 ++++++++++++++++++++++++++++++++++++
- arch/arm64/include/asm/memory.h      |  3 +-
- arch/arm64/include/asm/processor.h   |  5 ++--
- arch/arm64/include/asm/syscall.h     |  2 +-
- arch/arm64/include/asm/thread_info.h |  2 +-
- arch/arm64/kernel/hw_breakpoint.c    | 10 +++----
- arch/arm64/kernel/perf_regs.c        |  2 +-
- arch/arm64/kernel/process.c          |  7 ++---
- arch/arm64/kernel/ptrace.c           |  9 +++---
- arch/arm64/kernel/signal.c           |  4 +--
- arch/arm64/kernel/traps.c            |  3 +-
- 14 files changed, 90 insertions(+), 46 deletions(-)
- create mode 100644 arch/arm64/include/asm/is_compat.h
-
-diff --git a/arch/arm64/include/asm/compat.h b/arch/arm64/include/asm/compat.h
-index eb8432b..df2f72d 100644
---- a/arch/arm64/include/asm/compat.h
-+++ b/arch/arm64/include/asm/compat.h
-@@ -24,6 +24,8 @@
- #include <linux/types.h>
- #include <linux/sched.h>
- 
-+#include <asm/is_compat.h>
-+
- #define COMPAT_USER_HZ		100
- #ifdef __AARCH64EB__
- #define COMPAT_UTS_MACHINE	"armv8b\0\0"
-@@ -298,23 +300,6 @@ struct compat_shmid64_ds {
- 	compat_ulong_t __unused5;
- };
- 
--static inline int is_compat_task(void)
--{
--	return test_thread_flag(TIF_32BIT);
--}
--
--static inline int is_compat_thread(struct thread_info *thread)
--{
--	return test_ti_thread_flag(thread, TIF_32BIT);
--}
--
--#else /* !CONFIG_COMPAT */
--
--static inline int is_compat_thread(struct thread_info *thread)
--{
--	return 0;
--}
--
- #endif /* CONFIG_COMPAT */
- #endif /* __KERNEL__ */
- #endif /* __ASM_COMPAT_H */
-diff --git a/arch/arm64/include/asm/elf.h b/arch/arm64/include/asm/elf.h
-index faad6df..d7e01fe 100644
---- a/arch/arm64/include/asm/elf.h
-+++ b/arch/arm64/include/asm/elf.h
-@@ -16,6 +16,10 @@
- #ifndef __ASM_ELF_H
- #define __ASM_ELF_H
- 
-+#ifndef __ASSEMBLY__
-+#include <linux/compat.h>
-+#endif
-+
- #include <asm/hwcap.h>
- 
- /*
-@@ -148,13 +152,9 @@ extern int arch_setup_additional_pages(struct linux_binprm *bprm,
- 				       int uses_interp);
- 
- /* 1GB of VA */
--#ifdef CONFIG_COMPAT
--#define STACK_RND_MASK			(test_thread_flag(TIF_32BIT) ? \
-+#define STACK_RND_MASK			(is_compat_task() ? \
- 						0x7ff >> (PAGE_SHIFT - 12) : \
- 						0x3ffff >> (PAGE_SHIFT - 12))
--#else
--#define STACK_RND_MASK			(0x3ffff >> (PAGE_SHIFT - 12))
--#endif
- 
- #ifdef CONFIG_COMPAT
- 
-diff --git a/arch/arm64/include/asm/ftrace.h b/arch/arm64/include/asm/ftrace.h
-index c5534fa..61cd658 100644
---- a/arch/arm64/include/asm/ftrace.h
-+++ b/arch/arm64/include/asm/ftrace.h
-@@ -52,7 +52,7 @@ static inline unsigned long ftrace_call_adjust(unsigned long addr)
- #define ARCH_TRACE_IGNORE_COMPAT_SYSCALLS
- static inline bool arch_trace_is_compat_syscall(struct pt_regs *regs)
- {
--	return is_compat_task();
-+	return is_a32_compat_task();
- }
- #endif /* ifndef __ASSEMBLY__ */
- 
-diff --git a/arch/arm64/include/asm/is_compat.h b/arch/arm64/include/asm/is_compat.h
-new file mode 100644
-index 0000000..6139b5a
---- /dev/null
-+++ b/arch/arm64/include/asm/is_compat.h
-@@ -0,0 +1,58 @@
-+/*
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License version 2 as
-+ * published by the Free Software Foundation.
-+ *
-+ * This program is distributed in the hope that it will be useful,
-+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-+ * GNU General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
-+ */
-+
-+#ifndef __ASM_IS_COMPAT_H
-+#define __ASM_IS_COMPAT_H
-+#ifndef __ASSEMBLY__
-+
-+#include <linux/thread_bits.h>
-+
-+#ifdef CONFIG_AARCH32_EL0
-+
-+static inline int is_a32_compat_task(void)
-+{
-+	return test_thread_flag(TIF_32BIT);
-+}
-+
-+static inline int is_a32_compat_thread(struct thread_info *thread)
-+{
-+	return test_ti_thread_flag(thread, TIF_32BIT);
-+}
-+
-+#else
-+
-+static inline int is_a32_compat_task(void)
-+
-+{
-+	return 0;
-+}
-+
-+static inline int is_a32_compat_thread(struct thread_info *thread)
-+{
-+	return 0;
-+}
-+
-+#endif /* CONFIG_AARCH32_EL0 */
-+
-+#ifdef CONFIG_COMPAT
-+
-+static inline int is_compat_task(void)
-+{
-+	return is_a32_compat_task();
-+}
-+
-+#endif /* CONFIG_COMPAT */
-+
-+#endif /* !__ASSEMBLY__ */
-+#endif /* __ASM_IS_COMPAT_H */
-diff --git a/arch/arm64/include/asm/memory.h b/arch/arm64/include/asm/memory.h
-index 853953c..5ec1b74 100644
---- a/arch/arm64/include/asm/memory.h
-+++ b/arch/arm64/include/asm/memory.h
-@@ -25,6 +25,7 @@
- #include <linux/const.h>
- #include <linux/types.h>
- #include <asm/sizes.h>
-+#include <asm/is_compat.h>
- 
- /*
-  * Allow for constants defined here to be used from assembly code
-@@ -60,7 +61,7 @@
- 
- #ifdef CONFIG_COMPAT
- #define TASK_SIZE_32		UL(0x100000000)
--#define TASK_SIZE		(test_thread_flag(TIF_32BIT) ? \
-+#define TASK_SIZE		(is_compat_task() ?		\
- 				TASK_SIZE_32 : TASK_SIZE_64)
- #define TASK_SIZE_OF(tsk)	(test_tsk_thread_flag(tsk, TIF_32BIT) ? \
- 				TASK_SIZE_32 : TASK_SIZE_64)
-diff --git a/arch/arm64/include/asm/processor.h b/arch/arm64/include/asm/processor.h
-index ba48561..c7473df 100644
---- a/arch/arm64/include/asm/processor.h
-+++ b/arch/arm64/include/asm/processor.h
-@@ -30,6 +30,7 @@
- #include <linux/string.h>
- 
- #include <asm/alternative.h>
-+#include <asm/is_compat.h>
- #include <asm/fpsimd.h>
- #include <asm/hw_breakpoint.h>
- #include <asm/lse.h>
-@@ -41,7 +42,7 @@
- #define STACK_TOP_MAX		TASK_SIZE_64
- #ifdef CONFIG_COMPAT
- #define AARCH32_VECTORS_BASE	0xffff0000
--#define STACK_TOP		(test_thread_flag(TIF_32BIT) ? \
-+#define STACK_TOP		(is_compat_task() ? \
- 				AARCH32_VECTORS_BASE : STACK_TOP_MAX)
- #else
- #define STACK_TOP		STACK_TOP_MAX
-@@ -94,7 +95,7 @@ struct thread_struct {
- #define task_user_tls(t)						\
- ({									\
- 	unsigned long *__tls;						\
--	if (is_compat_thread(task_thread_info(t)))			\
-+	if (is_a32_compat_thread(task_thread_info(t)))			\
- 		__tls = &(t)->thread.tp2_value;				\
- 	else								\
- 		__tls = &(t)->thread.tp_value;				\
-diff --git a/arch/arm64/include/asm/syscall.h b/arch/arm64/include/asm/syscall.h
-index 709a574..ce09641 100644
---- a/arch/arm64/include/asm/syscall.h
-+++ b/arch/arm64/include/asm/syscall.h
-@@ -113,7 +113,7 @@ static inline void syscall_set_arguments(struct task_struct *task,
-  */
- static inline int syscall_get_arch(void)
- {
--	if (is_compat_task())
-+	if (is_a32_compat_task())
- 		return AUDIT_ARCH_ARM;
- 
- 	return AUDIT_ARCH_AARCH64;
-diff --git a/arch/arm64/include/asm/thread_info.h b/arch/arm64/include/asm/thread_info.h
-index 90c7ff2..dd046c5 100644
---- a/arch/arm64/include/asm/thread_info.h
-+++ b/arch/arm64/include/asm/thread_info.h
-@@ -112,7 +112,7 @@ static inline struct thread_info *current_thread_info(void)
- #define TIF_FREEZE		19
- #define TIF_RESTORE_SIGMASK	20
- #define TIF_SINGLESTEP		21
--#define TIF_32BIT		22	/* 32bit process */
-+#define TIF_32BIT		22	/* AARCH32 process */
- 
- #define _TIF_SIGPENDING		(1 << TIF_SIGPENDING)
- #define _TIF_NEED_RESCHED	(1 << TIF_NEED_RESCHED)
-diff --git a/arch/arm64/kernel/hw_breakpoint.c b/arch/arm64/kernel/hw_breakpoint.c
-index b45c95d..baa1eba 100644
---- a/arch/arm64/kernel/hw_breakpoint.c
-+++ b/arch/arm64/kernel/hw_breakpoint.c
-@@ -164,7 +164,7 @@ enum hw_breakpoint_ops {
- 	HW_BREAKPOINT_RESTORE
- };
- 
--static int is_compat_bp(struct perf_event *bp)
-+static int is_a32_compat_bp(struct perf_event *bp)
- {
- 	struct task_struct *tsk = bp->hw.target;
- 
-@@ -175,7 +175,7 @@ static int is_compat_bp(struct perf_event *bp)
- 	 * deprecated behaviour if we use unaligned watchpoints in
- 	 * AArch64 state.
- 	 */
--	return tsk && is_compat_thread(task_thread_info(tsk));
-+	return tsk && is_a32_compat_thread(task_thread_info(tsk));
- }
- 
- /**
-@@ -435,7 +435,7 @@ static int arch_build_bp_info(struct perf_event *bp)
- 	 * Watchpoints can be of length 1, 2, 4 or 8 bytes.
- 	 */
- 	if (info->ctrl.type == ARM_BREAKPOINT_EXECUTE) {
--		if (is_compat_bp(bp)) {
-+		if (is_a32_compat_bp(bp)) {
- 			if (info->ctrl.len != ARM_BREAKPOINT_LEN_2 &&
- 			    info->ctrl.len != ARM_BREAKPOINT_LEN_4)
- 				return -EINVAL;
-@@ -492,7 +492,7 @@ int arch_validate_hwbkpt_settings(struct perf_event *bp)
- 	 * AArch32 tasks expect some simple alignment fixups, so emulate
- 	 * that here.
- 	 */
--	if (is_compat_bp(bp)) {
-+	if (is_a32_compat_bp(bp)) {
- 		if (info->ctrl.len == ARM_BREAKPOINT_LEN_8)
- 			alignment_mask = 0x7;
- 		else
-@@ -679,7 +679,7 @@ static int watchpoint_handler(unsigned long addr, unsigned int esr,
- 
- 		info = counter_arch_bp(wp);
- 		/* AArch32 watchpoints are either 4 or 8 bytes aligned. */
--		if (is_compat_task()) {
-+		if (is_a32_compat_task()) {
- 			if (info->ctrl.len == ARM_BREAKPOINT_LEN_8)
- 				alignment_mask = 0x7;
- 			else
-diff --git a/arch/arm64/kernel/perf_regs.c b/arch/arm64/kernel/perf_regs.c
-index 3f62b35..a79058f 100644
---- a/arch/arm64/kernel/perf_regs.c
-+++ b/arch/arm64/kernel/perf_regs.c
-@@ -45,7 +45,7 @@ int perf_reg_validate(u64 mask)
- 
- u64 perf_reg_abi(struct task_struct *task)
- {
--	if (is_compat_thread(task_thread_info(task)))
-+	if (is_a32_compat_thread(task_thread_info(task)))
- 		return PERF_SAMPLE_REGS_ABI_32;
- 	else
- 		return PERF_SAMPLE_REGS_ABI_64;
-diff --git a/arch/arm64/kernel/process.c b/arch/arm64/kernel/process.c
-index f75b540..44c8328 100644
---- a/arch/arm64/kernel/process.c
-+++ b/arch/arm64/kernel/process.c
-@@ -46,7 +46,6 @@
- #include <linux/notifier.h>
- #include <trace/events/power.h>
- 
--#include <asm/compat.h>
- #include <asm/cacheflush.h>
- #include <asm/fpsimd.h>
- #include <asm/mmu_context.h>
-@@ -210,7 +209,7 @@ static void tls_thread_flush(void)
- {
- 	asm ("msr tpidr_el0, xzr");
- 
--	if (is_compat_task()) {
-+	if (is_a32_compat_task()) {
- 		current->thread.tp_value = 0;
- 
- 		/*
-@@ -262,7 +261,7 @@ int copy_thread(unsigned long clone_flags, unsigned long stack_start,
- 		asm("mrs %0, tpidr_el0" : "=r" (*task_user_tls(p)));
- 
- 		if (stack_start) {
--			if (is_compat_thread(task_thread_info(p)))
-+			if (is_a32_compat_thread(task_thread_info(p)))
- 				childregs->compat_sp = stack_start;
- 			/* 16-byte aligned stack mandatory on AArch64 */
- 			else if (stack_start & 15)
-@@ -299,7 +298,7 @@ static void tls_thread_switch(struct task_struct *next)
- 	*task_user_tls(current) = tpidr;
- 
- 	tpidr = *task_user_tls(next);
--	tpidrro = is_compat_thread(task_thread_info(next)) ?
-+	tpidrro = is_a32_compat_thread(task_thread_info(next)) ?
- 		  next->thread.tp_value : 0;
- 
- 	asm(
-diff --git a/arch/arm64/kernel/ptrace.c b/arch/arm64/kernel/ptrace.c
-index 16ed9fd..39d333c 100644
---- a/arch/arm64/kernel/ptrace.c
-+++ b/arch/arm64/kernel/ptrace.c
-@@ -38,7 +38,6 @@
- #include <linux/tracehook.h>
- #include <linux/elf.h>
- 
--#include <asm/compat.h>
- #include <asm/debug-monitors.h>
- #include <asm/pgtable.h>
- #include <asm/syscall.h>
-@@ -85,7 +84,7 @@ static void ptrace_hbptriggered(struct perf_event *bp,
- #ifdef CONFIG_AARCH32_EL0
- 	int i;
- 
--	if (!is_compat_task())
-+	if (!is_a32_compat_task())
- 		goto send_sig;
- 
- 	for (i = 0; i < ARM_MAX_BRP; ++i) {
-@@ -1203,9 +1202,9 @@ const struct user_regset_view *task_user_regset_view(struct task_struct *task)
- 	 * 32-bit children use an extended user_aarch32_ptrace_view to allow
- 	 * access to the TLS register.
- 	 */
--	if (is_compat_task())
-+	if (is_a32_compat_task())
- 		return &user_aarch32_view;
--	else if (is_compat_thread(task_thread_info(task)))
-+	else if (is_a32_compat_thread(task_thread_info(task)))
- 		return &user_aarch32_ptrace_view;
- #endif
- 	return &user_aarch64_view;
-@@ -1232,7 +1231,7 @@ static void tracehook_report_syscall(struct pt_regs *regs,
- 	 * A scratch register (ip(r12) on AArch32, x7 on AArch64) is
- 	 * used to denote syscall entry/exit:
- 	 */
--	regno = (is_compat_task() ? 12 : 7);
-+	regno = (is_a32_compat_task() ? 12 : 7);
- 	saved_reg = regs->regs[regno];
- 	regs->regs[regno] = dir;
- 
-diff --git a/arch/arm64/kernel/signal.c b/arch/arm64/kernel/signal.c
-index e18c48c..65baaef 100644
---- a/arch/arm64/kernel/signal.c
-+++ b/arch/arm64/kernel/signal.c
-@@ -276,7 +276,7 @@ static int setup_rt_frame(int usig, struct ksignal *ksig, sigset_t *set,
- 
- static void setup_restart_syscall(struct pt_regs *regs)
- {
--	if (is_compat_task())
-+	if (is_a32_compat_task())
- 		compat_setup_restart_syscall(regs);
- 	else
- 		regs->regs[8] = __NR_restart_syscall;
-@@ -295,7 +295,7 @@ static void handle_signal(struct ksignal *ksig, struct pt_regs *regs)
- 	/*
- 	 * Set up the stack frame
- 	 */
--	if (is_compat_task()) {
-+	if (is_a32_compat_task()) {
- 		if (ksig->ka.sa.sa_flags & SA_SIGINFO)
- 			ret = compat_setup_rt_frame(usig, ksig, oldset, regs);
- 		else
-diff --git a/arch/arm64/kernel/traps.c b/arch/arm64/kernel/traps.c
-index b50fced..4115c44 100644
---- a/arch/arm64/kernel/traps.c
-+++ b/arch/arm64/kernel/traps.c
-@@ -18,6 +18,7 @@
-  */
- 
- #include <linux/bug.h>
-+#include <linux/compat.h>
- #include <linux/signal.h>
- #include <linux/personality.h>
- #include <linux/kallsyms.h>
-@@ -370,7 +371,7 @@ asmlinkage long do_ni_syscall(struct pt_regs *regs)
- {
- #ifdef CONFIG_AARCH32_EL0
- 	long ret;
--	if (is_compat_task()) {
-+	if (is_a32_compat_task()) {
- 		ret = compat_arm_syscall(regs);
- 		if (ret != -ENOSYS)
- 			return ret;
--- 
-1.9.1
-
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0014-arm64-ilp32-add-is_ilp32_compat_-task-thread-and-TIF.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0014-arm64-ilp32-add-is_ilp32_compat_-task-thread-and-TIF.patch
deleted file mode 100644
index 845364a..0000000
--- a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0014-arm64-ilp32-add-is_ilp32_compat_-task-thread-and-TIF.patch
+++ /dev/null
@@ -1,121 +0,0 @@
-From c2bc401ce50cac456b9f0994dc7bc0e467df2622 Mon Sep 17 00:00:00 2001
-From: Yury Norov <ynorov@caviumnetworks.com>
-Date: Tue, 24 May 2016 03:04:43 +0300
-Subject: [PATCH 14/24] arm64: ilp32: add is_ilp32_compat_{task,thread} and
- TIF_32BIT_AARCH64
-
-ILP32 tasks are needed to be distinguished from lp64 and aarch32.
-This patch adds helper functions is_ilp32_compat_{task,thread} and
-thread flag TIF_32BIT_AARCH64 to address it. This is a preparation
-for following patches in ilp32 patchset.
-
-For consistency, SET_PERSONALITY is changed here accordingly.
-
-Signed-off-by: Andrew Pinski <Andrew.Pinski@caviumnetworks.com>
-Signed-off-by: Philipp Tomsich <philipp.tomsich@theobroma-systems.com>
-Signed-off-by: Christoph Muellner <christoph.muellner@theobroma-systems.com>
-Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
-Reviewed-by: David Daney <ddaney@caviumnetworks.com>
----
- arch/arm64/include/asm/elf.h         | 13 +++++++++++--
- arch/arm64/include/asm/is_compat.h   | 28 +++++++++++++++++++++++++++-
- arch/arm64/include/asm/thread_info.h |  2 ++
- 3 files changed, 40 insertions(+), 3 deletions(-)
-
-diff --git a/arch/arm64/include/asm/elf.h b/arch/arm64/include/asm/elf.h
-index d7e01fe..61b844c 100644
---- a/arch/arm64/include/asm/elf.h
-+++ b/arch/arm64/include/asm/elf.h
-@@ -138,7 +138,11 @@ typedef struct user_fpsimd_state elf_fpregset_t;
-  */
- #define ELF_PLAT_INIT(_r, load_addr)	(_r)->regs[0] = 0
- 
--#define SET_PERSONALITY(ex)		clear_thread_flag(TIF_32BIT);
-+#define SET_PERSONALITY(ex)		\
-+do {						\
-+	clear_thread_flag(TIF_32BIT_AARCH64);	\
-+	clear_thread_flag(TIF_32BIT);		\
-+} while (0)
- 
- #define ARCH_DLINFO							\
- do {									\
-@@ -177,7 +181,12 @@ typedef compat_elf_greg_t		compat_elf_gregset_t[COMPAT_ELF_NGREG];
- 					 ((x)->e_flags & EF_ARM_EABI_MASK))
- 
- #define compat_start_thread		compat_start_thread
--#define COMPAT_SET_PERSONALITY(ex)	set_thread_flag(TIF_32BIT);
-+#define COMPAT_SET_PERSONALITY(ex)		\
-+do {						\
-+	clear_thread_flag(TIF_32BIT_AARCH64);	\
-+	set_thread_flag(TIF_32BIT);		\
-+} while (0)
-+
- #define COMPAT_ARCH_DLINFO
- extern int aarch32_setup_vectors_page(struct linux_binprm *bprm,
- 				      int uses_interp);
-diff --git a/arch/arm64/include/asm/is_compat.h b/arch/arm64/include/asm/is_compat.h
-index 6139b5a..55134cf 100644
---- a/arch/arm64/include/asm/is_compat.h
-+++ b/arch/arm64/include/asm/is_compat.h
-@@ -45,11 +45,37 @@ static inline int is_a32_compat_thread(struct thread_info *thread)
- 
- #endif /* CONFIG_AARCH32_EL0 */
- 
-+#ifdef CONFIG_ARM64_ILP32
-+
-+static inline int is_ilp32_compat_task(void)
-+{
-+	return test_thread_flag(TIF_32BIT_AARCH64);
-+}
-+
-+static inline int is_ilp32_compat_thread(struct thread_info *thread)
-+{
-+	return test_ti_thread_flag(thread, TIF_32BIT_AARCH64);
-+}
-+
-+#else
-+
-+static inline int is_ilp32_compat_task(void)
-+{
-+	return 0;
-+}
-+
-+static inline int is_ilp32_compat_thread(struct thread_info *thread)
-+{
-+	return 0;
-+}
-+
-+#endif /* CONFIG_ARM64_ILP32 */
-+
- #ifdef CONFIG_COMPAT
- 
- static inline int is_compat_task(void)
- {
--	return is_a32_compat_task();
-+	return is_a32_compat_task() || is_ilp32_compat_task();
- }
- 
- #endif /* CONFIG_COMPAT */
-diff --git a/arch/arm64/include/asm/thread_info.h b/arch/arm64/include/asm/thread_info.h
-index dd046c5..22a07d1 100644
---- a/arch/arm64/include/asm/thread_info.h
-+++ b/arch/arm64/include/asm/thread_info.h
-@@ -113,6 +113,7 @@ static inline struct thread_info *current_thread_info(void)
- #define TIF_RESTORE_SIGMASK	20
- #define TIF_SINGLESTEP		21
- #define TIF_32BIT		22	/* AARCH32 process */
-+#define TIF_32BIT_AARCH64	23	/* 32 bit process on AArch64(ILP32) */
- 
- #define _TIF_SIGPENDING		(1 << TIF_SIGPENDING)
- #define _TIF_NEED_RESCHED	(1 << TIF_NEED_RESCHED)
-@@ -124,6 +125,7 @@ static inline struct thread_info *current_thread_info(void)
- #define _TIF_SYSCALL_TRACEPOINT	(1 << TIF_SYSCALL_TRACEPOINT)
- #define _TIF_SECCOMP		(1 << TIF_SECCOMP)
- #define _TIF_32BIT		(1 << TIF_32BIT)
-+#define _TIF_32BIT_AARCH64	(1 << TIF_32BIT_AARCH64)
- 
- #define _TIF_WORK_MASK		(_TIF_NEED_RESCHED | _TIF_SIGPENDING | \
- 				 _TIF_NOTIFY_RESUME | _TIF_FOREIGN_FPSTATE)
--- 
-1.9.1
-
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0014-arm64-ilp32-add-sys_ilp32.c-and-a-separate-table-in-.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0014-arm64-ilp32-add-sys_ilp32.c-and-a-separate-table-in-.patch
new file mode 100644
index 0000000..01ad6d1
--- /dev/null
+++ b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0014-arm64-ilp32-add-sys_ilp32.c-and-a-separate-table-in-.patch
@@ -0,0 +1,250 @@
+From a480130b29a910c7ca7a35ab58d923498e93b915 Mon Sep 17 00:00:00 2001
+From: Andrew Pinski <apinski@cavium.com>
+Date: Tue, 24 May 2016 03:04:47 +0300
+Subject: [PATCH 14/20] arm64: ilp32: add sys_ilp32.c and a separate table (in
+ entry.S) to use it
+
+Add a separate syscall-table for ILP32, which dispatches either to native
+LP64 system call implementation or to compat-syscalls, as appropriate.
+
+Signed-off-by: Andrew Pinski <Andrew.Pinski@caviumnetworks.com>
+Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
+---
+ arch/arm64/include/asm/unistd.h      |   8 ++-
+ arch/arm64/include/uapi/asm/unistd.h |  13 +++++
+ arch/arm64/kernel/Makefile           |   2 +-
+ arch/arm64/kernel/entry.S            |  28 +++++++++-
+ arch/arm64/kernel/sys_ilp32.c        | 100 +++++++++++++++++++++++++++++++++++
+ 5 files changed, 146 insertions(+), 5 deletions(-)
+ create mode 100644 arch/arm64/kernel/sys_ilp32.c
+
+diff --git a/arch/arm64/include/asm/unistd.h b/arch/arm64/include/asm/unistd.h
+index 2971dea..118d238 100644
+--- a/arch/arm64/include/asm/unistd.h
++++ b/arch/arm64/include/asm/unistd.h
+@@ -13,13 +13,17 @@
+  * You should have received a copy of the GNU General Public License
+  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+  */
++
++#ifdef CONFIG_COMPAT
++#define __ARCH_WANT_COMPAT_STAT64
++#define __ARCH_WANT_SYS_LLSEEK
++#endif
++
+ #ifdef CONFIG_AARCH32_EL0
+ #define __ARCH_WANT_COMPAT_SYS_GETDENTS64
+-#define __ARCH_WANT_COMPAT_STAT64
+ #define __ARCH_WANT_SYS_GETHOSTNAME
+ #define __ARCH_WANT_SYS_PAUSE
+ #define __ARCH_WANT_SYS_GETPGRP
+-#define __ARCH_WANT_SYS_LLSEEK
+ #define __ARCH_WANT_SYS_NICE
+ #define __ARCH_WANT_SYS_SIGPENDING
+ #define __ARCH_WANT_SYS_SIGPROCMASK
+diff --git a/arch/arm64/include/uapi/asm/unistd.h b/arch/arm64/include/uapi/asm/unistd.h
+index 3faca2c..1ff3047 100644
+--- a/arch/arm64/include/uapi/asm/unistd.h
++++ b/arch/arm64/include/uapi/asm/unistd.h
+@@ -13,6 +13,19 @@
+  * You should have received a copy of the GNU General Public License
+  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+  */
++
++/*
++ * Use AARCH32 interface for sys_sync_file_range() as it passes 64-bit arguments.
++ */
++#if defined(__ILP32__) || defined(__SYSCALL_COMPAT)
++#define __ARCH_WANT_SYNC_FILE_RANGE2
++#endif
++
++/*
++ * AARCH64/ILP32 is introduced after next syscalls were deprecated.
++ */
++#if !(defined(__ILP32__) || defined(__SYSCALL_COMPAT))
+ #define __ARCH_WANT_SET_GET_RLIMIT
++#endif
+ 
+ #include <asm-generic/unistd.h>
+diff --git a/arch/arm64/kernel/Makefile b/arch/arm64/kernel/Makefile
+index c5c361f..9939e37 100644
+--- a/arch/arm64/kernel/Makefile
++++ b/arch/arm64/kernel/Makefile
+@@ -28,7 +28,7 @@ $(obj)/%.stub.o: $(obj)/%.o FORCE
+ arm64-obj-$(CONFIG_AARCH32_EL0)		+= sys32.o kuser32.o signal32.o 	\
+ 					   sys_compat.o entry32.o binfmt_elf32.o\
+ 					   ../../arm/kernel/opcodes.o
+-arm64-obj-$(CONFIG_ARM64_ILP32)		+= binfmt_ilp32.o
++arm64-obj-$(CONFIG_ARM64_ILP32)		+= binfmt_ilp32.o sys_ilp32.o
+ arm64-obj-$(CONFIG_COMPAT)		+= entry32_common.o
+ arm64-obj-$(CONFIG_FUNCTION_TRACER)	+= ftrace.o entry-ftrace.o
+ arm64-obj-$(CONFIG_MODULES)		+= arm64ksyms.o module.o
+diff --git a/arch/arm64/kernel/entry.S b/arch/arm64/kernel/entry.S
+index d782d2a..5f7def4 100644
+--- a/arch/arm64/kernel/entry.S
++++ b/arch/arm64/kernel/entry.S
+@@ -191,6 +191,23 @@ tsk	.req	x28		// current thread_info
+ 
+ 	.text
+ 
++#ifdef CONFIG_ARM64_ILP32
++/*
++ * AARCH64/ILP32. Zero top halves of x0-x7
++ * registers as userspace may put garbage there.
++ */
++	.macro	delouse_input_regs
++	mov w0, w0
++	mov w1, w1
++	mov w2, w2
++	mov w3, w3
++	mov w4, w4
++	mov w5, w5
++	mov w6, w6
++	mov w7, w7
++	.endm
++#endif
++
+ /*
+  * Exception vectors.
+  */
+@@ -452,6 +469,7 @@ el0_svc_compat:
+ 	 * AArch32 syscall handling
+ 	 */
+ 	adrp	stbl, compat_sys_call_table	// load compat syscall table pointer
++	ldr     x16, [tsk, #TI_FLAGS]
+ 	uxtw	scno, w7			// syscall number in w7 (r7)
+ 	mov     sc_nr, #__NR_compat_syscalls
+ 	b	el0_svc_naked
+@@ -670,15 +688,21 @@ ENDPROC(ret_from_fork)
+ 	.align	6
+ el0_svc:
+ 	adrp	stbl, sys_call_table		// load syscall table pointer
++	ldr	x16, [tsk, #TI_FLAGS]
+ 	uxtw	scno, w8			// syscall number in w8
+ 	mov	sc_nr, #__NR_syscalls
++#ifdef CONFIG_ARM64_ILP32
++	tst	x16, #_TIF_32BIT_AARCH64
++	b.eq	el0_svc_naked			// We are using LP64  syscall table
++	adrp	stbl, sys_call_ilp32_table	// load ilp32 syscall table pointer
++	delouse_input_regs
++#endif
+ el0_svc_naked:					// compat entry point
+ 	stp	x0, scno, [sp, #S_ORIG_X0]	// save the original x0 and syscall number
+ 	enable_dbg_and_irq
+ 	ct_user_exit 1
+ 
+-	ldr	x16, [tsk, #TI_FLAGS]		// check for syscall hooks
+-	tst	x16, #_TIF_SYSCALL_WORK
++	tst	x16, #_TIF_SYSCALL_WORK		// check for syscall hooks
+ 	b.ne	__sys_trace
+ 	cmp     scno, sc_nr                     // check upper syscall limit
+ 	b.hs	ni_sys
+diff --git a/arch/arm64/kernel/sys_ilp32.c b/arch/arm64/kernel/sys_ilp32.c
+new file mode 100644
+index 0000000..d203dec
+--- /dev/null
++++ b/arch/arm64/kernel/sys_ilp32.c
+@@ -0,0 +1,100 @@
++/*
++ * AArch64- ILP32 specific system calls implementation
++ *
++ * Copyright (C) 2017 Cavium Inc.
++ * Author: Andrew Pinski <apinski@cavium.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
++ */
++
++#define __SYSCALL_COMPAT
++
++#include <linux/compiler.h>
++#include <linux/errno.h>
++#include <linux/fs.h>
++#include <linux/mm.h>
++#include <linux/msg.h>
++#include <linux/export.h>
++#include <linux/sched.h>
++#include <linux/slab.h>
++#include <linux/syscalls.h>
++#include <linux/compat.h>
++#include <asm-generic/syscalls.h>
++
++/*
++ * AARCH32 requires 4-page alignement for shared memory,
++ * but AARCH64 - only 1 page. This is the only difference
++ * between compat and native sys_shmat(). So ILP32 just pick
++ * AARCH64 version.
++ */
++#define compat_sys_shmat		sys_shmat
++
++/*
++ * ILP32 needs special handling for some ptrace requests.
++ */
++#define sys_ptrace			compat_sys_ptrace
++
++/*
++ * Using AARCH32 interface for syscalls that take 64-bit
++ * parameters in registers.
++ */
++#define compat_sys_fadvise64_64		compat_sys_fadvise64_64_wrapper
++#define compat_sys_fallocate		compat_sys_fallocate_wrapper
++#define compat_sys_ftruncate64		compat_sys_ftruncate64_wrapper
++#define compat_sys_pread64		compat_sys_pread64_wrapper
++#define compat_sys_pwrite64		compat_sys_pwrite64_wrapper
++#define compat_sys_readahead		compat_sys_readahead_wrapper
++#define compat_sys_sync_file_range2	compat_sys_sync_file_range2_wrapper
++#define compat_sys_truncate64		compat_sys_truncate64_wrapper
++#define sys_mmap2			compat_sys_mmap2_wrapper
++
++/*
++ * Using AARCH32 interface for syscalls that take the size of
++ * sfruct statfs as an argument, as it's calculated differently
++ * in kernel and user spaces.
++ */
++#define compat_sys_fstatfs64		compat_sys_fstatfs64_wrapper
++#define compat_sys_statfs64		compat_sys_statfs64_wrapper
++
++/*
++ * Using custom wrapper for rt_sigreturn() to handle custom
++ * struct rt_sigframe.
++ */
++#define compat_sys_rt_sigreturn        ilp32_sys_rt_sigreturn_wrapper
++
++asmlinkage long compat_sys_fstatfs64_wrapper(void);
++asmlinkage long compat_sys_statfs64_wrapper(void);
++asmlinkage long compat_sys_fadvise64_64_wrapper(void);
++asmlinkage long compat_sys_fallocate_wrapper(void);
++asmlinkage long compat_sys_ftruncate64_wrapper(void);
++asmlinkage long compat_sys_mmap2_wrapper(void);
++asmlinkage long compat_sys_pread64_wrapper(void);
++asmlinkage long compat_sys_pwrite64_wrapper(void);
++asmlinkage long compat_sys_readahead_wrapper(void);
++asmlinkage long compat_sys_sync_file_range2_wrapper(void);
++asmlinkage long compat_sys_truncate64_wrapper(void);
++asmlinkage long ilp32_sys_rt_sigreturn_wrapper(void);
++
++#include <asm/syscall.h>
++
++#undef __SYSCALL
++#define __SYSCALL(nr, sym)	[nr] = sym,
++
++/*
++ * The sys_call_ilp32_table array must be 4K aligned to be accessible from
++ * kernel/entry.S.
++ */
++void *sys_call_ilp32_table[__NR_syscalls] __aligned(4096) = {
++	[0 ... __NR_syscalls - 1] = sys_ni_syscall,
++#include <asm/unistd.h>
++};
+-- 
+2.5.0
+
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0015-arm64-introduce-binfmt_elf32.c.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0015-arm64-introduce-binfmt_elf32.c.patch
deleted file mode 100644
index f916161..0000000
--- a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0015-arm64-introduce-binfmt_elf32.c.patch
+++ /dev/null
@@ -1,141 +0,0 @@
-From 0e20d0a9c8be168e112943b91646b5d94767bb71 Mon Sep 17 00:00:00 2001
-From: Yury Norov <ynorov@caviumnetworks.com>
-Date: Tue, 24 May 2016 03:04:44 +0300
-Subject: [PATCH 15/24] arm64: introduce binfmt_elf32.c
-
-As we support more than one compat formats, it looks more reasonable
-to not use fs/compat_binfmt.c. Custom binfmt_elf32.c allows to move aarch32
-specific definitions there and make code more maintainable and readable.
-
-Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
----
- arch/arm64/Kconfig               |  1 -
- arch/arm64/include/asm/elf.h     | 24 ------------------------
- arch/arm64/include/asm/hwcap.h   |  2 --
- arch/arm64/kernel/Makefile       |  2 +-
- arch/arm64/kernel/binfmt_elf32.c | 33 +++++++++++++++++++++++++++++++++
- 5 files changed, 34 insertions(+), 28 deletions(-)
- create mode 100644 arch/arm64/kernel/binfmt_elf32.c
-
-diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
-index ef8bddf..9ce37af 100644
---- a/arch/arm64/Kconfig
-+++ b/arch/arm64/Kconfig
-@@ -826,7 +826,6 @@ config AARCH32_EL0
- 	bool "Kernel support for 32-bit EL0"
- 	def_bool y
- 	depends on ARM64_4K_PAGES || EXPERT
--	select COMPAT_BINFMT_ELF
- 	select HAVE_UID16
- 	select OLD_SIGSUSPEND3
- 	select COMPAT_OLD_SIGACTION
-diff --git a/arch/arm64/include/asm/elf.h b/arch/arm64/include/asm/elf.h
-index 61b844c..920a867 100644
---- a/arch/arm64/include/asm/elf.h
-+++ b/arch/arm64/include/asm/elf.h
-@@ -162,12 +162,6 @@ extern int arch_setup_additional_pages(struct linux_binprm *bprm,
- 
- #ifdef CONFIG_COMPAT
- 
--#ifdef __AARCH64EB__
--#define COMPAT_ELF_PLATFORM		("v8b")
--#else
--#define COMPAT_ELF_PLATFORM		("v8l")
--#endif
--
- #define COMPAT_ELF_ET_DYN_BASE		(2 * TASK_SIZE_32 / 3)
- 
- /* AArch32 registers. */
-@@ -175,24 +169,6 @@ extern int arch_setup_additional_pages(struct linux_binprm *bprm,
- typedef unsigned int			compat_elf_greg_t;
- typedef compat_elf_greg_t		compat_elf_gregset_t[COMPAT_ELF_NGREG];
- 
--/* AArch32 EABI. */
--#define EF_ARM_EABI_MASK		0xff000000
--#define compat_elf_check_arch(x)	(((x)->e_machine == EM_ARM) && \
--					 ((x)->e_flags & EF_ARM_EABI_MASK))
--
--#define compat_start_thread		compat_start_thread
--#define COMPAT_SET_PERSONALITY(ex)		\
--do {						\
--	clear_thread_flag(TIF_32BIT_AARCH64);	\
--	set_thread_flag(TIF_32BIT);		\
--} while (0)
--
--#define COMPAT_ARCH_DLINFO
--extern int aarch32_setup_vectors_page(struct linux_binprm *bprm,
--				      int uses_interp);
--#define compat_arch_setup_additional_pages \
--					aarch32_setup_vectors_page
--
- #endif /* CONFIG_COMPAT */
- 
- #endif
-diff --git a/arch/arm64/include/asm/hwcap.h b/arch/arm64/include/asm/hwcap.h
-index 2c7fc5d..99dfd92 100644
---- a/arch/arm64/include/asm/hwcap.h
-+++ b/arch/arm64/include/asm/hwcap.h
-@@ -47,8 +47,6 @@
- #define ELF_HWCAP		(elf_hwcap)
- 
- #ifdef CONFIG_AARCH32_EL0
--#define COMPAT_ELF_HWCAP	(compat_elf_hwcap)
--#define COMPAT_ELF_HWCAP2	(compat_elf_hwcap2)
- extern unsigned int compat_elf_hwcap, compat_elf_hwcap2;
- #endif
- 
-diff --git a/arch/arm64/kernel/Makefile b/arch/arm64/kernel/Makefile
-index 4c11256..23a4a38 100644
---- a/arch/arm64/kernel/Makefile
-+++ b/arch/arm64/kernel/Makefile
-@@ -27,7 +27,7 @@ $(obj)/%.stub.o: $(obj)/%.o FORCE
- 
- arm64-obj-$(CONFIG_AARCH32_EL0)		+= sys32.o kuser32.o signal32.o 	\
- 					   sys_compat.o entry32.o		\
--					   ../../arm/kernel/opcodes.o
-+					   ../../arm/kernel/opcodes.o binfmt_elf32.o
- arm64-obj-$(CONFIG_FUNCTION_TRACER)	+= ftrace.o entry-ftrace.o
- arm64-obj-$(CONFIG_MODULES)		+= arm64ksyms.o module.o
- arm64-obj-$(CONFIG_PERF_EVENTS)		+= perf_regs.o perf_callchain.o
-diff --git a/arch/arm64/kernel/binfmt_elf32.c b/arch/arm64/kernel/binfmt_elf32.c
-new file mode 100644
-index 0000000..5487872
---- /dev/null
-+++ b/arch/arm64/kernel/binfmt_elf32.c
-@@ -0,0 +1,33 @@
-+/*
-+ * Support for AArch32 Linux ELF binaries.
-+ */
-+
-+/* AArch32 EABI. */
-+#define EF_ARM_EABI_MASK		0xff000000
-+#define compat_elf_check_arch(x)	(((x)->e_machine == EM_ARM) && \
-+					 ((x)->e_flags & EF_ARM_EABI_MASK))
-+
-+#define compat_start_thread		compat_start_thread
-+#define COMPAT_SET_PERSONALITY(ex)		\
-+do {						\
-+	clear_thread_flag(TIF_32BIT_AARCH64);	\
-+	set_thread_flag(TIF_32BIT);		\
-+} while (0)
-+
-+#define COMPAT_ARCH_DLINFO
-+#define COMPAT_ELF_HWCAP		(compat_elf_hwcap)
-+#define COMPAT_ELF_HWCAP2		(compat_elf_hwcap2)
-+
-+#ifdef __AARCH64EB__
-+#define COMPAT_ELF_PLATFORM		("v8b")
-+#else
-+#define COMPAT_ELF_PLATFORM		("v8l")
-+#endif
-+
-+#define compat_arch_setup_additional_pages \
-+					aarch32_setup_vectors_page
-+struct linux_binprm;
-+extern int aarch32_setup_vectors_page(struct linux_binprm *bprm,
-+				      int uses_interp);
-+
-+#include "../../../fs/compat_binfmt_elf.c"
--- 
-1.9.1
-
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0015-arm64-signal-share-lp64-signal-routines-to-ilp32.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0015-arm64-signal-share-lp64-signal-routines-to-ilp32.patch
new file mode 100644
index 0000000..d6fe1e7
--- /dev/null
+++ b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0015-arm64-signal-share-lp64-signal-routines-to-ilp32.patch
@@ -0,0 +1,241 @@
+From 7d94f604c2d5c3bd93d9ad8c1f7989c01bd1086e Mon Sep 17 00:00:00 2001
+From: Yury Norov <ynorov@caviumnetworks.com>
+Date: Tue, 24 May 2016 03:04:48 +0300
+Subject: [PATCH 15/20] arm64: signal: share lp64 signal routines to ilp32
+
+After that, it will be possible to reuse it in ilp32.
+
+Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
+---
+ arch/arm64/include/asm/signal_common.h | 33 ++++++++++++
+ arch/arm64/kernel/signal.c             | 93 +++++++++++++++++++++-------------
+ 2 files changed, 92 insertions(+), 34 deletions(-)
+ create mode 100644 arch/arm64/include/asm/signal_common.h
+
+diff --git a/arch/arm64/include/asm/signal_common.h b/arch/arm64/include/asm/signal_common.h
+new file mode 100644
+index 0000000..756ed2c
+--- /dev/null
++++ b/arch/arm64/include/asm/signal_common.h
+@@ -0,0 +1,33 @@
++/*
++ * Copyright (C) 1995-2009 Russell King
++ * Copyright (C) 2012 ARM Ltd.
++ * Copyright (C) 2016 Cavium Networks.
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
++ */
++
++#ifndef __ASM_SIGNAL_COMMON_H
++#define __ASM_SIGNAL_COMMON_H
++
++#include <linux/uaccess.h>
++#include <asm/ucontext.h>
++#include <asm/fpsimd.h>
++
++int preserve_fpsimd_context(struct fpsimd_context __user *ctx);
++int restore_fpsimd_context(struct fpsimd_context __user *ctx);
++int setup_sigcontext(struct sigcontext __user *uc_mcontext, struct pt_regs *regs);
++int restore_sigcontext(struct pt_regs *regs, struct sigcontext __user *sf);
++void setup_return(struct pt_regs *regs, struct k_sigaction *ka,
++			void __user *frame, off_t sigframe_off, int usig);
++
++#endif /* __ASM_SIGNAL_COMMON_H */
+diff --git a/arch/arm64/kernel/signal.c b/arch/arm64/kernel/signal.c
+index 65baaef..5244075 100644
+--- a/arch/arm64/kernel/signal.c
++++ b/arch/arm64/kernel/signal.c
+@@ -34,18 +34,26 @@
+ #include <asm/fpsimd.h>
+ #include <asm/signal32.h>
+ #include <asm/vdso.h>
++#include <asm/signal_common.h>
++
++#define RT_SIGFRAME_FP_POS (offsetof(struct rt_sigframe, sig)	\
++			+ offsetof(struct sigframe, fp))
++
++struct sigframe {
++	struct ucontext uc;
++	u64 fp;
++	u64 lr;
++};
+ 
+ /*
+  * Do a signal return; undo the signal stack. These are aligned to 128-bit.
+  */
+ struct rt_sigframe {
+ 	struct siginfo info;
+-	struct ucontext uc;
+-	u64 fp;
+-	u64 lr;
++	struct sigframe sig;
+ };
+ 
+-static int preserve_fpsimd_context(struct fpsimd_context __user *ctx)
++int preserve_fpsimd_context(struct fpsimd_context __user *ctx)
+ {
+ 	struct fpsimd_state *fpsimd = &current->thread.fpsimd_state;
+ 	int err;
+@@ -65,7 +73,7 @@ static int preserve_fpsimd_context(struct fpsimd_context __user *ctx)
+ 	return err ? -EFAULT : 0;
+ }
+ 
+-static int restore_fpsimd_context(struct fpsimd_context __user *ctx)
++int restore_fpsimd_context(struct fpsimd_context __user *ctx)
+ {
+ 	struct fpsimd_state fpsimd;
+ 	__u32 magic, size;
+@@ -93,22 +101,30 @@ static int restore_fpsimd_context(struct fpsimd_context __user *ctx)
+ }
+ 
+ static int restore_sigframe(struct pt_regs *regs,
+-			    struct rt_sigframe __user *sf)
++			    struct sigframe __user *sf)
+ {
+ 	sigset_t set;
+-	int i, err;
+-	void *aux = sf->uc.uc_mcontext.__reserved;
+-
++	int err;
+ 	err = __copy_from_user(&set, &sf->uc.uc_sigmask, sizeof(set));
+ 	if (err == 0)
+ 		set_current_blocked(&set);
+ 
++	err |= restore_sigcontext(regs, &sf->uc.uc_mcontext);
++	return err;
++}
++
++
++int restore_sigcontext(struct pt_regs *regs, struct sigcontext __user *uc_mcontext)
++{
++	int i, err = 0;
++	void *aux = uc_mcontext->__reserved;
++
+ 	for (i = 0; i < 31; i++)
+-		__get_user_error(regs->regs[i], &sf->uc.uc_mcontext.regs[i],
++		__get_user_error(regs->regs[i], &uc_mcontext->regs[i],
+ 				 err);
+-	__get_user_error(regs->sp, &sf->uc.uc_mcontext.sp, err);
+-	__get_user_error(regs->pc, &sf->uc.uc_mcontext.pc, err);
+-	__get_user_error(regs->pstate, &sf->uc.uc_mcontext.pstate, err);
++	__get_user_error(regs->sp, &uc_mcontext->sp, err);
++	__get_user_error(regs->pc, &uc_mcontext->pc, err);
++	__get_user_error(regs->pstate, &uc_mcontext->pstate, err);
+ 
+ 	/*
+ 	 * Avoid sys_rt_sigreturn() restarting.
+@@ -145,10 +161,10 @@ asmlinkage long sys_rt_sigreturn(struct pt_regs *regs)
+ 	if (!access_ok(VERIFY_READ, frame, sizeof (*frame)))
+ 		goto badframe;
+ 
+-	if (restore_sigframe(regs, frame))
++	if (restore_sigframe(regs, &frame->sig))
+ 		goto badframe;
+ 
+-	if (restore_altstack(&frame->uc.uc_stack))
++	if (restore_altstack(&frame->sig.uc.uc_stack))
+ 		goto badframe;
+ 
+ 	return regs->regs[0];
+@@ -162,27 +178,36 @@ badframe:
+ 	return 0;
+ }
+ 
+-static int setup_sigframe(struct rt_sigframe __user *sf,
++static int setup_sigframe(struct sigframe __user *sf,
+ 			  struct pt_regs *regs, sigset_t *set)
+ {
+-	int i, err = 0;
+-	void *aux = sf->uc.uc_mcontext.__reserved;
+-	struct _aarch64_ctx *end;
++	int err = 0;
+ 
+ 	/* set up the stack frame for unwinding */
+ 	__put_user_error(regs->regs[29], &sf->fp, err);
+ 	__put_user_error(regs->regs[30], &sf->lr, err);
++	err |= __copy_to_user(&sf->uc.uc_sigmask, set, sizeof(*set));
++	err |= setup_sigcontext(&sf->uc.uc_mcontext, regs);
++
++	return err;
++}
++
++int setup_sigcontext(struct sigcontext __user *uc_mcontext,
++			struct pt_regs *regs)
++{
++	void *aux = uc_mcontext->__reserved;
++	struct _aarch64_ctx *end;
++	int i, err = 0;
+ 
+ 	for (i = 0; i < 31; i++)
+-		__put_user_error(regs->regs[i], &sf->uc.uc_mcontext.regs[i],
++		__put_user_error(regs->regs[i], &uc_mcontext->regs[i],
+ 				 err);
+-	__put_user_error(regs->sp, &sf->uc.uc_mcontext.sp, err);
+-	__put_user_error(regs->pc, &sf->uc.uc_mcontext.pc, err);
+-	__put_user_error(regs->pstate, &sf->uc.uc_mcontext.pstate, err);
+ 
+-	__put_user_error(current->thread.fault_address, &sf->uc.uc_mcontext.fault_address, err);
++	__put_user_error(regs->sp, &uc_mcontext->sp, err);
++	__put_user_error(regs->pc, &uc_mcontext->pc, err);
++	__put_user_error(regs->pstate, &uc_mcontext->pstate, err);
+ 
+-	err |= __copy_to_user(&sf->uc.uc_sigmask, set, sizeof(*set));
++	__put_user_error(current->thread.fault_address, &uc_mcontext->fault_address, err);
+ 
+ 	if (err == 0) {
+ 		struct fpsimd_context *fpsimd_ctx =
+@@ -229,14 +254,14 @@ static struct rt_sigframe __user *get_sigframe(struct ksignal *ksig,
+ 	return frame;
+ }
+ 
+-static void setup_return(struct pt_regs *regs, struct k_sigaction *ka,
+-			 void __user *frame, int usig)
++void setup_return(struct pt_regs *regs, struct k_sigaction *ka,
++			 void __user *frame, off_t fp_pos, int usig)
+ {
+ 	__sigrestore_t sigtramp;
+ 
+ 	regs->regs[0] = usig;
+ 	regs->sp = (unsigned long)frame;
+-	regs->regs[29] = regs->sp + offsetof(struct rt_sigframe, fp);
++	regs->regs[29] = regs->sp + fp_pos;
+ 	regs->pc = (unsigned long)ka->sa.sa_handler;
+ 
+ 	if (ka->sa.sa_flags & SA_RESTORER)
+@@ -257,17 +282,17 @@ static int setup_rt_frame(int usig, struct ksignal *ksig, sigset_t *set,
+ 	if (!frame)
+ 		return 1;
+ 
+-	__put_user_error(0, &frame->uc.uc_flags, err);
+-	__put_user_error(NULL, &frame->uc.uc_link, err);
++	__put_user_error(0, &frame->sig.uc.uc_flags, err);
++	__put_user_error(NULL, &frame->sig.uc.uc_link, err);
+ 
+-	err |= __save_altstack(&frame->uc.uc_stack, regs->sp);
+-	err |= setup_sigframe(frame, regs, set);
++	err |= __save_altstack(&frame->sig.uc.uc_stack, regs->sp);
++	err |= setup_sigframe(&frame->sig, regs, set);
+ 	if (err == 0) {
+-		setup_return(regs, &ksig->ka, frame, usig);
++		setup_return(regs, &ksig->ka, frame, RT_SIGFRAME_FP_POS, usig);
+ 		if (ksig->ka.sa.sa_flags & SA_SIGINFO) {
+ 			err |= copy_siginfo_to_user(&frame->info, &ksig->info);
+ 			regs->regs[1] = (unsigned long)&frame->info;
+-			regs->regs[2] = (unsigned long)&frame->uc;
++			regs->regs[2] = (unsigned long)&frame->sig.uc;
+ 		}
+ 	}
+ 
+-- 
+2.5.0
+
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0016-arm64-ilp32-introduce-binfmt_ilp32.c.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0016-arm64-ilp32-introduce-binfmt_ilp32.c.patch
deleted file mode 100644
index 1ce3e4a..0000000
--- a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0016-arm64-ilp32-introduce-binfmt_ilp32.c.patch
+++ /dev/null
@@ -1,126 +0,0 @@
-From d9fc9b0b2c9e5c0588e7f2ddd1577bc3fb665c5b Mon Sep 17 00:00:00 2001
-From: Yury Norov <ynorov@caviumnetworks.com>
-Date: Tue, 24 May 2016 03:04:45 +0300
-Subject: [PATCH 16/24] arm64: ilp32: introduce binfmt_ilp32.c
-
-to handle ILP32 binaries
-
-Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
----
- arch/arm64/kernel/Makefile       |  1 +
- arch/arm64/kernel/binfmt_ilp32.c | 91 ++++++++++++++++++++++++++++++++++++++++
- 2 files changed, 92 insertions(+)
- create mode 100644 arch/arm64/kernel/binfmt_ilp32.c
-
-diff --git a/arch/arm64/kernel/Makefile b/arch/arm64/kernel/Makefile
-index 23a4a38..4cc81da 100644
---- a/arch/arm64/kernel/Makefile
-+++ b/arch/arm64/kernel/Makefile
-@@ -28,6 +28,7 @@ $(obj)/%.stub.o: $(obj)/%.o FORCE
- arm64-obj-$(CONFIG_AARCH32_EL0)		+= sys32.o kuser32.o signal32.o 	\
- 					   sys_compat.o entry32.o		\
- 					   ../../arm/kernel/opcodes.o binfmt_elf32.o
-+arm64-obj-$(CONFIG_ARM64_ILP32)		+= binfmt_ilp32.o
- arm64-obj-$(CONFIG_FUNCTION_TRACER)	+= ftrace.o entry-ftrace.o
- arm64-obj-$(CONFIG_MODULES)		+= arm64ksyms.o module.o
- arm64-obj-$(CONFIG_PERF_EVENTS)		+= perf_regs.o perf_callchain.o
-diff --git a/arch/arm64/kernel/binfmt_ilp32.c b/arch/arm64/kernel/binfmt_ilp32.c
-new file mode 100644
-index 0000000..a934fd4
---- /dev/null
-+++ b/arch/arm64/kernel/binfmt_ilp32.c
-@@ -0,0 +1,91 @@
-+/*
-+ * Support for ILP32 Linux/aarch64 ELF binaries.
-+ */
-+
-+#include <linux/elfcore-compat.h>
-+#include <linux/time.h>
-+
-+#undef	ELF_CLASS
-+#define ELF_CLASS	ELFCLASS32
-+
-+#undef	elfhdr
-+#undef	elf_phdr
-+#undef	elf_shdr
-+#undef	elf_note
-+#undef	elf_addr_t
-+#define elfhdr		elf32_hdr
-+#define elf_phdr	elf32_phdr
-+#define elf_shdr	elf32_shdr
-+#define elf_note	elf32_note
-+#define elf_addr_t	Elf32_Addr
-+
-+/*
-+ * Some data types as stored in coredump.
-+ */
-+#define user_long_t		compat_long_t
-+#define user_siginfo_t		compat_siginfo_t
-+#define copy_siginfo_to_user	copy_siginfo_to_user32
-+
-+/*
-+ * The machine-dependent core note format types are defined in elfcore-compat.h,
-+ * which requires asm/elf.h to define compat_elf_gregset_t et al.
-+ */
-+#define elf_prstatus	compat_elf_prstatus
-+#define elf_prpsinfo	compat_elf_prpsinfo
-+
-+/*
-+ * Compat version of cputime_to_compat_timeval, perhaps this
-+ * should be an inline in <linux/compat.h>.
-+ */
-+static void cputime_to_compat_timeval(const cputime_t cputime,
-+				      struct compat_timeval *value)
-+{
-+	struct timeval tv;
-+	cputime_to_timeval(cputime, &tv);
-+	value->tv_sec = tv.tv_sec;
-+	value->tv_usec = tv.tv_usec;
-+}
-+
-+#undef cputime_to_timeval
-+#define cputime_to_timeval cputime_to_compat_timeval
-+
-+/* AARCH64 ILP32 EABI. */
-+#undef elf_check_arch
-+#define elf_check_arch(x)		(((x)->e_machine == EM_AARCH64)	\
-+					&& (x)->e_ident[EI_CLASS] == ELFCLASS32)
-+
-+#undef SET_PERSONALITY
-+#define SET_PERSONALITY(ex)						\
-+do {									\
-+	set_thread_flag(TIF_32BIT_AARCH64);				\
-+	clear_thread_flag(TIF_32BIT);					\
-+} while (0)
-+
-+#undef ARCH_DLINFO
-+#define ARCH_DLINFO							\
-+do {									\
-+	NEW_AUX_ENT(AT_SYSINFO_EHDR,					\
-+		    (elf_addr_t)(long)current->mm->context.vdso);	\
-+} while (0)
-+
-+#ifdef __AARCH64EB__
-+#define COMPAT_ELF_PLATFORM		("aarch64_be:ilp32")
-+#else
-+#define COMPAT_ELF_PLATFORM		("aarch64:ilp32")
-+#endif
-+
-+#undef ELF_HWCAP
-+#undef ELF_HWCAP2
-+#define ELF_HWCAP			((u32) elf_hwcap)
-+#define ELF_HWCAP2			((u32) (elf_hwcap >> 32))
-+
-+/*
-+ * Rename a few of the symbols that binfmt_elf.c will define.
-+ * These are all local so the names don't really matter, but it
-+ * might make some debugging less confusing not to duplicate them.
-+ */
-+#define elf_format		compat_elf_format
-+#define init_elf_binfmt		init_compat_elf_binfmt
-+#define exit_elf_binfmt		exit_compat_elf_binfmt
-+
-+#include "../../../fs/binfmt_elf.c"
--- 
-1.9.1
-
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0016-arm64-signal32-move-ilp32-and-aarch32-common-code-to.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0016-arm64-signal32-move-ilp32-and-aarch32-common-code-to.patch
new file mode 100644
index 0000000..804015a
--- /dev/null
+++ b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0016-arm64-signal32-move-ilp32-and-aarch32-common-code-to.patch
@@ -0,0 +1,339 @@
+From be5046051741dfd0db60142e18acfbf4f667a648 Mon Sep 17 00:00:00 2001
+From: Yury Norov <ynorov@caviumnetworks.com>
+Date: Tue, 24 May 2016 03:04:49 +0300
+Subject: [PATCH 16/20] arm64: signal32: move ilp32 and aarch32 common code to
+ separated file
+
+Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
+---
+ arch/arm64/include/asm/signal32.h        |   3 +
+ arch/arm64/include/asm/signal32_common.h |  27 +++++++
+ arch/arm64/kernel/Makefile               |   2 +-
+ arch/arm64/kernel/signal32.c             | 107 ------------------------
+ arch/arm64/kernel/signal32_common.c      | 135 +++++++++++++++++++++++++++++++
+ 5 files changed, 166 insertions(+), 108 deletions(-)
+ create mode 100644 arch/arm64/include/asm/signal32_common.h
+ create mode 100644 arch/arm64/kernel/signal32_common.c
+
+diff --git a/arch/arm64/include/asm/signal32.h b/arch/arm64/include/asm/signal32.h
+index e68fcce..1c4ede7 100644
+--- a/arch/arm64/include/asm/signal32.h
++++ b/arch/arm64/include/asm/signal32.h
+@@ -13,6 +13,9 @@
+  * You should have received a copy of the GNU General Public License
+  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+  */
++
++#include <asm/signal32_common.h>
++
+ #ifndef __ASM_SIGNAL32_H
+ #define __ASM_SIGNAL32_H
+ 
+diff --git a/arch/arm64/include/asm/signal32_common.h b/arch/arm64/include/asm/signal32_common.h
+new file mode 100644
+index 0000000..36c1ebc
+--- /dev/null
++++ b/arch/arm64/include/asm/signal32_common.h
+@@ -0,0 +1,27 @@
++/*
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
++ */
++#ifndef __ASM_SIGNAL32_COMMON_H
++#define __ASM_SIGNAL32_COMMON_H
++
++#ifdef CONFIG_COMPAT
++
++int copy_siginfo_to_user32(compat_siginfo_t __user *to, const siginfo_t *from);
++int copy_siginfo_from_user32(siginfo_t *to, compat_siginfo_t __user *from);
++
++int put_sigset_t(compat_sigset_t __user *uset, sigset_t *set);
++int get_sigset_t(sigset_t *set, const compat_sigset_t __user *uset);
++
++#endif /* CONFIG_COMPAT*/
++
++#endif /* __ASM_SIGNAL32_COMMON_H */
+diff --git a/arch/arm64/kernel/Makefile b/arch/arm64/kernel/Makefile
+index 9939e37..c569bf8 100644
+--- a/arch/arm64/kernel/Makefile
++++ b/arch/arm64/kernel/Makefile
+@@ -29,7 +29,7 @@ arm64-obj-$(CONFIG_AARCH32_EL0)		+= sys32.o kuser32.o signal32.o 	\
+ 					   sys_compat.o entry32.o binfmt_elf32.o\
+ 					   ../../arm/kernel/opcodes.o
+ arm64-obj-$(CONFIG_ARM64_ILP32)		+= binfmt_ilp32.o sys_ilp32.o
+-arm64-obj-$(CONFIG_COMPAT)		+= entry32_common.o
++arm64-obj-$(CONFIG_COMPAT)		+= entry32_common.o signal32_common.o
+ arm64-obj-$(CONFIG_FUNCTION_TRACER)	+= ftrace.o entry-ftrace.o
+ arm64-obj-$(CONFIG_MODULES)		+= arm64ksyms.o module.o
+ arm64-obj-$(CONFIG_PERF_EVENTS)		+= perf_regs.o perf_callchain.o
+diff --git a/arch/arm64/kernel/signal32.c b/arch/arm64/kernel/signal32.c
+index 71ef6dc..4593cfb 100644
+--- a/arch/arm64/kernel/signal32.c
++++ b/arch/arm64/kernel/signal32.c
+@@ -103,113 +103,6 @@ struct compat_rt_sigframe {
+ 
+ #define _BLOCKABLE (~(sigmask(SIGKILL) | sigmask(SIGSTOP)))
+ 
+-static inline int put_sigset_t(compat_sigset_t __user *uset, sigset_t *set)
+-{
+-	compat_sigset_t	cset;
+-
+-	cset.sig[0] = set->sig[0] & 0xffffffffull;
+-	cset.sig[1] = set->sig[0] >> 32;
+-
+-	return copy_to_user(uset, &cset, sizeof(*uset));
+-}
+-
+-static inline int get_sigset_t(sigset_t *set,
+-			       const compat_sigset_t __user *uset)
+-{
+-	compat_sigset_t s32;
+-
+-	if (copy_from_user(&s32, uset, sizeof(*uset)))
+-		return -EFAULT;
+-
+-	set->sig[0] = s32.sig[0] | (((long)s32.sig[1]) << 32);
+-	return 0;
+-}
+-
+-int copy_siginfo_to_user32(compat_siginfo_t __user *to, const siginfo_t *from)
+-{
+-	int err;
+-
+-	if (!access_ok(VERIFY_WRITE, to, sizeof(*to)))
+-		return -EFAULT;
+-
+-	/* If you change siginfo_t structure, please be sure
+-	 * this code is fixed accordingly.
+-	 * It should never copy any pad contained in the structure
+-	 * to avoid security leaks, but must copy the generic
+-	 * 3 ints plus the relevant union member.
+-	 * This routine must convert siginfo from 64bit to 32bit as well
+-	 * at the same time.
+-	 */
+-	err = __put_user(from->si_signo, &to->si_signo);
+-	err |= __put_user(from->si_errno, &to->si_errno);
+-	err |= __put_user((short)from->si_code, &to->si_code);
+-	if (from->si_code < 0)
+-		err |= __copy_to_user(&to->_sifields._pad, &from->_sifields._pad,
+-				      SI_PAD_SIZE);
+-	else switch (from->si_code & __SI_MASK) {
+-	case __SI_KILL:
+-		err |= __put_user(from->si_pid, &to->si_pid);
+-		err |= __put_user(from->si_uid, &to->si_uid);
+-		break;
+-	case __SI_TIMER:
+-		 err |= __put_user(from->si_tid, &to->si_tid);
+-		 err |= __put_user(from->si_overrun, &to->si_overrun);
+-		 err |= __put_user(from->si_int, &to->si_int);
+-		break;
+-	case __SI_POLL:
+-		err |= __put_user(from->si_band, &to->si_band);
+-		err |= __put_user(from->si_fd, &to->si_fd);
+-		break;
+-	case __SI_FAULT:
+-		err |= __put_user((compat_uptr_t)(unsigned long)from->si_addr,
+-				  &to->si_addr);
+-#ifdef BUS_MCEERR_AO
+-		/*
+-		 * Other callers might not initialize the si_lsb field,
+-		 * so check explicitely for the right codes here.
+-		 */
+-		if (from->si_signo == SIGBUS &&
+-		    (from->si_code == BUS_MCEERR_AR || from->si_code == BUS_MCEERR_AO))
+-			err |= __put_user(from->si_addr_lsb, &to->si_addr_lsb);
+-#endif
+-		break;
+-	case __SI_CHLD:
+-		err |= __put_user(from->si_pid, &to->si_pid);
+-		err |= __put_user(from->si_uid, &to->si_uid);
+-		err |= __put_user(from->si_status, &to->si_status);
+-		err |= __put_user(from->si_utime, &to->si_utime);
+-		err |= __put_user(from->si_stime, &to->si_stime);
+-		break;
+-	case __SI_RT: /* This is not generated by the kernel as of now. */
+-	case __SI_MESGQ: /* But this is */
+-		err |= __put_user(from->si_pid, &to->si_pid);
+-		err |= __put_user(from->si_uid, &to->si_uid);
+-		err |= __put_user(from->si_int, &to->si_int);
+-		break;
+-	case __SI_SYS:
+-		err |= __put_user((compat_uptr_t)(unsigned long)
+-				from->si_call_addr, &to->si_call_addr);
+-		err |= __put_user(from->si_syscall, &to->si_syscall);
+-		err |= __put_user(from->si_arch, &to->si_arch);
+-		break;
+-	default: /* this is just in case for now ... */
+-		err |= __put_user(from->si_pid, &to->si_pid);
+-		err |= __put_user(from->si_uid, &to->si_uid);
+-		break;
+-	}
+-	return err;
+-}
+-
+-int copy_siginfo_from_user32(siginfo_t *to, compat_siginfo_t __user *from)
+-{
+-	if (copy_from_user(to, from, __ARCH_SI_PREAMBLE_SIZE) ||
+-	    copy_from_user(to->_sifields._pad,
+-			   from->_sifields._pad, SI_PAD_SIZE))
+-		return -EFAULT;
+-
+-	return 0;
+-}
+-
+ /*
+  * VFP save/restore code.
+  *
+diff --git a/arch/arm64/kernel/signal32_common.c b/arch/arm64/kernel/signal32_common.c
+new file mode 100644
+index 0000000..06f0258
+--- /dev/null
++++ b/arch/arm64/kernel/signal32_common.c
+@@ -0,0 +1,135 @@
++/*
++ * Based on arch/arm/kernel/signal.c
++ *
++ * Copyright (C) 1995-2009 Russell King
++ * Copyright (C) 2012 ARM Ltd.
++ * Modified by Will Deacon <will.deacon@arm.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
++ */
++
++#include <linux/compat.h>
++#include <linux/signal.h>
++#include <linux/ratelimit.h>
++
++#include <asm/esr.h>
++#include <asm/fpsimd.h>
++#include <asm/signal32_common.h>
++#include <asm/uaccess.h>
++#include <asm/unistd.h>
++
++int put_sigset_t(compat_sigset_t __user *uset, sigset_t *set)
++{
++	compat_sigset_t	cset;
++
++	cset.sig[0] = set->sig[0] & 0xffffffffull;
++	cset.sig[1] = set->sig[0] >> 32;
++
++	return copy_to_user(uset, &cset, sizeof(*uset));
++}
++
++int get_sigset_t(sigset_t *set, const compat_sigset_t __user *uset)
++{
++	compat_sigset_t s32;
++
++	if (copy_from_user(&s32, uset, sizeof(*uset)))
++		return -EFAULT;
++
++	set->sig[0] = s32.sig[0] | (((long)s32.sig[1]) << 32);
++	return 0;
++}
++
++int copy_siginfo_to_user32(compat_siginfo_t __user *to, const siginfo_t *from)
++{
++	int err;
++
++	if (!access_ok(VERIFY_WRITE, to, sizeof(*to)))
++		return -EFAULT;
++
++	/* If you change siginfo_t structure, please be sure
++	 * this code is fixed accordingly.
++	 * It should never copy any pad contained in the structure
++	 * to avoid security leaks, but must copy the generic
++	 * 3 ints plus the relevant union member.
++	 * This routine must convert siginfo from 64bit to 32bit as well
++	 * at the same time.
++	 */
++	err = __put_user(from->si_signo, &to->si_signo);
++	err |= __put_user(from->si_errno, &to->si_errno);
++	err |= __put_user((short)from->si_code, &to->si_code);
++	if (from->si_code < 0)
++		err |= __copy_to_user(&to->_sifields._pad, &from->_sifields._pad,
++				      SI_PAD_SIZE);
++	else switch (from->si_code & __SI_MASK) {
++	case __SI_KILL:
++		err |= __put_user(from->si_pid, &to->si_pid);
++		err |= __put_user(from->si_uid, &to->si_uid);
++		break;
++	case __SI_TIMER:
++		 err |= __put_user(from->si_tid, &to->si_tid);
++		 err |= __put_user(from->si_overrun, &to->si_overrun);
++		 err |= __put_user(from->si_int, &to->si_int);
++		break;
++	case __SI_POLL:
++		err |= __put_user(from->si_band, &to->si_band);
++		err |= __put_user(from->si_fd, &to->si_fd);
++		break;
++	case __SI_FAULT:
++		err |= __put_user((compat_uptr_t)(unsigned long)from->si_addr,
++				  &to->si_addr);
++#ifdef BUS_MCEERR_AO
++		/*
++		 * Other callers might not initialize the si_lsb field,
++		 * so check explicitly for the right codes here.
++		 */
++		if (from->si_signo == SIGBUS &&
++		    (from->si_code == BUS_MCEERR_AR || from->si_code == BUS_MCEERR_AO))
++			err |= __put_user(from->si_addr_lsb, &to->si_addr_lsb);
++#endif
++		break;
++	case __SI_CHLD:
++		err |= __put_user(from->si_pid, &to->si_pid);
++		err |= __put_user(from->si_uid, &to->si_uid);
++		err |= __put_user(from->si_status, &to->si_status);
++		err |= __put_user(from->si_utime, &to->si_utime);
++		err |= __put_user(from->si_stime, &to->si_stime);
++		break;
++	case __SI_RT: /* This is not generated by the kernel as of now. */
++	case __SI_MESGQ: /* But this is */
++		err |= __put_user(from->si_pid, &to->si_pid);
++		err |= __put_user(from->si_uid, &to->si_uid);
++		err |= __put_user(from->si_int, &to->si_int);
++		break;
++	case __SI_SYS:
++		err |= __put_user((compat_uptr_t)(unsigned long)
++				from->si_call_addr, &to->si_call_addr);
++		err |= __put_user(from->si_syscall, &to->si_syscall);
++		err |= __put_user(from->si_arch, &to->si_arch);
++		break;
++	default: /* this is just in case for now ... */
++		err |= __put_user(from->si_pid, &to->si_pid);
++		err |= __put_user(from->si_uid, &to->si_uid);
++		break;
++	}
++	return err;
++}
++
++int copy_siginfo_from_user32(siginfo_t *to, compat_siginfo_t __user *from)
++{
++	if (copy_from_user(to, from, __ARCH_SI_PREAMBLE_SIZE) ||
++	    copy_from_user(to->_sifields._pad,
++			   from->_sifields._pad, SI_PAD_SIZE))
++		return -EFAULT;
++
++	return 0;
++}
+-- 
+2.5.0
+
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0017-arm64-ilp32-introduce-ilp32-specific-handlers-for-si.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0017-arm64-ilp32-introduce-ilp32-specific-handlers-for-si.patch
new file mode 100644
index 0000000..7bb634b
--- /dev/null
+++ b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0017-arm64-ilp32-introduce-ilp32-specific-handlers-for-si.patch
@@ -0,0 +1,309 @@
+From bb4328a31010ba14b16f28ed35851f73f6322d30 Mon Sep 17 00:00:00 2001
+From: Andrew Pinski <apinski@cavium.com>
+Date: Tue, 24 May 2016 03:04:50 +0300
+Subject: [PATCH 17/20] arm64: ilp32: introduce ilp32-specific handlers for
+ sigframe and ucontext
+
+ILP32 uses AARCH32 compat structures and syscall handlers for signals.
+But ILP32 struct rt_sigframe  and ucontext differs from both LP64 and
+AARCH32. So some specific mechanism is needed to take care of it.
+
+Signed-off-by: Andrew Pinski <Andrew.Pinski@caviumnetworks.com>
+Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
+---
+ arch/arm64/include/asm/signal_ilp32.h |  38 ++++++++
+ arch/arm64/kernel/Makefile            |   3 +-
+ arch/arm64/kernel/entry_ilp32.S       |  22 +++++
+ arch/arm64/kernel/signal.c            |   3 +
+ arch/arm64/kernel/signal_ilp32.c      | 170 ++++++++++++++++++++++++++++++++++
+ 5 files changed, 235 insertions(+), 1 deletion(-)
+ create mode 100644 arch/arm64/include/asm/signal_ilp32.h
+ create mode 100644 arch/arm64/kernel/entry_ilp32.S
+ create mode 100644 arch/arm64/kernel/signal_ilp32.c
+
+diff --git a/arch/arm64/include/asm/signal_ilp32.h b/arch/arm64/include/asm/signal_ilp32.h
+new file mode 100644
+index 0000000..3c6d737
+--- /dev/null
++++ b/arch/arm64/include/asm/signal_ilp32.h
+@@ -0,0 +1,38 @@
++/*
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
++ */
++
++#include <asm/signal32_common.h>
++#include <asm/signal_common.h>
++
++#ifndef __ASM_SIGNAL_ILP32_H
++#define __ASM_SIGNAL_ILP32_H
++
++#ifdef CONFIG_ARM64_ILP32
++
++#include <linux/compat.h>
++
++int ilp32_setup_rt_frame(int usig, struct ksignal *ksig, sigset_t *set,
++			  struct pt_regs *regs);
++
++#else
++
++static inline int ilp32_setup_rt_frame(int usig, struct ksignal *ksig, sigset_t *set,
++			  struct pt_regs *regs)
++{
++	return -ENOSYS;
++}
++
++#endif /* CONFIG_ARM64_ILP32 */
++
++#endif /* __ASM_SIGNAL_ILP32_H */
+diff --git a/arch/arm64/kernel/Makefile b/arch/arm64/kernel/Makefile
+index c569bf8..566454c 100644
+--- a/arch/arm64/kernel/Makefile
++++ b/arch/arm64/kernel/Makefile
+@@ -28,7 +28,8 @@ $(obj)/%.stub.o: $(obj)/%.o FORCE
+ arm64-obj-$(CONFIG_AARCH32_EL0)		+= sys32.o kuser32.o signal32.o 	\
+ 					   sys_compat.o entry32.o binfmt_elf32.o\
+ 					   ../../arm/kernel/opcodes.o
+-arm64-obj-$(CONFIG_ARM64_ILP32)		+= binfmt_ilp32.o sys_ilp32.o
++arm64-obj-$(CONFIG_ARM64_ILP32)		+= binfmt_ilp32.o sys_ilp32.o 		\
++					   signal_ilp32.o entry_ilp32.o
+ arm64-obj-$(CONFIG_COMPAT)		+= entry32_common.o signal32_common.o
+ arm64-obj-$(CONFIG_FUNCTION_TRACER)	+= ftrace.o entry-ftrace.o
+ arm64-obj-$(CONFIG_MODULES)		+= arm64ksyms.o module.o
+diff --git a/arch/arm64/kernel/entry_ilp32.S b/arch/arm64/kernel/entry_ilp32.S
+new file mode 100644
+index 0000000..a8bb94b
+--- /dev/null
++++ b/arch/arm64/kernel/entry_ilp32.S
+@@ -0,0 +1,22 @@
++/*
++ * ILP32 system call wrappers
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
++ */
++
++#include <linux/linkage.h>
++
++ENTRY(ilp32_sys_rt_sigreturn_wrapper)
++	mov	x0, sp
++	b	ilp32_sys_rt_sigreturn
++ENDPROC(ilp32_sys_rt_sigreturn_wrapper)
+diff --git a/arch/arm64/kernel/signal.c b/arch/arm64/kernel/signal.c
+index 5244075..f885e4a 100644
+--- a/arch/arm64/kernel/signal.c
++++ b/arch/arm64/kernel/signal.c
+@@ -35,6 +35,7 @@
+ #include <asm/signal32.h>
+ #include <asm/vdso.h>
+ #include <asm/signal_common.h>
++#include <asm/signal_ilp32.h>
+ 
+ #define RT_SIGFRAME_FP_POS (offsetof(struct rt_sigframe, sig)	\
+ 			+ offsetof(struct sigframe, fp))
+@@ -325,6 +326,8 @@ static void handle_signal(struct ksignal *ksig, struct pt_regs *regs)
+ 			ret = compat_setup_rt_frame(usig, ksig, oldset, regs);
+ 		else
+ 			ret = compat_setup_frame(usig, ksig, oldset, regs);
++	} else if (is_ilp32_compat_task()) {
++		ret = ilp32_setup_rt_frame(usig, ksig, oldset, regs);
+ 	} else {
+ 		ret = setup_rt_frame(usig, ksig, oldset, regs);
+ 	}
+diff --git a/arch/arm64/kernel/signal_ilp32.c b/arch/arm64/kernel/signal_ilp32.c
+new file mode 100644
+index 0000000..650f4cb
+--- /dev/null
++++ b/arch/arm64/kernel/signal_ilp32.c
+@@ -0,0 +1,170 @@
++/*
++ * Based on arch/arm/kernel/signal.c
++ *
++ * Copyright (C) 1995-2009 Russell King
++ * Copyright (C) 2012 ARM Ltd.
++ * Copyright (C) 2016 Cavium Networks.
++ * Yury Norov <ynorov@caviumnetworks.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
++ */
++
++#include <linux/compat.h>
++#include <linux/signal.h>
++#include <linux/syscalls.h>
++#include <linux/ratelimit.h>
++
++#include <asm/esr.h>
++#include <asm/fpsimd.h>
++#include <asm/signal_ilp32.h>
++#include <asm/uaccess.h>
++#include <asm/unistd.h>
++#include <asm/ucontext.h>
++
++
++#define ILP32_RT_SIGFRAME_FP_POS (offsetof(struct ilp32_rt_sigframe, sig)	\
++			+ offsetof(struct ilp32_sigframe, fp))
++
++struct ilp32_ucontext {
++	u32		uc_flags;
++	u32		uc_link;
++	compat_stack_t  uc_stack;
++	compat_sigset_t uc_sigmask;
++	/* glibc uses a 1024-bit sigset_t */
++	__u8 __unused[1024 / 8 - sizeof(compat_sigset_t)];
++	/* last for future expansion */
++	struct sigcontext uc_mcontext;
++};
++
++struct ilp32_sigframe {
++	struct ilp32_ucontext uc;
++	u64 fp;
++	u64 lr;
++};
++
++struct ilp32_rt_sigframe {
++	struct compat_siginfo info;
++	struct ilp32_sigframe sig;
++};
++
++static int restore_ilp32_sigframe(struct pt_regs *regs,
++				struct ilp32_sigframe __user *sf)
++{
++	sigset_t set;
++	int err;
++	err = get_sigset_t(&set, &sf->uc.uc_sigmask);
++	if (err == 0)
++		set_current_blocked(&set);
++	err |= restore_sigcontext(regs, &sf->uc.uc_mcontext);
++	return err;
++}
++
++static int setup_ilp32_sigframe(struct ilp32_sigframe __user *sf,
++				struct pt_regs *regs, sigset_t *set)
++{
++	int err = 0;
++	/* set up the stack frame for unwinding */
++	__put_user_error(regs->regs[29], &sf->fp, err);
++	__put_user_error(regs->regs[30], &sf->lr, err);
++
++	err |= put_sigset_t(&sf->uc.uc_sigmask, set);
++	err |= setup_sigcontext(&sf->uc.uc_mcontext, regs);
++	return err;
++}
++
++asmlinkage long ilp32_sys_rt_sigreturn(struct pt_regs *regs)
++{
++	struct ilp32_rt_sigframe __user *frame;
++
++	/* Always make any pending restarted system calls return -EINTR */
++	current->restart_block.fn = do_no_restart_syscall;
++
++	/*
++	 * Since we stacked the signal on a 128-bit boundary,
++	 * then 'sp' should be word aligned here.  If it's
++	 * not, then the user is trying to mess with us.
++	 */
++	if (regs->sp & 15)
++		goto badframe;
++
++	frame = (struct ilp32_rt_sigframe __user *)regs->sp;
++
++	if (!access_ok(VERIFY_READ, frame, sizeof (*frame)))
++		goto badframe;
++
++	if (restore_ilp32_sigframe(regs, &frame->sig))
++		goto badframe;
++
++	if (compat_restore_altstack(&frame->sig.uc.uc_stack))
++		goto badframe;
++
++	return regs->regs[0];
++
++badframe:
++	if (show_unhandled_signals)
++		pr_info_ratelimited("%s[%d]: bad frame in %s: pc=%08llx sp=%08llx\n",
++				current->comm, task_pid_nr(current), __func__,
++				regs->pc, regs->sp);
++	force_sig(SIGSEGV, current);
++	return 0;
++}
++
++static struct ilp32_rt_sigframe __user *ilp32_get_sigframe(struct ksignal *ksig,
++						struct pt_regs *regs)
++{
++	unsigned long sp, sp_top;
++	struct ilp32_rt_sigframe __user *frame;
++
++	sp = sp_top = sigsp(regs->sp, ksig);
++
++	sp = (sp - sizeof(struct ilp32_rt_sigframe)) & ~15;
++	frame = (struct ilp32_rt_sigframe __user *)sp;
++
++	/*
++	 * Check that we can actually write to the signal frame.
++	 */
++	if (!access_ok(VERIFY_WRITE, frame, sp_top - sp))
++		frame = NULL;
++
++	return frame;
++}
++
++/*
++ * ILP32 signal handling routines called from signal.c
++ */
++int ilp32_setup_rt_frame(int usig, struct ksignal *ksig,
++			  sigset_t *set, struct pt_regs *regs)
++{
++	struct ilp32_rt_sigframe __user *frame;
++	int err = 0;
++
++	frame = ilp32_get_sigframe(ksig, regs);
++
++	if (!frame)
++		return 1;
++
++	err |= copy_siginfo_to_user32(&frame->info, &ksig->info);
++
++	__put_user_error(0, &frame->sig.uc.uc_flags, err);
++	__put_user_error(0, &frame->sig.uc.uc_link, err);
++
++	err |= __compat_save_altstack(&frame->sig.uc.uc_stack, regs->sp);
++	err |= setup_ilp32_sigframe(&frame->sig, regs, set);
++	if (err == 0) {
++		setup_return(regs, &ksig->ka, frame, ILP32_RT_SIGFRAME_FP_POS, usig);
++		regs->regs[1] = (unsigned long)&frame->info;
++		regs->regs[2] = (unsigned long)&frame->sig.uc;
++	}
++
++	return err;
++}
+-- 
+2.5.0
+
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0017-arm64-ptrace-handle-ptrace_request-differently-for-a.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0017-arm64-ptrace-handle-ptrace_request-differently-for-a.patch
deleted file mode 100644
index 4a57840..0000000
--- a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0017-arm64-ptrace-handle-ptrace_request-differently-for-a.patch
+++ /dev/null
@@ -1,189 +0,0 @@
-From 315e986a5ad4db96192209b99d2979b24dada966 Mon Sep 17 00:00:00 2001
-From: Yury Norov <ynorov@caviumnetworks.com>
-Date: Tue, 24 May 2016 03:04:46 +0300
-Subject: [PATCH 17/24] arm64: ptrace: handle ptrace_request differently for
- aarch32 and ilp32
-
-Here new aarch32 ptrace syscall handler is introsuced to avoid run-time
-detection of the task type.
-
-Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
----
- arch/arm64/include/asm/unistd32.h |  2 +-
- arch/arm64/kernel/ptrace.c        | 50 ++++++++++++++++++++++++++++++++++++++-
- arch/arm64/kernel/sys32.c         |  1 +
- include/linux/ptrace.h            |  6 +++++
- kernel/ptrace.c                   | 10 ++++----
- 5 files changed, 62 insertions(+), 7 deletions(-)
-
-diff --git a/arch/arm64/include/asm/unistd32.h b/arch/arm64/include/asm/unistd32.h
-index 5b925b7..f57bbe3 100644
---- a/arch/arm64/include/asm/unistd32.h
-+++ b/arch/arm64/include/asm/unistd32.h
-@@ -74,7 +74,7 @@ __SYSCALL(__NR_getuid, sys_getuid16)
- 			/* 25 was sys_stime */
- __SYSCALL(25, sys_ni_syscall)
- #define __NR_ptrace 26
--__SYSCALL(__NR_ptrace, compat_sys_ptrace)
-+__SYSCALL(__NR_ptrace, compat_sys_aarch32_ptrace)
- 			/* 27 was sys_alarm */
- __SYSCALL(27, sys_ni_syscall)
- 			/* 28 was sys_fstat */
-diff --git a/arch/arm64/kernel/ptrace.c b/arch/arm64/kernel/ptrace.c
-index 39d333c..6083919 100644
---- a/arch/arm64/kernel/ptrace.c
-+++ b/arch/arm64/kernel/ptrace.c
-@@ -29,6 +29,7 @@
- #include <linux/user.h>
- #include <linux/seccomp.h>
- #include <linux/security.h>
-+#include <linux/syscalls.h>
- #include <linux/init.h>
- #include <linux/signal.h>
- #include <linux/uaccess.h>
-@@ -1114,7 +1115,7 @@ static int compat_ptrace_sethbpregs(struct task_struct *tsk, compat_long_t num,
- }
- #endif	/* CONFIG_HAVE_HW_BREAKPOINT */
- 
--long compat_arch_ptrace(struct task_struct *child, compat_long_t request,
-+static long compat_a32_ptrace(struct task_struct *child, compat_long_t request,
- 			compat_ulong_t caddr, compat_ulong_t cdata)
- {
- 	unsigned long addr = caddr;
-@@ -1191,8 +1192,55 @@ long compat_arch_ptrace(struct task_struct *child, compat_long_t request,
- 
- 	return ret;
- }
-+
-+COMPAT_SYSCALL_DEFINE4(aarch32_ptrace, compat_long_t, request, compat_long_t, pid,
-+		       compat_long_t, addr, compat_long_t, data)
-+{
-+	struct task_struct *child;
-+	long ret;
-+
-+	if (request == PTRACE_TRACEME) {
-+		ret = ptrace_traceme();
-+		goto out;
-+	}
-+
-+	child = ptrace_get_task_struct(pid);
-+	if (IS_ERR(child)) {
-+		ret = PTR_ERR(child);
-+		goto out;
-+	}
-+
-+	if (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {
-+		ret = ptrace_attach(child, request, addr, data);
-+		goto out_put_task_struct;
-+	}
-+
-+	ret = ptrace_check_attach(child, request == PTRACE_KILL ||
-+				  request == PTRACE_INTERRUPT);
-+	if (!ret) {
-+		ret = compat_a32_ptrace(child, request, addr, data);
-+		if (ret || request != PTRACE_DETACH)
-+			ptrace_unfreeze_traced(child);
-+	}
-+
-+ out_put_task_struct:
-+	put_task_struct(child);
-+ out:
-+	return ret;
-+}
-+
- #endif /* CONFIG_AARCH32_EL0 */
- 
-+#ifdef CONFIG_COMPAT
-+
-+long compat_arch_ptrace(struct task_struct *child, compat_long_t request,
-+			compat_ulong_t caddr, compat_ulong_t cdata)
-+{
-+	return compat_ptrace_request(child, request, caddr, cdata);
-+}
-+
-+#endif /* CONFIG_COMPAT */
-+
- const struct user_regset_view *task_user_regset_view(struct task_struct *task)
- {
- #ifdef CONFIG_AARCH32_EL0
-diff --git a/arch/arm64/kernel/sys32.c b/arch/arm64/kernel/sys32.c
-index a40b134..3752443 100644
---- a/arch/arm64/kernel/sys32.c
-+++ b/arch/arm64/kernel/sys32.c
-@@ -38,6 +38,7 @@ asmlinkage long compat_sys_fadvise64_64_wrapper(void);
- asmlinkage long compat_sys_sync_file_range2_wrapper(void);
- asmlinkage long compat_sys_fallocate_wrapper(void);
- asmlinkage long compat_sys_mmap2_wrapper(void);
-+asmlinkage long compat_sys_aarch32_ptrace(void);
- 
- #undef __SYSCALL
- #define __SYSCALL(nr, sym)	[nr] = sym,
-diff --git a/include/linux/ptrace.h b/include/linux/ptrace.h
-index 504c98a..75887a0 100644
---- a/include/linux/ptrace.h
-+++ b/include/linux/ptrace.h
-@@ -97,6 +97,12 @@ int generic_ptrace_peekdata(struct task_struct *tsk, unsigned long addr,
- 			    unsigned long data);
- int generic_ptrace_pokedata(struct task_struct *tsk, unsigned long addr,
- 			    unsigned long data);
-+int ptrace_traceme(void);
-+struct task_struct *ptrace_get_task_struct(pid_t pid);
-+int ptrace_attach(struct task_struct *task, long request,
-+			 unsigned long addr, unsigned long flags);
-+int ptrace_check_attach(struct task_struct *child, bool ignore_state);
-+void ptrace_unfreeze_traced(struct task_struct *task);
- 
- /**
-  * ptrace_parent - return the task that is tracing the given task
-diff --git a/kernel/ptrace.c b/kernel/ptrace.c
-index 32462e6..bcebc23 100644
---- a/kernel/ptrace.c
-+++ b/kernel/ptrace.c
-@@ -137,7 +137,7 @@ static bool ptrace_freeze_traced(struct task_struct *task)
- 	return ret;
- }
- 
--static void ptrace_unfreeze_traced(struct task_struct *task)
-+void ptrace_unfreeze_traced(struct task_struct *task)
- {
- 	if (task->state != __TASK_TRACED)
- 		return;
-@@ -169,7 +169,7 @@ static void ptrace_unfreeze_traced(struct task_struct *task)
-  * RETURNS:
-  * 0 on success, -ESRCH if %child is not ready.
-  */
--static int ptrace_check_attach(struct task_struct *child, bool ignore_state)
-+int ptrace_check_attach(struct task_struct *child, bool ignore_state)
- {
- 	int ret = -ESRCH;
- 
-@@ -313,7 +313,7 @@ bool ptrace_may_access(struct task_struct *task, unsigned int mode)
- 	return !err;
- }
- 
--static int ptrace_attach(struct task_struct *task, long request,
-+int ptrace_attach(struct task_struct *task, long request,
- 			 unsigned long addr,
- 			 unsigned long flags)
- {
-@@ -421,7 +421,7 @@ out:
-  * Performs checks and sets PT_PTRACED.
-  * Should be used by all ptrace implementations for PTRACE_TRACEME.
-  */
--static int ptrace_traceme(void)
-+ int ptrace_traceme(void)
- {
- 	int ret = -EPERM;
- 
-@@ -1071,7 +1071,7 @@ int ptrace_request(struct task_struct *child, long request,
- 	return ret;
- }
- 
--static struct task_struct *ptrace_get_task_struct(pid_t pid)
-+struct task_struct *ptrace_get_task_struct(pid_t pid)
- {
- 	struct task_struct *child;
- 
--- 
-1.9.1
-
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0018-arm64-ilp32-add-sys_ilp32.c-and-a-separate-table-in-.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0018-arm64-ilp32-add-sys_ilp32.c-and-a-separate-table-in-.patch
deleted file mode 100644
index a5f653f..0000000
--- a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0018-arm64-ilp32-add-sys_ilp32.c-and-a-separate-table-in-.patch
+++ /dev/null
@@ -1,183 +0,0 @@
-From d030646ecf2971ee254271b87d79fcd305d9ce76 Mon Sep 17 00:00:00 2001
-From: Andrew Pinski <apinski@cavium.com>
-Date: Tue, 24 May 2016 03:04:47 +0300
-Subject: [PATCH 18/24] arm64: ilp32: add sys_ilp32.c and a separate table (in
- entry.S) to use it
-
-Add a separate syscall-table for ILP32, which dispatches either to native
-LP64 system call implementation or to compat-syscalls, as appropriate.
-
-Signed-off-by: Andrew Pinski <Andrew.Pinski@caviumnetworks.com>
-Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
----
- arch/arm64/include/asm/unistd.h | 11 +++++-
- arch/arm64/kernel/Makefile      |  2 +-
- arch/arm64/kernel/entry.S       | 10 ++++-
- arch/arm64/kernel/sys_ilp32.c   | 83 +++++++++++++++++++++++++++++++++++++++++
- 4 files changed, 102 insertions(+), 4 deletions(-)
- create mode 100644 arch/arm64/kernel/sys_ilp32.c
-
-diff --git a/arch/arm64/include/asm/unistd.h b/arch/arm64/include/asm/unistd.h
-index 2971dea..5ea18ef 100644
---- a/arch/arm64/include/asm/unistd.h
-+++ b/arch/arm64/include/asm/unistd.h
-@@ -13,9 +13,18 @@
-  * You should have received a copy of the GNU General Public License
-  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
-  */
-+
-+#ifdef CONFIG_COMPAT
-+#define __ARCH_WANT_COMPAT_STAT64
-+#endif
-+
-+#ifdef CONFIG_ARM64_ILP32
-+#define __ARCH_WANT_COMPAT_SYS_PREADV64
-+#define __ARCH_WANT_COMPAT_SYS_PWRITEV64
-+#endif
-+
- #ifdef CONFIG_AARCH32_EL0
- #define __ARCH_WANT_COMPAT_SYS_GETDENTS64
--#define __ARCH_WANT_COMPAT_STAT64
- #define __ARCH_WANT_SYS_GETHOSTNAME
- #define __ARCH_WANT_SYS_PAUSE
- #define __ARCH_WANT_SYS_GETPGRP
-diff --git a/arch/arm64/kernel/Makefile b/arch/arm64/kernel/Makefile
-index 4cc81da..b0adab7 100644
---- a/arch/arm64/kernel/Makefile
-+++ b/arch/arm64/kernel/Makefile
-@@ -28,7 +28,7 @@ $(obj)/%.stub.o: $(obj)/%.o FORCE
- arm64-obj-$(CONFIG_AARCH32_EL0)		+= sys32.o kuser32.o signal32.o 	\
- 					   sys_compat.o entry32.o		\
- 					   ../../arm/kernel/opcodes.o binfmt_elf32.o
--arm64-obj-$(CONFIG_ARM64_ILP32)		+= binfmt_ilp32.o
-+arm64-obj-$(CONFIG_ARM64_ILP32)		+= binfmt_ilp32.o sys_ilp32.o
- arm64-obj-$(CONFIG_FUNCTION_TRACER)	+= ftrace.o entry-ftrace.o
- arm64-obj-$(CONFIG_MODULES)		+= arm64ksyms.o module.o
- arm64-obj-$(CONFIG_PERF_EVENTS)		+= perf_regs.o perf_callchain.o
-diff --git a/arch/arm64/kernel/entry.S b/arch/arm64/kernel/entry.S
-index 5eb1bb7..8a951b1 100644
---- a/arch/arm64/kernel/entry.S
-+++ b/arch/arm64/kernel/entry.S
-@@ -452,6 +452,7 @@ el0_svc_compat:
- 	 * AArch32 syscall handling
- 	 */
- 	adrp	stbl, compat_sys_call_table	// load compat syscall table pointer
-+	ldr     x16, [tsk, #TI_FLAGS]
- 	uxtw	scno, w7			// syscall number in w7 (r7)
- 	mov     sc_nr, #__NR_compat_syscalls
- 	b	el0_svc_naked
-@@ -667,15 +668,20 @@ ENDPROC(ret_from_fork)
- 	.align	6
- el0_svc:
- 	adrp	stbl, sys_call_table		// load syscall table pointer
-+	ldr	x16, [tsk, #TI_FLAGS]
- 	uxtw	scno, w8			// syscall number in w8
- 	mov	sc_nr, #__NR_syscalls
-+#ifdef CONFIG_ARM64_ILP32
-+	adrp	x17, sys_call_ilp32_table	// load ilp32 syscall table pointer
-+	tst	x16, #_TIF_32BIT_AARCH64
-+	csel    stbl, stbl, x17, eq		// We are using ILP32
-+#endif
- el0_svc_naked:					// compat entry point
- 	stp	x0, scno, [sp, #S_ORIG_X0]	// save the original x0 and syscall number
- 	enable_dbg_and_irq
- 	ct_user_exit 1
- 
--	ldr	x16, [tsk, #TI_FLAGS]		// check for syscall hooks
--	tst	x16, #_TIF_SYSCALL_WORK
-+	tst	x16, #_TIF_SYSCALL_WORK		// check for syscall hooks
- 	b.ne	__sys_trace
- 	cmp     scno, sc_nr                     // check upper syscall limit
- 	b.hs	ni_sys
-diff --git a/arch/arm64/kernel/sys_ilp32.c b/arch/arm64/kernel/sys_ilp32.c
-new file mode 100644
-index 0000000..d4cd2a9
---- /dev/null
-+++ b/arch/arm64/kernel/sys_ilp32.c
-@@ -0,0 +1,83 @@
-+/*
-+ * AArch64- ILP32 specific system calls implementation
-+ *
-+ * Copyright (C) 2016 Cavium Inc.
-+ * Author: Andrew Pinski <apinski@cavium.com>
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License version 2 as
-+ * published by the Free Software Foundation.
-+ *
-+ * This program is distributed in the hope that it will be useful,
-+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-+ * GNU General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
-+ */
-+
-+#define __SYSCALL_COMPAT
-+
-+#include <linux/compiler.h>
-+#include <linux/errno.h>
-+#include <linux/fs.h>
-+#include <linux/mm.h>
-+#include <linux/msg.h>
-+#include <linux/export.h>
-+#include <linux/sched.h>
-+#include <linux/slab.h>
-+#include <linux/syscalls.h>
-+#include <linux/compat.h>
-+#include <asm-generic/syscalls.h>
-+
-+/* Using non-compat syscalls where necessary */
-+#define compat_sys_fadvise64_64		sys_fadvise64_64
-+#define compat_sys_fallocate		sys_fallocate
-+#define compat_sys_ftruncate64		sys_ftruncate
-+#define compat_sys_lookup_dcookie	sys_lookup_dcookie
-+#define compat_sys_readahead		sys_readahead
-+#define compat_sys_shmat		sys_shmat
-+#define compat_sys_sync_file_range	sys_sync_file_range
-+#define compat_sys_truncate64		sys_truncate
-+#define sys_llseek			sys_lseek
-+#define sys_mmap2			compat_sys_mmap2
-+
-+static unsigned long compat_sys_mmap2(compat_uptr_t addr, compat_size_t len,
-+       int prot, int flags, int fd, off_t pgoff)
-+{
-+       if (pgoff & (~PAGE_MASK >> 12))
-+               return -EINVAL;
-+
-+       return sys_mmap_pgoff(addr, len, prot, flags, fd,
-+		       pgoff >> (PAGE_SHIFT - 12));
-+}
-+
-+static unsigned long compat_sys_pread64(unsigned int fd,
-+		compat_uptr_t __user *ubuf, compat_size_t count, off_t offset)
-+{
-+	return sys_pread64(fd, (char *) ubuf, count, offset);
-+}
-+
-+static unsigned long compat_sys_pwrite64(unsigned int fd,
-+		compat_uptr_t __user *ubuf, compat_size_t count, off_t offset)
-+{
-+	return sys_pwrite64(fd, (char *) ubuf, count, offset);
-+}
-+
-+#include <asm/syscall.h>
-+
-+#undef __SYSCALL
-+#undef __SC_WRAP
-+
-+#define __SYSCALL(nr, sym)	[nr] = sym,
-+#define __SC_WRAP(nr, sym)	[nr] = compat_##sym,
-+
-+/*
-+ * The sys_call_ilp32_table array must be 4K aligned to be accessible from
-+ * kernel/entry.S.
-+ */
-+void *sys_call_ilp32_table[__NR_syscalls] __aligned(4096) = {
-+	[0 ... __NR_syscalls - 1] = sys_ni_syscall,
-+#include <asm/unistd.h>
-+};
--- 
-1.9.1
-
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0018-arm64-ptrace-handle-ptrace_request-differently-for-a.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0018-arm64-ptrace-handle-ptrace_request-differently-for-a.patch
new file mode 100644
index 0000000..585d586
--- /dev/null
+++ b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0018-arm64-ptrace-handle-ptrace_request-differently-for-a.patch
@@ -0,0 +1,119 @@
+From a10c3927aca4c9423809aeb9daed58b8afabe7fa Mon Sep 17 00:00:00 2001
+From: Yury Norov <ynorov@caviumnetworks.com>
+Date: Thu, 5 Jan 2017 16:14:48 +0530
+Subject: [PATCH 18/20] arm64: ptrace: handle ptrace_request differently for
+ aarch32 and ilp32
+
+ILP32 has context-related structures different from both aarch32 and
+aarch64/lp64. In this patch compat_arch_ptrace() renamed to
+compat_a32_ptrace(), and compat_arch_ptrace() only makes choice between
+compat_a32_ptrace() and new compat_ilp32_ptrace() handler.
+
+compat_ilp32_ptrace() calls generic compat_ptrace_request() for all
+requests except PTRACE_GETSIGMASK and PTRACE_SETSIGMASK, which need
+special handling.
+
+Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
+Signed-off-by: Bamvor Jian Zhang <bamvor.zhangjian@linaro.org>
+Signed-off-by: Chengming Zhou <zhouchengming1@huawei.com>
+---
+ arch/arm64/kernel/ptrace.c | 65 ++++++++++++++++++++++++++++++++++++++++++++--
+ 1 file changed, 63 insertions(+), 2 deletions(-)
+
+diff --git a/arch/arm64/kernel/ptrace.c b/arch/arm64/kernel/ptrace.c
+index 2b644c9..9c2d5be 100644
+--- a/arch/arm64/kernel/ptrace.c
++++ b/arch/arm64/kernel/ptrace.c
+@@ -657,9 +657,11 @@ static const struct user_regset_view user_aarch64_view = {
+ 	.regsets = aarch64_regsets, .n = ARRAY_SIZE(aarch64_regsets)
+ };
+ 
+-#ifdef CONFIG_AARCH32_EL0
++#ifdef CONFIG_COMPAT
+ #include <linux/compat.h>
++#endif
+ 
++#ifdef CONFIG_AARCH32_EL0
+ enum compat_regset {
+ 	REGSET_COMPAT_GPR,
+ 	REGSET_COMPAT_VFP,
+@@ -1115,7 +1117,7 @@ static int compat_ptrace_sethbpregs(struct task_struct *tsk, compat_long_t num,
+ }
+ #endif	/* CONFIG_HAVE_HW_BREAKPOINT */
+ 
+-long compat_arch_ptrace(struct task_struct *child, compat_long_t request,
++static long compat_a32_ptrace(struct task_struct *child, compat_long_t request,
+ 			compat_ulong_t caddr, compat_ulong_t cdata)
+ {
+ 	unsigned long addr = caddr;
+@@ -1192,8 +1194,67 @@ long compat_arch_ptrace(struct task_struct *child, compat_long_t request,
+ 
+ 	return ret;
+ }
++
++#else
++#define  compat_a32_ptrace(child, request, caddr, cdata)	(0)
+ #endif /* CONFIG_AARCH32_EL0 */
+ 
++#ifdef CONFIG_ARM64_ILP32
++#include <asm/signal32_common.h>
++
++static long compat_ilp32_ptrace(struct task_struct *child, compat_long_t request,
++			compat_ulong_t caddr, compat_ulong_t cdata)
++{
++	sigset_t new_set;
++
++	switch (request) {
++	case PTRACE_GETSIGMASK:
++		if (caddr != sizeof(compat_sigset_t))
++			return -EINVAL;
++
++		return put_sigset_t((compat_sigset_t __user *) (u64) cdata,
++					&child->blocked);
++
++	case PTRACE_SETSIGMASK:
++		if (caddr != sizeof(compat_sigset_t))
++			return -EINVAL;
++
++		if (get_sigset_t(&new_set, (compat_sigset_t __user *) (u64) cdata))
++			return -EFAULT;
++
++		sigdelsetmask(&new_set, sigmask(SIGKILL)|sigmask(SIGSTOP));
++
++		/*
++		 * Every thread does recalc_sigpending() after resume, so
++		 * retarget_shared_pending() and recalc_sigpending() are not
++		 * called here.
++		 */
++		spin_lock_irq(&child->sighand->siglock);
++		child->blocked = new_set;
++		spin_unlock_irq(&child->sighand->siglock);
++
++		return 0;
++
++	default:
++		return compat_ptrace_request(child, request, caddr, cdata);
++	}
++}
++
++#else
++#define compat_ilp32_ptrace(child, request, caddr, cdata)	(0)
++#endif
++
++#ifdef CONFIG_COMPAT
++long compat_arch_ptrace(struct task_struct *child, compat_long_t request,
++			compat_ulong_t caddr, compat_ulong_t cdata)
++{
++	if (is_a32_compat_task())
++		return compat_a32_ptrace(child, request, caddr, cdata);
++
++	return compat_ilp32_ptrace(child, request, caddr, cdata);
++}
++#endif
++
+ const struct user_regset_view *task_user_regset_view(struct task_struct *task)
+ {
+ #ifdef CONFIG_AARCH32_EL0
+-- 
+2.5.0
+
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0019-arm64-ilp32-add-vdso-ilp32-and-use-for-signal-return.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0019-arm64-ilp32-add-vdso-ilp32-and-use-for-signal-return.patch
new file mode 100644
index 0000000..a968f96
--- /dev/null
+++ b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0019-arm64-ilp32-add-vdso-ilp32-and-use-for-signal-return.patch
@@ -0,0 +1,558 @@
+From 7ad3c48d616d42c990f5a2e3c7c9ba7aa910a557 Mon Sep 17 00:00:00 2001
+From: Manish Jaggi <mjaggi@cavium.com>
+Date: Wed, 29 Mar 2017 17:58:12 -0700
+Subject: [PATCH 19/20] arm64:ilp32: add vdso-ilp32 and use for signal return
+
+ILP32 VDSO exports next symbols:
+ __kernel_rt_sigreturn;
+ __kernel_gettimeofday;
+ __kernel_clock_gettime;
+ __kernel_clock_getres.
+
+What shared object to use, kernel selects depending on result of
+is_ilp32_compat_task() in arch/arm64/kernel/vdso.c, so it substitutes
+correct pages and spec.
+
+Adjusted to move the data page before code pages in sync with
+commit 601255ae3c98 ("arm64: vdso: move data page before code pages")
+
+Signed-off-by: Philipp Tomsich <philipp.tomsich@theobroma-systems.com>
+Signed-off-by: Christoph Muellner <christoph.muellner@theobroma-systems.com>
+Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
+---
+ arch/arm64/include/asm/vdso.h                 |  6 ++
+ arch/arm64/kernel/Makefile                    |  7 ++
+ arch/arm64/kernel/asm-offsets.c               |  7 ++
+ arch/arm64/kernel/signal.c                    |  2 +
+ arch/arm64/kernel/vdso-ilp32/.gitignore       |  2 +
+ arch/arm64/kernel/vdso-ilp32/Makefile         | 74 +++++++++++++++++++++
+ arch/arm64/kernel/vdso-ilp32/vdso-ilp32.S     | 33 ++++++++++
+ arch/arm64/kernel/vdso-ilp32/vdso-ilp32.lds.S | 95 +++++++++++++++++++++++++++
+ arch/arm64/kernel/vdso.c                      | 74 +++++++++++++++++----
+ arch/arm64/kernel/vdso/gettimeofday.S         | 20 +++++-
+ arch/arm64/kernel/vdso/vdso.S                 |  9 ++-
+ 11 files changed, 310 insertions(+), 19 deletions(-)
+ create mode 100644 arch/arm64/kernel/vdso-ilp32/.gitignore
+ create mode 100644 arch/arm64/kernel/vdso-ilp32/Makefile
+ create mode 100644 arch/arm64/kernel/vdso-ilp32/vdso-ilp32.S
+ create mode 100644 arch/arm64/kernel/vdso-ilp32/vdso-ilp32.lds.S
+
+diff --git a/arch/arm64/include/asm/vdso.h b/arch/arm64/include/asm/vdso.h
+index 839ce00..649a9a4 100644
+--- a/arch/arm64/include/asm/vdso.h
++++ b/arch/arm64/include/asm/vdso.h
+@@ -29,6 +29,12 @@
+ 
+ #include <generated/vdso-offsets.h>
+ 
++#ifdef CONFIG_ARM64_ILP32
++#include <generated/vdso-ilp32-offsets.h>
++#else
++#define vdso_offset_sigtramp_ilp32
++#endif
++
+ #define VDSO_SYMBOL(base, name)						   \
+ ({									   \
+ 	(void *)(vdso_offset_##name - VDSO_LBASE + (unsigned long)(base)); \
+diff --git a/arch/arm64/kernel/Makefile b/arch/arm64/kernel/Makefile
+index 566454c..167c1b6 100644
+--- a/arch/arm64/kernel/Makefile
++++ b/arch/arm64/kernel/Makefile
+@@ -47,6 +47,7 @@ arm64-obj-$(CONFIG_ACPI)		+= acpi.o
+ arm64-obj-$(CONFIG_ARM64_ACPI_PARKING_PROTOCOL)	+= acpi_parking_protocol.o
+ 
+ obj-y					+= $(arm64-obj-y) vdso/
++obj-$(CONFIG_ARM64_ILP32)		+= vdso-ilp32/
+ obj-m					+= $(arm64-obj-m)
+ head-y					:= head.o
+ extra-y					+= $(head-y) vmlinux.lds
+@@ -54,3 +55,9 @@ extra-y					+= $(head-y) vmlinux.lds
+ # vDSO - this must be built first to generate the symbol offsets
+ $(call objectify,$(arm64-obj-y)): $(obj)/vdso/vdso-offsets.h
+ $(obj)/vdso/vdso-offsets.h: $(obj)/vdso
++
++ifeq ($(CONFIG_ARM64_ILP32),y)
++# vDSO - this must be built first to generate the symbol offsets
++$(call objectify,$(arm64-obj-y)): $(obj)/vdso-ilp32/vdso-ilp32-offsets.h
++$(obj)/vdso-ilp32/vdso-ilp32-offsets.h: $(obj)/vdso-ilp32
++endif
+diff --git a/arch/arm64/kernel/asm-offsets.c b/arch/arm64/kernel/asm-offsets.c
+index e2414ab..e86cd1e 100644
+--- a/arch/arm64/kernel/asm-offsets.c
++++ b/arch/arm64/kernel/asm-offsets.c
+@@ -101,6 +101,13 @@ int main(void)
+   DEFINE(TSPEC_TV_SEC,		offsetof(struct timespec, tv_sec));
+   DEFINE(TSPEC_TV_NSEC,		offsetof(struct timespec, tv_nsec));
+   BLANK();
++#ifdef CONFIG_COMPAT
++  DEFINE(COMPAT_TVAL_TV_SEC,	offsetof(struct compat_timeval, tv_sec));
++  DEFINE(COMPAT_TVAL_TV_USEC,	offsetof(struct compat_timeval, tv_usec));
++  DEFINE(COMPAT_TSPEC_TV_SEC,	offsetof(struct compat_timespec, tv_sec));
++  DEFINE(COMPAT_TSPEC_TV_NSEC,	offsetof(struct compat_timespec, tv_nsec));
++  BLANK();
++#endif
+   DEFINE(TZ_MINWEST,		offsetof(struct timezone, tz_minuteswest));
+   DEFINE(TZ_DSTTIME,		offsetof(struct timezone, tz_dsttime));
+   BLANK();
+diff --git a/arch/arm64/kernel/signal.c b/arch/arm64/kernel/signal.c
+index f885e4a..8d51451 100644
+--- a/arch/arm64/kernel/signal.c
++++ b/arch/arm64/kernel/signal.c
+@@ -267,6 +267,8 @@ void setup_return(struct pt_regs *regs, struct k_sigaction *ka,
+ 
+ 	if (ka->sa.sa_flags & SA_RESTORER)
+ 		sigtramp = ka->sa.sa_restorer;
++	else if (is_ilp32_compat_task())
++		sigtramp = VDSO_SYMBOL(current->mm->context.vdso, sigtramp_ilp32);
+ 	else
+ 		sigtramp = VDSO_SYMBOL(current->mm->context.vdso, sigtramp);
+ 
+diff --git a/arch/arm64/kernel/vdso-ilp32/.gitignore b/arch/arm64/kernel/vdso-ilp32/.gitignore
+new file mode 100644
+index 0000000..61806c3
+--- /dev/null
++++ b/arch/arm64/kernel/vdso-ilp32/.gitignore
+@@ -0,0 +1,2 @@
++vdso-ilp32.lds
++vdso-ilp32-offsets.h
+diff --git a/arch/arm64/kernel/vdso-ilp32/Makefile b/arch/arm64/kernel/vdso-ilp32/Makefile
+new file mode 100644
+index 0000000..0671e88
+--- /dev/null
++++ b/arch/arm64/kernel/vdso-ilp32/Makefile
+@@ -0,0 +1,74 @@
++#
++# Building a vDSO image for AArch64.
++#
++# Author: Will Deacon <will.deacon@arm.com>
++# Heavily based on the vDSO Makefiles for other archs.
++#
++
++obj-ilp32-vdso := gettimeofday-ilp32.o note-ilp32.o sigreturn-ilp32.o
++
++# Build rules
++targets := $(obj-ilp32-vdso) vdso-ilp32.so vdso-ilp32.so.dbg
++obj-ilp32-vdso := $(addprefix $(obj)/, $(obj-ilp32-vdso))
++
++ccflags-y := -shared -fno-common -fno-builtin
++ccflags-y += -nostdlib -Wl,-soname=linux-ilp32-vdso.so.1 \
++		$(call cc-ldoption, -Wl$(comma)--hash-style=sysv)
++
++obj-y += vdso-ilp32.o
++extra-y += vdso-ilp32.lds vdso-ilp32-offsets.h
++CPPFLAGS_vdso-ilp32.lds += -P -C -U$(ARCH) -mabi=ilp32
++
++# Force dependency (incbin is bad)
++$(obj)/vdso-ilp32.o : $(obj)/vdso-ilp32.so
++
++# Link rule for the .so file, .lds has to be first
++$(obj)/vdso-ilp32.so.dbg: $(src)/vdso-ilp32.lds $(obj-ilp32-vdso)
++	$(call if_changed,vdso-ilp32ld)
++
++# Strip rule for the .so file
++$(obj)/%.so: OBJCOPYFLAGS := -S
++$(obj)/%.so: $(obj)/%.so.dbg FORCE
++	$(call if_changed,objcopy)
++
++# Generate VDSO offsets using helper script
++gen-vdsosym := $(srctree)/$(src)/../vdso/gen_vdso_offsets.sh
++quiet_cmd_vdsosym = VDSOSYM $@
++define cmd_vdsosym
++	$(NM) $< | $(gen-vdsosym) | LC_ALL=C sort > $@ && \
++	cp $@ include/generated/
++endef
++
++$(obj)/vdso-ilp32-offsets.h: $(obj)/vdso-ilp32.so.dbg FORCE
++	$(call if_changed,vdsosym)
++
++# Assembly rules for the .S files
++#$(obj-ilp32-vdso): %.o: $(src)/../vdso/$(subst -ilp32,,%.S)
++#	$(call if_changed_dep,vdso-ilp32as)
++
++$(obj)/gettimeofday-ilp32.o: $(src)/../vdso/gettimeofday.S
++	$(call if_changed_dep,vdso-ilp32as)
++
++$(obj)/note-ilp32.o: $(src)/../vdso/note.S
++	$(call if_changed_dep,vdso-ilp32as)
++
++# This one should be fine because ILP32 uses the same generic
++# __NR_rt_sigreturn syscall number.
++$(obj)/sigreturn-ilp32.o: $(src)/../vdso/sigreturn.S
++	$(call if_changed_dep,vdso-ilp32as)
++
++# Actual build commands
++quiet_cmd_vdso-ilp32ld = VDSOILP32L $@
++      cmd_vdso-ilp32ld = $(CC) $(c_flags) -mabi=ilp32  -Wl,-n -Wl,-T $^ -o $@
++quiet_cmd_vdso-ilp32as = VDSOILP32A $@
++      cmd_vdso-ilp32as = $(CC) $(a_flags) -mabi=ilp32 -c -o $@ $<
++
++# Install commands for the unstripped file
++quiet_cmd_vdso_install = INSTALL $@
++      cmd_vdso_install = cp $(obj)/$@.dbg $(MODLIB)/vdso/$@
++
++vdso-ilp32.so: $(obj)/vdso-ilp32.so.dbg
++	@mkdir -p $(MODLIB)/vdso
++	$(call cmd,vdso_install)
++
++vdso_install: vdso-ilp32.so
+diff --git a/arch/arm64/kernel/vdso-ilp32/vdso-ilp32.S b/arch/arm64/kernel/vdso-ilp32/vdso-ilp32.S
+new file mode 100644
+index 0000000..46ac072
+--- /dev/null
++++ b/arch/arm64/kernel/vdso-ilp32/vdso-ilp32.S
+@@ -0,0 +1,33 @@
++/*
++ * Copyright (C) 2012 ARM Limited
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
++ *
++ * Author: Will Deacon <will.deacon@arm.com>
++ */
++
++#include <linux/init.h>
++#include <linux/linkage.h>
++#include <linux/const.h>
++#include <asm/page.h>
++
++	__PAGE_ALIGNED_DATA
++
++	.globl vdso_ilp32_start, vdso_ilp32_end
++	.balign PAGE_SIZE
++vdso_ilp32_start:
++	.incbin "arch/arm64/kernel/vdso-ilp32/vdso-ilp32.so"
++	.balign PAGE_SIZE
++vdso_ilp32_end:
++
++	.previous
+diff --git a/arch/arm64/kernel/vdso-ilp32/vdso-ilp32.lds.S b/arch/arm64/kernel/vdso-ilp32/vdso-ilp32.lds.S
+new file mode 100644
+index 0000000..fb89086
+--- /dev/null
++++ b/arch/arm64/kernel/vdso-ilp32/vdso-ilp32.lds.S
+@@ -0,0 +1,95 @@
++/*
++ * GNU linker script for the VDSO library.
++ *
++ * Copyright (C) 2012 ARM Limited
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
++ *
++ * Author: Will Deacon <will.deacon@arm.com>
++ * Heavily based on the vDSO linker scripts for other archs.
++ */
++
++#include <linux/const.h>
++#include <asm/page.h>
++#include <asm/vdso.h>
++
++SECTIONS
++{
++	PROVIDE(_vdso_data = . - PAGE_SIZE);
++	. = VDSO_LBASE + SIZEOF_HEADERS;
++
++	.hash		: { *(.hash) }			:text
++	.gnu.hash	: { *(.gnu.hash) }
++	.dynsym		: { *(.dynsym) }
++	.dynstr		: { *(.dynstr) }
++	.gnu.version	: { *(.gnu.version) }
++	.gnu.version_d	: { *(.gnu.version_d) }
++	.gnu.version_r	: { *(.gnu.version_r) }
++
++	.note		: { *(.note.*) }		:text	:note
++
++	. = ALIGN(16);
++
++	.text		: { *(.text*) }			:text	=0xd503201f
++	PROVIDE (__etext = .);
++	PROVIDE (_etext = .);
++	PROVIDE (etext = .);
++
++	.eh_frame_hdr	: { *(.eh_frame_hdr) }		:text	:eh_frame_hdr
++	.eh_frame	: { KEEP (*(.eh_frame)) }	:text
++
++	.dynamic	: { *(.dynamic) }		:text	:dynamic
++
++	.rodata		: { *(.rodata*) }		:text
++
++	_end = .;
++	PROVIDE(end = .);
++
++	/DISCARD/	: {
++		*(.note.GNU-stack)
++		*(.data .data.* .gnu.linkonce.d.* .sdata*)
++		*(.bss .sbss .dynbss .dynsbss)
++	}
++}
++
++/*
++ * We must supply the ELF program headers explicitly to get just one
++ * PT_LOAD segment, and set the flags explicitly to make segments read-only.
++ */
++PHDRS
++{
++	text		PT_LOAD		FLAGS(5) FILEHDR PHDRS; /* PF_R|PF_X */
++	dynamic		PT_DYNAMIC	FLAGS(4);		/* PF_R */
++	note		PT_NOTE		FLAGS(4);		/* PF_R */
++	eh_frame_hdr	PT_GNU_EH_FRAME;
++}
++
++/*
++ * This controls what symbols we export from the DSO.
++ */
++VERSION
++{
++	LINUX_4.5 {
++	global:
++		__kernel_rt_sigreturn;
++		__kernel_gettimeofday;
++		__kernel_clock_gettime;
++		__kernel_clock_getres;
++	local: *;
++	};
++}
++
++/*
++ * Make the sigreturn code visible to the kernel.
++ */
++VDSO_sigtramp_ilp32		= __kernel_rt_sigreturn;
+diff --git a/arch/arm64/kernel/vdso.c b/arch/arm64/kernel/vdso.c
+index 26352a6..d3363cd 100644
+--- a/arch/arm64/kernel/vdso.c
++++ b/arch/arm64/kernel/vdso.c
+@@ -36,9 +36,13 @@
+ #include <asm/vdso.h>
+ #include <asm/vdso_datapage.h>
+ 
+-extern char vdso_start, vdso_end;
+-static unsigned long vdso_pages;
+-static struct page **vdso_pagelist;
++extern char vdso_lp64_start, vdso_lp64_end;
++static unsigned long vdso_lp64_pages;
++
++#ifdef CONFIG_ARM64_ILP32
++extern char vdso_ilp32_start, vdso_ilp32_end;
++static unsigned long vdso_ilp32_pages;
++#endif
+ 
+ /*
+  * The vDSO data page.
+@@ -109,20 +113,44 @@ int aarch32_setup_vectors_page(struct linux_binprm *bprm, int uses_interp)
+ }
+ #endif /* CONFIG_AARCH32_EL0 */
+ 
+-static struct vm_special_mapping vdso_spec[2];
++static struct vm_special_mapping vdso_lp64_spec[2] = {
++	{
++		.name	= "[vvar]",
++	},
++	{
++		.name	= "[vdso]",
++	},
++};
+ 
+-static int __init vdso_init(void)
++#ifdef CONFIG_ARM64_ILP32
++static struct vm_special_mapping vdso_ilp32_spec[2] = {
++	{
++		.name	= "[vvar]",
++	},
++	{
++		.name	= "[vdso]",
++	},
++};
++#endif
++
++static int __init vdso_init(char *vdso_start, char *vdso_end,
++					  unsigned long *vdso_pagesp,
++					  struct vm_special_mapping *vdso_spec)
+ {
+ 	int i;
++	unsigned long vdso_pages;
++	struct page **vdso_pagelist;
+ 
+-	if (memcmp(&vdso_start, "\177ELF", 4)) {
++	if (memcmp(vdso_start, "\177ELF", 4)) {
+ 		pr_err("vDSO is not a valid ELF object!\n");
+ 		return -EINVAL;
+ 	}
+ 
+-	vdso_pages = (&vdso_end - &vdso_start) >> PAGE_SHIFT;
++	vdso_pages = (vdso_end - vdso_start) >> PAGE_SHIFT;
++	*vdso_pagesp = vdso_pages;
+ 	pr_info("vdso: %ld pages (%ld code @ %p, %ld data @ %p)\n",
+-		vdso_pages + 1, vdso_pages, &vdso_start, 1L, vdso_data);
++					vdso_pages + 1, vdso_pages,
++					vdso_start, 1L, vdso_data);
+ 
+ 	/* Allocate the vDSO pagelist, plus a page for the data. */
+ 	vdso_pagelist = kcalloc(vdso_pages + 1, sizeof(struct page *),
+@@ -135,7 +163,7 @@ static int __init vdso_init(void)
+ 
+ 	/* Grab the vDSO code pages. */
+ 	for (i = 0; i < vdso_pages; i++)
+-		vdso_pagelist[i + 1] = virt_to_page(&vdso_start + i * PAGE_SIZE);
++		vdso_pagelist[i + 1] = virt_to_page(vdso_start + i * PAGE_SIZE);
+ 
+ 	/* Populate the special mapping structures */
+ 	vdso_spec[0] = (struct vm_special_mapping) {
+@@ -150,7 +178,22 @@ static int __init vdso_init(void)
+ 
+ 	return 0;
+ }
+-arch_initcall(vdso_init);
++
++static int __init vdso_lp64_init(void)
++{
++	return vdso_init(&vdso_lp64_start, &vdso_lp64_end,
++				&vdso_lp64_pages, vdso_lp64_spec);
++}
++arch_initcall(vdso_lp64_init);
++
++#ifdef CONFIG_ARM64_ILP32
++static int __init vdso_ilp32_init(void)
++{
++	return vdso_init(&vdso_ilp32_start, &vdso_ilp32_end,
++				&vdso_ilp32_pages, vdso_ilp32_spec);
++}
++arch_initcall(vdso_ilp32_init);
++#endif
+ 
+ int arch_setup_additional_pages(struct linux_binprm *bprm,
+ 				int uses_interp)
+@@ -158,8 +201,17 @@ int arch_setup_additional_pages(struct linux_binprm *bprm,
+ 	struct mm_struct *mm = current->mm;
+ 	unsigned long vdso_base, vdso_text_len, vdso_mapping_len;
+ 	void *ret;
++	unsigned long pages = vdso_lp64_pages;
++	struct vm_special_mapping *vdso_spec = vdso_lp64_spec;
++
++#ifdef CONFIG_ARM64_ILP32
++	if (is_ilp32_compat_task()) {
++		pages = vdso_ilp32_pages;
++		vdso_spec = vdso_ilp32_spec;
++	}
++#endif
+ 
+-	vdso_text_len = vdso_pages << PAGE_SHIFT;
++	vdso_text_len = pages << PAGE_SHIFT;
+ 	/* Be sure to map the data page */
+ 	vdso_mapping_len = vdso_text_len + PAGE_SIZE;
+ 
+diff --git a/arch/arm64/kernel/vdso/gettimeofday.S b/arch/arm64/kernel/vdso/gettimeofday.S
+index efa79e8..a2d8a70 100644
+--- a/arch/arm64/kernel/vdso/gettimeofday.S
++++ b/arch/arm64/kernel/vdso/gettimeofday.S
+@@ -25,6 +25,16 @@
+ #define NSEC_PER_SEC_LO16	0xca00
+ #define NSEC_PER_SEC_HI16	0x3b9a
+ 
++#ifdef __LP64__
++#define PTR_REG(n)	x##n
++#define OFFSET(n)	n
++#define DELOUSE(n)
++#else
++#define PTR_REG(n)	w##n
++#define OFFSET(n)	COMPAT_##n
++#define DELOUSE(n)	mov     w##n, w##n
++#endif
++
+ vdso_data	.req	x6
+ use_syscall	.req	w7
+ seqcnt		.req	w8
+@@ -51,6 +61,8 @@ seqcnt		.req	w8
+ /* int __kernel_gettimeofday(struct timeval *tv, struct timezone *tz); */
+ ENTRY(__kernel_gettimeofday)
+ 	.cfi_startproc
++	DELOUSE(0)
++	DELOUSE(1)
+ 	mov	x2, x30
+ 	.cfi_register x30, x2
+ 
+@@ -68,7 +80,7 @@ ENTRY(__kernel_gettimeofday)
+ 	mov	x13, #1000
+ 	lsl	x13, x13, x12
+ 	udiv	x11, x11, x13
+-	stp	x10, x11, [x0, #TVAL_TV_SEC]
++	stp	PTR_REG(10), PTR_REG(11), [x0, #OFFSET(TVAL_TV_SEC)]
+ 2:
+ 	/* If tz is NULL, return 0. */
+ 	cbz	x1, 3f
+@@ -88,6 +100,7 @@ ENDPROC(__kernel_gettimeofday)
+ /* int __kernel_clock_gettime(clockid_t clock_id, struct timespec *tp); */
+ ENTRY(__kernel_clock_gettime)
+ 	.cfi_startproc
++	DELOUSE(1)
+ 	cmp	w0, #CLOCK_REALTIME
+ 	ccmp	w0, #CLOCK_MONOTONIC, #0x4, ne
+ 	b.ne	2f
+@@ -159,7 +172,7 @@ ENTRY(__kernel_clock_gettime)
+ 
+ 6:	/* Store to the user timespec. */
+ 	lsr	x11, x11, x12
+-	stp	x10, x11, [x1, #TSPEC_TV_SEC]
++	stp	PTR_REG(10), PTR_REG(11), [x1, #OFFSET(TSPEC_TV_SEC)]
+ 	mov	x0, xzr
+ 	ret
+ 7:
+@@ -174,6 +187,7 @@ ENDPROC(__kernel_clock_gettime)
+ /* int __kernel_clock_getres(clockid_t clock_id, struct timespec *res); */
+ ENTRY(__kernel_clock_getres)
+ 	.cfi_startproc
++	DELOUSE(1)
+ 	cmp	w0, #CLOCK_REALTIME
+ 	ccmp	w0, #CLOCK_MONOTONIC, #0x4, ne
+ 	b.ne	1f
+@@ -187,7 +201,7 @@ ENTRY(__kernel_clock_getres)
+ 	ldr	x2, 6f
+ 2:
+ 	cbz	w1, 3f
+-	stp	xzr, x2, [x1]
++	stp	PTR_REG(zr), PTR_REG(2), [x1]
+ 
+ 3:	/* res == NULL. */
+ 	mov	w0, wzr
+diff --git a/arch/arm64/kernel/vdso/vdso.S b/arch/arm64/kernel/vdso/vdso.S
+index 60c1db5..a40ae24 100644
+--- a/arch/arm64/kernel/vdso/vdso.S
++++ b/arch/arm64/kernel/vdso/vdso.S
+@@ -21,13 +21,12 @@
+ #include <linux/const.h>
+ #include <asm/page.h>
+ 
+-	__PAGE_ALIGNED_DATA
+-
+-	.globl vdso_start, vdso_end
++	.globl vdso_lp64_start, vdso_lp64_end
++	.section .rodata
+ 	.balign PAGE_SIZE
+-vdso_start:
++vdso_lp64_start:
+ 	.incbin "arch/arm64/kernel/vdso/vdso.so"
+ 	.balign PAGE_SIZE
+-vdso_end:
++vdso_lp64_end:
+ 
+ 	.previous
+-- 
+2.5.0
+
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0019-arm64-signal-share-lp64-signal-routines-to-ilp32.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0019-arm64-signal-share-lp64-signal-routines-to-ilp32.patch
deleted file mode 100644
index a0d4fd2..0000000
--- a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0019-arm64-signal-share-lp64-signal-routines-to-ilp32.patch
+++ /dev/null
@@ -1,239 +0,0 @@
-From 4dae2734132f2e47479753ffaf6222076c2bfa47 Mon Sep 17 00:00:00 2001
-From: Yury Norov <ynorov@caviumnetworks.com>
-Date: Tue, 24 May 2016 03:04:48 +0300
-Subject: [PATCH 19/24] arm64: signal: share lp64 signal routines to ilp32
-
-After that, it will be possible to reuse it in ilp32.
-
-Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
----
- arch/arm64/include/asm/signal_common.h | 33 ++++++++++++
- arch/arm64/kernel/signal.c             | 91 +++++++++++++++++++++-------------
- 2 files changed, 90 insertions(+), 34 deletions(-)
- create mode 100644 arch/arm64/include/asm/signal_common.h
-
-diff --git a/arch/arm64/include/asm/signal_common.h b/arch/arm64/include/asm/signal_common.h
-new file mode 100644
-index 0000000..756ed2c
---- /dev/null
-+++ b/arch/arm64/include/asm/signal_common.h
-@@ -0,0 +1,33 @@
-+/*
-+ * Copyright (C) 1995-2009 Russell King
-+ * Copyright (C) 2012 ARM Ltd.
-+ * Copyright (C) 2016 Cavium Networks.
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License version 2 as
-+ * published by the Free Software Foundation.
-+ *
-+ * This program is distributed in the hope that it will be useful,
-+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-+ * GNU General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
-+ */
-+
-+#ifndef __ASM_SIGNAL_COMMON_H
-+#define __ASM_SIGNAL_COMMON_H
-+
-+#include <linux/uaccess.h>
-+#include <asm/ucontext.h>
-+#include <asm/fpsimd.h>
-+
-+int preserve_fpsimd_context(struct fpsimd_context __user *ctx);
-+int restore_fpsimd_context(struct fpsimd_context __user *ctx);
-+int setup_sigcontext(struct sigcontext __user *uc_mcontext, struct pt_regs *regs);
-+int restore_sigcontext(struct pt_regs *regs, struct sigcontext __user *sf);
-+void setup_return(struct pt_regs *regs, struct k_sigaction *ka,
-+			void __user *frame, off_t sigframe_off, int usig);
-+
-+#endif /* __ASM_SIGNAL_COMMON_H */
-diff --git a/arch/arm64/kernel/signal.c b/arch/arm64/kernel/signal.c
-index 65baaef..b22e02a 100644
---- a/arch/arm64/kernel/signal.c
-+++ b/arch/arm64/kernel/signal.c
-@@ -34,18 +34,23 @@
- #include <asm/fpsimd.h>
- #include <asm/signal32.h>
- #include <asm/vdso.h>
-+#include <asm/signal_common.h>
-+
-+struct sigframe {
-+	struct ucontext uc;
-+	u64 fp;
-+	u64 lr;
-+};
- 
- /*
-  * Do a signal return; undo the signal stack. These are aligned to 128-bit.
-  */
- struct rt_sigframe {
- 	struct siginfo info;
--	struct ucontext uc;
--	u64 fp;
--	u64 lr;
-+	struct sigframe sig;
- };
- 
--static int preserve_fpsimd_context(struct fpsimd_context __user *ctx)
-+int preserve_fpsimd_context(struct fpsimd_context __user *ctx)
- {
- 	struct fpsimd_state *fpsimd = &current->thread.fpsimd_state;
- 	int err;
-@@ -65,7 +70,7 @@ static int preserve_fpsimd_context(struct fpsimd_context __user *ctx)
- 	return err ? -EFAULT : 0;
- }
- 
--static int restore_fpsimd_context(struct fpsimd_context __user *ctx)
-+int restore_fpsimd_context(struct fpsimd_context __user *ctx)
- {
- 	struct fpsimd_state fpsimd;
- 	__u32 magic, size;
-@@ -93,22 +98,30 @@ static int restore_fpsimd_context(struct fpsimd_context __user *ctx)
- }
- 
- static int restore_sigframe(struct pt_regs *regs,
--			    struct rt_sigframe __user *sf)
-+			    struct sigframe __user *sf)
- {
- 	sigset_t set;
--	int i, err;
--	void *aux = sf->uc.uc_mcontext.__reserved;
--
-+	int err;
- 	err = __copy_from_user(&set, &sf->uc.uc_sigmask, sizeof(set));
- 	if (err == 0)
- 		set_current_blocked(&set);
- 
-+	err |= restore_sigcontext(regs, &sf->uc.uc_mcontext);
-+	return err;
-+}
-+
-+
-+int restore_sigcontext(struct pt_regs *regs, struct sigcontext __user *uc_mcontext)
-+{
-+	int i, err = 0;
-+	void *aux = uc_mcontext->__reserved;
-+
- 	for (i = 0; i < 31; i++)
--		__get_user_error(regs->regs[i], &sf->uc.uc_mcontext.regs[i],
-+		__get_user_error(regs->regs[i], &uc_mcontext->regs[i],
- 				 err);
--	__get_user_error(regs->sp, &sf->uc.uc_mcontext.sp, err);
--	__get_user_error(regs->pc, &sf->uc.uc_mcontext.pc, err);
--	__get_user_error(regs->pstate, &sf->uc.uc_mcontext.pstate, err);
-+	__get_user_error(regs->sp, &uc_mcontext->sp, err);
-+	__get_user_error(regs->pc, &uc_mcontext->pc, err);
-+	__get_user_error(regs->pstate, &uc_mcontext->pstate, err);
- 
- 	/*
- 	 * Avoid sys_rt_sigreturn() restarting.
-@@ -145,10 +158,10 @@ asmlinkage long sys_rt_sigreturn(struct pt_regs *regs)
- 	if (!access_ok(VERIFY_READ, frame, sizeof (*frame)))
- 		goto badframe;
- 
--	if (restore_sigframe(regs, frame))
-+	if (restore_sigframe(regs, &frame->sig))
- 		goto badframe;
- 
--	if (restore_altstack(&frame->uc.uc_stack))
-+	if (restore_altstack(&frame->sig.uc.uc_stack))
- 		goto badframe;
- 
- 	return regs->regs[0];
-@@ -162,27 +175,36 @@ badframe:
- 	return 0;
- }
- 
--static int setup_sigframe(struct rt_sigframe __user *sf,
-+static int setup_sigframe(struct sigframe __user *sf,
- 			  struct pt_regs *regs, sigset_t *set)
- {
--	int i, err = 0;
--	void *aux = sf->uc.uc_mcontext.__reserved;
--	struct _aarch64_ctx *end;
-+	int err = 0;
- 
- 	/* set up the stack frame for unwinding */
- 	__put_user_error(regs->regs[29], &sf->fp, err);
- 	__put_user_error(regs->regs[30], &sf->lr, err);
-+	err |= __copy_to_user(&sf->uc.uc_sigmask, set, sizeof(*set));
-+	err |= setup_sigcontext(&sf->uc.uc_mcontext, regs);
-+
-+	return err;
-+}
-+
-+int setup_sigcontext(struct sigcontext __user *uc_mcontext,
-+			struct pt_regs *regs)
-+{
-+	void *aux = uc_mcontext->__reserved;
-+	struct _aarch64_ctx *end;
-+	int i, err = 0;
- 
- 	for (i = 0; i < 31; i++)
--		__put_user_error(regs->regs[i], &sf->uc.uc_mcontext.regs[i],
-+		__put_user_error(regs->regs[i], &uc_mcontext->regs[i],
- 				 err);
--	__put_user_error(regs->sp, &sf->uc.uc_mcontext.sp, err);
--	__put_user_error(regs->pc, &sf->uc.uc_mcontext.pc, err);
--	__put_user_error(regs->pstate, &sf->uc.uc_mcontext.pstate, err);
- 
--	__put_user_error(current->thread.fault_address, &sf->uc.uc_mcontext.fault_address, err);
-+	__put_user_error(regs->sp, &uc_mcontext->sp, err);
-+	__put_user_error(regs->pc, &uc_mcontext->pc, err);
-+	__put_user_error(regs->pstate, &uc_mcontext->pstate, err);
- 
--	err |= __copy_to_user(&sf->uc.uc_sigmask, set, sizeof(*set));
-+	__put_user_error(current->thread.fault_address, &uc_mcontext->fault_address, err);
- 
- 	if (err == 0) {
- 		struct fpsimd_context *fpsimd_ctx =
-@@ -229,14 +251,14 @@ static struct rt_sigframe __user *get_sigframe(struct ksignal *ksig,
- 	return frame;
- }
- 
--static void setup_return(struct pt_regs *regs, struct k_sigaction *ka,
--			 void __user *frame, int usig)
-+void setup_return(struct pt_regs *regs, struct k_sigaction *ka,
-+			 void __user *frame, off_t sigframe_off, int usig)
- {
- 	__sigrestore_t sigtramp;
- 
- 	regs->regs[0] = usig;
- 	regs->sp = (unsigned long)frame;
--	regs->regs[29] = regs->sp + offsetof(struct rt_sigframe, fp);
-+	regs->regs[29] = regs->sp + sigframe_off + offsetof(struct sigframe, fp);
- 	regs->pc = (unsigned long)ka->sa.sa_handler;
- 
- 	if (ka->sa.sa_flags & SA_RESTORER)
-@@ -257,17 +279,18 @@ static int setup_rt_frame(int usig, struct ksignal *ksig, sigset_t *set,
- 	if (!frame)
- 		return 1;
- 
--	__put_user_error(0, &frame->uc.uc_flags, err);
--	__put_user_error(NULL, &frame->uc.uc_link, err);
-+	__put_user_error(0, &frame->sig.uc.uc_flags, err);
-+	__put_user_error(NULL, &frame->sig.uc.uc_link, err);
- 
--	err |= __save_altstack(&frame->uc.uc_stack, regs->sp);
--	err |= setup_sigframe(frame, regs, set);
-+	err |= __save_altstack(&frame->sig.uc.uc_stack, regs->sp);
-+	err |= setup_sigframe(&frame->sig, regs, set);
- 	if (err == 0) {
--		setup_return(regs, &ksig->ka, frame, usig);
-+		setup_return(regs, &ksig->ka, frame,
-+			offsetof(struct rt_sigframe, sig), usig);
- 		if (ksig->ka.sa.sa_flags & SA_SIGINFO) {
- 			err |= copy_siginfo_to_user(&frame->info, &ksig->info);
- 			regs->regs[1] = (unsigned long)&frame->info;
--			regs->regs[2] = (unsigned long)&frame->uc;
-+			regs->regs[2] = (unsigned long)&frame->sig.uc;
- 		}
- 	}
- 
--- 
-1.9.1
-
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0020-arm64-ilp32-add-ARM64_ILP32-to-Kconfig.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0020-arm64-ilp32-add-ARM64_ILP32-to-Kconfig.patch
new file mode 100644
index 0000000..ade9a88
--- /dev/null
+++ b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0020-arm64-ilp32-add-ARM64_ILP32-to-Kconfig.patch
@@ -0,0 +1,47 @@
+From 576e7d0450b05cc094c3467cb220fb894ee47682 Mon Sep 17 00:00:00 2001
+From: Andrew Pinski <apinski@cavium.com>
+Date: Tue, 24 May 2016 03:04:52 +0300
+Subject: [PATCH 20/20] arm64:ilp32: add ARM64_ILP32 to Kconfig
+
+This patch adds the config option for ILP32.
+
+Signed-off-by: Andrew Pinski <Andrew.Pinski@caviumnetworks.com>
+Signed-off-by: Philipp Tomsich <philipp.tomsich@theobroma-systems.com>
+Signed-off-by: Christoph Muellner <christoph.muellner@theobroma-systems.com>
+Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
+Reviewed-by: David Daney <ddaney@caviumnetworks.com>
+---
+ arch/arm64/Kconfig | 10 +++++++++-
+ 1 file changed, 9 insertions(+), 1 deletion(-)
+
+diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
+index 7b3bf7b..d81f58c 100644
+--- a/arch/arm64/Kconfig
++++ b/arch/arm64/Kconfig
+@@ -834,7 +834,7 @@ source "fs/Kconfig.binfmt"
+ 
+ config COMPAT
+ 	bool
+-	depends on AARCH32_EL0
++	depends on AARCH32_EL0 || ARM64_ILP32
+ 
+ config AARCH32_EL0
+ 	bool "Kernel support for 32-bit EL0"
+@@ -856,6 +856,14 @@ config AARCH32_EL0
+ 
+ 	  If you want to execute 32-bit userspace applications, say Y.
+ 
++config ARM64_ILP32
++	bool "Kernel support for ILP32"
++	select COMPAT
++	help
++	  This option enables support for AArch64 ILP32 user space.  ILP32
++	  is an ABI where long and pointers are 32bits but it uses the AARCH64
++	  instruction set.
++
+ config SYSVIPC_COMPAT
+ 	def_bool y
+ 	depends on COMPAT && SYSVIPC
+-- 
+2.5.0
+
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0020-arm64-signal32-move-ilp32-and-aarch32-common-code-to.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0020-arm64-signal32-move-ilp32-and-aarch32-common-code-to.patch
deleted file mode 100644
index fce99c2..0000000
--- a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0020-arm64-signal32-move-ilp32-and-aarch32-common-code-to.patch
+++ /dev/null
@@ -1,278 +0,0 @@
-From 1d78ddc37a0bd9d29d9e67d3e563c8fe5e1c044f Mon Sep 17 00:00:00 2001
-From: Yury Norov <ynorov@caviumnetworks.com>
-Date: Tue, 24 May 2016 03:04:49 +0300
-Subject: [PATCH 20/24] arm64: signal32: move ilp32 and aarch32 common code to
- separated file
-
-Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
----
- arch/arm64/include/asm/signal32_common.h |  25 +++++++
- arch/arm64/kernel/Makefile               |   1 +
- arch/arm64/kernel/signal32.c             |  84 ----------------------
- arch/arm64/kernel/signal32_common.c      | 115 +++++++++++++++++++++++++++++++
- 4 files changed, 141 insertions(+), 84 deletions(-)
- create mode 100644 arch/arm64/include/asm/signal32_common.h
- create mode 100644 arch/arm64/kernel/signal32_common.c
-
-diff --git a/arch/arm64/include/asm/signal32_common.h b/arch/arm64/include/asm/signal32_common.h
-new file mode 100644
-index 0000000..b4f2099
---- /dev/null
-+++ b/arch/arm64/include/asm/signal32_common.h
-@@ -0,0 +1,25 @@
-+/*
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License version 2 as
-+ * published by the Free Software Foundation.
-+ *
-+ * This program is distributed in the hope that it will be useful,
-+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-+ * GNU General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
-+ */
-+#ifndef __ASM_SIGNAL32_COMMON_H
-+#define __ASM_SIGNAL32_COMMON_H
-+
-+#ifdef CONFIG_COMPAT
-+
-+int copy_siginfo_to_user32(compat_siginfo_t __user *to, const siginfo_t *from);
-+int copy_siginfo_from_user32(siginfo_t *to, compat_siginfo_t __user *from);
-+
-+#endif /* CONFIG_COMPAT*/
-+
-+#endif /* __ASM_SIGNAL32_COMMON_H */
-+
-diff --git a/arch/arm64/kernel/Makefile b/arch/arm64/kernel/Makefile
-index b0adab7..4c1db47 100644
---- a/arch/arm64/kernel/Makefile
-+++ b/arch/arm64/kernel/Makefile
-@@ -29,6 +29,7 @@ arm64-obj-$(CONFIG_AARCH32_EL0)		+= sys32.o kuser32.o signal32.o 	\
- 					   sys_compat.o entry32.o		\
- 					   ../../arm/kernel/opcodes.o binfmt_elf32.o
- arm64-obj-$(CONFIG_ARM64_ILP32)		+= binfmt_ilp32.o sys_ilp32.o
-+arm64-obj-$(CONFIG_COMPAT)		+= signal32_common.o
- arm64-obj-$(CONFIG_FUNCTION_TRACER)	+= ftrace.o entry-ftrace.o
- arm64-obj-$(CONFIG_MODULES)		+= arm64ksyms.o module.o
- arm64-obj-$(CONFIG_PERF_EVENTS)		+= perf_regs.o perf_callchain.o
-diff --git a/arch/arm64/kernel/signal32.c b/arch/arm64/kernel/signal32.c
-index 71ef6dc..3472a1a 100644
---- a/arch/arm64/kernel/signal32.c
-+++ b/arch/arm64/kernel/signal32.c
-@@ -125,90 +125,6 @@ static inline int get_sigset_t(sigset_t *set,
- 	return 0;
- }
- 
--int copy_siginfo_to_user32(compat_siginfo_t __user *to, const siginfo_t *from)
--{
--	int err;
--
--	if (!access_ok(VERIFY_WRITE, to, sizeof(*to)))
--		return -EFAULT;
--
--	/* If you change siginfo_t structure, please be sure
--	 * this code is fixed accordingly.
--	 * It should never copy any pad contained in the structure
--	 * to avoid security leaks, but must copy the generic
--	 * 3 ints plus the relevant union member.
--	 * This routine must convert siginfo from 64bit to 32bit as well
--	 * at the same time.
--	 */
--	err = __put_user(from->si_signo, &to->si_signo);
--	err |= __put_user(from->si_errno, &to->si_errno);
--	err |= __put_user((short)from->si_code, &to->si_code);
--	if (from->si_code < 0)
--		err |= __copy_to_user(&to->_sifields._pad, &from->_sifields._pad,
--				      SI_PAD_SIZE);
--	else switch (from->si_code & __SI_MASK) {
--	case __SI_KILL:
--		err |= __put_user(from->si_pid, &to->si_pid);
--		err |= __put_user(from->si_uid, &to->si_uid);
--		break;
--	case __SI_TIMER:
--		 err |= __put_user(from->si_tid, &to->si_tid);
--		 err |= __put_user(from->si_overrun, &to->si_overrun);
--		 err |= __put_user(from->si_int, &to->si_int);
--		break;
--	case __SI_POLL:
--		err |= __put_user(from->si_band, &to->si_band);
--		err |= __put_user(from->si_fd, &to->si_fd);
--		break;
--	case __SI_FAULT:
--		err |= __put_user((compat_uptr_t)(unsigned long)from->si_addr,
--				  &to->si_addr);
--#ifdef BUS_MCEERR_AO
--		/*
--		 * Other callers might not initialize the si_lsb field,
--		 * so check explicitely for the right codes here.
--		 */
--		if (from->si_signo == SIGBUS &&
--		    (from->si_code == BUS_MCEERR_AR || from->si_code == BUS_MCEERR_AO))
--			err |= __put_user(from->si_addr_lsb, &to->si_addr_lsb);
--#endif
--		break;
--	case __SI_CHLD:
--		err |= __put_user(from->si_pid, &to->si_pid);
--		err |= __put_user(from->si_uid, &to->si_uid);
--		err |= __put_user(from->si_status, &to->si_status);
--		err |= __put_user(from->si_utime, &to->si_utime);
--		err |= __put_user(from->si_stime, &to->si_stime);
--		break;
--	case __SI_RT: /* This is not generated by the kernel as of now. */
--	case __SI_MESGQ: /* But this is */
--		err |= __put_user(from->si_pid, &to->si_pid);
--		err |= __put_user(from->si_uid, &to->si_uid);
--		err |= __put_user(from->si_int, &to->si_int);
--		break;
--	case __SI_SYS:
--		err |= __put_user((compat_uptr_t)(unsigned long)
--				from->si_call_addr, &to->si_call_addr);
--		err |= __put_user(from->si_syscall, &to->si_syscall);
--		err |= __put_user(from->si_arch, &to->si_arch);
--		break;
--	default: /* this is just in case for now ... */
--		err |= __put_user(from->si_pid, &to->si_pid);
--		err |= __put_user(from->si_uid, &to->si_uid);
--		break;
--	}
--	return err;
--}
--
--int copy_siginfo_from_user32(siginfo_t *to, compat_siginfo_t __user *from)
--{
--	if (copy_from_user(to, from, __ARCH_SI_PREAMBLE_SIZE) ||
--	    copy_from_user(to->_sifields._pad,
--			   from->_sifields._pad, SI_PAD_SIZE))
--		return -EFAULT;
--
--	return 0;
--}
- 
- /*
-  * VFP save/restore code.
-diff --git a/arch/arm64/kernel/signal32_common.c b/arch/arm64/kernel/signal32_common.c
-new file mode 100644
-index 0000000..8fbb609
---- /dev/null
-+++ b/arch/arm64/kernel/signal32_common.c
-@@ -0,0 +1,115 @@
-+/*
-+ * Based on arch/arm/kernel/signal.c
-+ *
-+ * Copyright (C) 1995-2009 Russell King
-+ * Copyright (C) 2012 ARM Ltd.
-+ * Modified by Will Deacon <will.deacon@arm.com>
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License version 2 as
-+ * published by the Free Software Foundation.
-+ *
-+ * This program is distributed in the hope that it will be useful,
-+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-+ * GNU General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
-+ */
-+
-+#include <linux/compat.h>
-+#include <linux/signal.h>
-+#include <linux/ratelimit.h>
-+
-+#include <asm/esr.h>
-+#include <asm/fpsimd.h>
-+#include <asm/signal32_common.h>
-+#include <asm/uaccess.h>
-+#include <asm/unistd.h>
-+
-+int copy_siginfo_to_user32(compat_siginfo_t __user *to, const siginfo_t *from)
-+{
-+	int err;
-+
-+	if (!access_ok(VERIFY_WRITE, to, sizeof(*to)))
-+		return -EFAULT;
-+
-+	/* If you change siginfo_t structure, please be sure
-+	 * this code is fixed accordingly.
-+	 * It should never copy any pad contained in the structure
-+	 * to avoid security leaks, but must copy the generic
-+	 * 3 ints plus the relevant union member.
-+	 * This routine must convert siginfo from 64bit to 32bit as well
-+	 * at the same time.
-+	 */
-+	err = __put_user(from->si_signo, &to->si_signo);
-+	err |= __put_user(from->si_errno, &to->si_errno);
-+	err |= __put_user((short)from->si_code, &to->si_code);
-+	if (from->si_code < 0)
-+		err |= __copy_to_user(&to->_sifields._pad, &from->_sifields._pad,
-+				      SI_PAD_SIZE);
-+	else switch (from->si_code & __SI_MASK) {
-+	case __SI_KILL:
-+		err |= __put_user(from->si_pid, &to->si_pid);
-+		err |= __put_user(from->si_uid, &to->si_uid);
-+		break;
-+	case __SI_TIMER:
-+		 err |= __put_user(from->si_tid, &to->si_tid);
-+		 err |= __put_user(from->si_overrun, &to->si_overrun);
-+		 err |= __put_user(from->si_int, &to->si_int);
-+		break;
-+	case __SI_POLL:
-+		err |= __put_user(from->si_band, &to->si_band);
-+		err |= __put_user(from->si_fd, &to->si_fd);
-+		break;
-+	case __SI_FAULT:
-+		err |= __put_user((compat_uptr_t)(unsigned long)from->si_addr,
-+				  &to->si_addr);
-+#ifdef BUS_MCEERR_AO
-+		/*
-+		 * Other callers might not initialize the si_lsb field,
-+		 * so check explicitly for the right codes here.
-+		 */
-+		if (from->si_signo == SIGBUS &&
-+		    (from->si_code == BUS_MCEERR_AR || from->si_code == BUS_MCEERR_AO))
-+			err |= __put_user(from->si_addr_lsb, &to->si_addr_lsb);
-+#endif
-+		break;
-+	case __SI_CHLD:
-+		err |= __put_user(from->si_pid, &to->si_pid);
-+		err |= __put_user(from->si_uid, &to->si_uid);
-+		err |= __put_user(from->si_status, &to->si_status);
-+		err |= __put_user(from->si_utime, &to->si_utime);
-+		err |= __put_user(from->si_stime, &to->si_stime);
-+		break;
-+	case __SI_RT: /* This is not generated by the kernel as of now. */
-+	case __SI_MESGQ: /* But this is */
-+		err |= __put_user(from->si_pid, &to->si_pid);
-+		err |= __put_user(from->si_uid, &to->si_uid);
-+		err |= __put_user(from->si_int, &to->si_int);
-+		break;
-+	case __SI_SYS:
-+		err |= __put_user((compat_uptr_t)(unsigned long)
-+				from->si_call_addr, &to->si_call_addr);
-+		err |= __put_user(from->si_syscall, &to->si_syscall);
-+		err |= __put_user(from->si_arch, &to->si_arch);
-+		break;
-+	default: /* this is just in case for now ... */
-+		err |= __put_user(from->si_pid, &to->si_pid);
-+		err |= __put_user(from->si_uid, &to->si_uid);
-+		break;
-+	}
-+	return err;
-+}
-+
-+int copy_siginfo_from_user32(siginfo_t *to, compat_siginfo_t __user *from)
-+{
-+	if (copy_from_user(to, from, __ARCH_SI_PREAMBLE_SIZE) ||
-+	    copy_from_user(to->_sifields._pad,
-+			   from->_sifields._pad, SI_PAD_SIZE))
-+		return -EFAULT;
-+
-+	return 0;
-+}
-+
--- 
-1.9.1
-
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0021-arm64-ilp32-introduce-ilp32-specific-handlers-for-si.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0021-arm64-ilp32-introduce-ilp32-specific-handlers-for-si.patch
deleted file mode 100644
index 9640ea1..0000000
--- a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0021-arm64-ilp32-introduce-ilp32-specific-handlers-for-si.patch
+++ /dev/null
@@ -1,343 +0,0 @@
-From 917ae737f99d75aaaa08a81f24ba32c183774f77 Mon Sep 17 00:00:00 2001
-From: Andrew Pinski <apinski@cavium.com>
-Date: Tue, 24 May 2016 03:04:50 +0300
-Subject: [PATCH 21/24] arm64: ilp32: introduce ilp32-specific handlers for
- sigframe and ucontext
-
-ILP32 uses AARCH32 compat structures and syscall handlers for signals.
-But ILP32 struct rt_sigframe  and ucontext differs from both LP64 and
-AARCH32. So some specific mechanism is needed to take care of it.
-
-Signed-off-by: Andrew Pinski <Andrew.Pinski@caviumnetworks.com>
-Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
----
- arch/arm64/include/asm/signal_ilp32.h |  34 ++++++
- arch/arm64/kernel/Makefile            |   3 +-
- arch/arm64/kernel/entry_ilp32.S       |  23 ++++
- arch/arm64/kernel/signal.c            |   3 +
- arch/arm64/kernel/signal_ilp32.c      | 192 ++++++++++++++++++++++++++++++++++
- arch/arm64/kernel/sys_ilp32.c         |   3 +
- 6 files changed, 257 insertions(+), 1 deletion(-)
- create mode 100644 arch/arm64/include/asm/signal_ilp32.h
- create mode 100644 arch/arm64/kernel/entry_ilp32.S
- create mode 100644 arch/arm64/kernel/signal_ilp32.c
-
-diff --git a/arch/arm64/include/asm/signal_ilp32.h b/arch/arm64/include/asm/signal_ilp32.h
-new file mode 100644
-index 0000000..30eff23
---- /dev/null
-+++ b/arch/arm64/include/asm/signal_ilp32.h
-@@ -0,0 +1,34 @@
-+/*
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License version 2 as
-+ * published by the Free Software Foundation.
-+ *
-+ * This program is distributed in the hope that it will be useful,
-+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-+ * GNU General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
-+ */
-+#ifndef __ASM_SIGNAL_ILP32_H
-+#define __ASM_SIGNAL_ILP32_H
-+
-+#ifdef CONFIG_ARM64_ILP32
-+
-+#include <linux/compat.h>
-+
-+int ilp32_setup_rt_frame(int usig, struct ksignal *ksig, sigset_t *set,
-+			  struct pt_regs *regs);
-+
-+#else
-+
-+static inline int ilp32_setup_rt_frame(int usig, struct ksignal *ksig, sigset_t *set,
-+			  struct pt_regs *regs)
-+{
-+	return -ENOSYS;
-+}
-+
-+#endif /* CONFIG_ARM64_ILP32 */
-+
-+#endif /* __ASM_SIGNAL_ILP32_H */
-diff --git a/arch/arm64/kernel/Makefile b/arch/arm64/kernel/Makefile
-index 4c1db47..9c91b8c 100644
---- a/arch/arm64/kernel/Makefile
-+++ b/arch/arm64/kernel/Makefile
-@@ -28,7 +28,8 @@ $(obj)/%.stub.o: $(obj)/%.o FORCE
- arm64-obj-$(CONFIG_AARCH32_EL0)		+= sys32.o kuser32.o signal32.o 	\
- 					   sys_compat.o entry32.o		\
- 					   ../../arm/kernel/opcodes.o binfmt_elf32.o
--arm64-obj-$(CONFIG_ARM64_ILP32)		+= binfmt_ilp32.o sys_ilp32.o
-+arm64-obj-$(CONFIG_ARM64_ILP32)		+= binfmt_ilp32.o sys_ilp32.o 		\
-+					   signal_ilp32.o entry_ilp32.o
- arm64-obj-$(CONFIG_COMPAT)		+= signal32_common.o
- arm64-obj-$(CONFIG_FUNCTION_TRACER)	+= ftrace.o entry-ftrace.o
- arm64-obj-$(CONFIG_MODULES)		+= arm64ksyms.o module.o
-diff --git a/arch/arm64/kernel/entry_ilp32.S b/arch/arm64/kernel/entry_ilp32.S
-new file mode 100644
-index 0000000..5063172
---- /dev/null
-+++ b/arch/arm64/kernel/entry_ilp32.S
-@@ -0,0 +1,23 @@
-+/*
-+ * ILP32 system call wrappers
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License version 2 as
-+ * published by the Free Software Foundation.
-+ *
-+ * This program is distributed in the hope that it will be useful,
-+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-+ * GNU General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
-+ */
-+
-+#include <linux/linkage.h>
-+
-+ENTRY(ilp32_sys_rt_sigreturn_wrapper)
-+	mov	x0, sp
-+	b	ilp32_sys_rt_sigreturn
-+ENDPROC(ilp32_sys_rt_sigreturn_wrapper)
-+
-diff --git a/arch/arm64/kernel/signal.c b/arch/arm64/kernel/signal.c
-index b22e02a..4ddf00d 100644
---- a/arch/arm64/kernel/signal.c
-+++ b/arch/arm64/kernel/signal.c
-@@ -35,6 +35,7 @@
- #include <asm/signal32.h>
- #include <asm/vdso.h>
- #include <asm/signal_common.h>
-+#include <asm/signal_ilp32.h>
- 
- struct sigframe {
- 	struct ucontext uc;
-@@ -323,6 +324,8 @@ static void handle_signal(struct ksignal *ksig, struct pt_regs *regs)
- 			ret = compat_setup_rt_frame(usig, ksig, oldset, regs);
- 		else
- 			ret = compat_setup_frame(usig, ksig, oldset, regs);
-+	} else if (is_ilp32_compat_task()) {
-+		ret = ilp32_setup_rt_frame(usig, ksig, oldset, regs);
- 	} else {
- 		ret = setup_rt_frame(usig, ksig, oldset, regs);
- 	}
-diff --git a/arch/arm64/kernel/signal_ilp32.c b/arch/arm64/kernel/signal_ilp32.c
-new file mode 100644
-index 0000000..841e8f8
---- /dev/null
-+++ b/arch/arm64/kernel/signal_ilp32.c
-@@ -0,0 +1,192 @@
-+/*
-+ * Based on arch/arm/kernel/signal.c
-+ *
-+ * Copyright (C) 1995-2009 Russell King
-+ * Copyright (C) 2012 ARM Ltd.
-+ * Copyright (C) 2016 Cavium Networks.
-+ * Yury Norov <ynorov@caviumnetworks.com>
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License version 2 as
-+ * published by the Free Software Foundation.
-+ *
-+ * This program is distributed in the hope that it will be useful,
-+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-+ * GNU General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
-+ */
-+
-+#include <linux/compat.h>
-+#include <linux/signal.h>
-+#include <linux/syscalls.h>
-+#include <linux/ratelimit.h>
-+
-+#include <asm/esr.h>
-+#include <asm/fpsimd.h>
-+#include <asm/signal32_common.h>
-+#include <asm/signal_common.h>
-+#include <asm/uaccess.h>
-+#include <asm/unistd.h>
-+#include <asm/ucontext.h>
-+
-+
-+struct ilp32_ucontext {
-+        u32		uc_flags;
-+        u32		uc_link;
-+        compat_stack_t  uc_stack;
-+        compat_sigset_t uc_sigmask;
-+        /* glibc uses a 1024-bit sigset_t */
-+        __u8            __unused[1024 / 8 - sizeof(compat_sigset_t)];
-+        /* last for future expansion */
-+        struct sigcontext uc_mcontext;
-+};
-+
-+struct ilp32_sigframe {
-+	struct ilp32_ucontext uc;
-+	u64 fp;
-+	u64 lr;
-+};
-+
-+struct ilp32_rt_sigframe {
-+	struct compat_siginfo info;
-+	struct ilp32_sigframe sig;
-+};
-+
-+static inline int put_sigset_t(compat_sigset_t __user *uset, sigset_t *set)
-+{
-+	compat_sigset_t cset;
-+
-+	cset.sig[0] = set->sig[0] & 0xffffffffull;
-+	cset.sig[1] = set->sig[0] >> 32;
-+
-+	return copy_to_user(uset, &cset, sizeof(*uset));
-+}
-+
-+static inline int get_sigset_t(sigset_t *set,
-+                               const compat_sigset_t __user *uset)
-+{
-+	compat_sigset_t s32;
-+
-+	if (copy_from_user(&s32, uset, sizeof(*uset)))
-+		return -EFAULT;
-+
-+	set->sig[0] = s32.sig[0] | (((long)s32.sig[1]) << 32);
-+	return 0;
-+}
-+
-+static int restore_ilp32_sigframe(struct pt_regs *regs,
-+                            struct ilp32_sigframe __user *sf)
-+{
-+	sigset_t set;
-+	int err;
-+	err = get_sigset_t(&set, &sf->uc.uc_sigmask);
-+	if (err == 0)
-+		set_current_blocked(&set);
-+	err |= restore_sigcontext(regs, &sf->uc.uc_mcontext);
-+	return err;
-+}
-+
-+static int setup_ilp32_sigframe(struct ilp32_sigframe __user *sf,
-+                          struct pt_regs *regs, sigset_t *set)
-+{
-+	int err = 0;
-+	/* set up the stack frame for unwinding */
-+	__put_user_error(regs->regs[29], &sf->fp, err);
-+	__put_user_error(regs->regs[30], &sf->lr, err);
-+
-+	err |= put_sigset_t(&sf->uc.uc_sigmask, set);
-+	err |= setup_sigcontext(&sf->uc.uc_mcontext, regs);
-+	return err;
-+}
-+
-+asmlinkage long ilp32_sys_rt_sigreturn(struct pt_regs *regs)
-+{
-+	struct ilp32_rt_sigframe __user *frame;
-+
-+	/* Always make any pending restarted system calls return -EINTR */
-+	current->restart_block.fn = do_no_restart_syscall;
-+
-+	/*
-+	 * Since we stacked the signal on a 128-bit boundary,
-+	 * then 'sp' should be word aligned here.  If it's
-+	 * not, then the user is trying to mess with us.
-+	 */
-+	if (regs->sp & 15)
-+		goto badframe;
-+
-+	frame = (struct ilp32_rt_sigframe __user *)regs->sp;
-+
-+	if (!access_ok(VERIFY_READ, frame, sizeof (*frame)))
-+		goto badframe;
-+
-+	if (restore_ilp32_sigframe(regs, &frame->sig))
-+		goto badframe;
-+
-+	if (compat_restore_altstack(&frame->sig.uc.uc_stack))
-+		goto badframe;
-+
-+	return regs->regs[0];
-+
-+badframe:
-+	if (show_unhandled_signals)
-+		pr_info_ratelimited("%s[%d]: bad frame in %s: pc=%08llx sp=%08llx\n",
-+				    current->comm, task_pid_nr(current), __func__,
-+				    regs->pc, regs->compat_sp);
-+	force_sig(SIGSEGV, current);
-+	return 0;
-+}
-+
-+static struct ilp32_rt_sigframe __user *ilp32_get_sigframe(struct ksignal *ksig,
-+					       struct pt_regs *regs)
-+{
-+	unsigned long sp, sp_top;
-+	struct ilp32_rt_sigframe __user *frame;
-+
-+	sp = sp_top = sigsp(regs->sp, ksig);
-+
-+	sp = (sp - sizeof(struct ilp32_rt_sigframe)) & ~15;
-+	frame = (struct ilp32_rt_sigframe __user *)sp;
-+
-+	/*
-+	 * Check that we can actually write to the signal frame.
-+	 */
-+	if (!access_ok(VERIFY_WRITE, frame, sp_top - sp))
-+		frame = NULL;
-+
-+	return frame;
-+}
-+
-+/*
-+ * ILP32 signal handling routines called from signal.c
-+ */
-+int ilp32_setup_rt_frame(int usig, struct ksignal *ksig,
-+			  sigset_t *set, struct pt_regs *regs)
-+{
-+	struct ilp32_rt_sigframe __user *frame;
-+	int err = 0;
-+
-+	frame = ilp32_get_sigframe(ksig, regs);
-+
-+	if (!frame)
-+		return 1;
-+
-+	err |= copy_siginfo_to_user32(&frame->info, &ksig->info);
-+
-+	__put_user_error(0, &frame->sig.uc.uc_flags, err);
-+	__put_user_error(0, &frame->sig.uc.uc_link, err);
-+
-+	err |= __compat_save_altstack(&frame->sig.uc.uc_stack, regs->sp);
-+	err |= setup_ilp32_sigframe(&frame->sig, regs, set);
-+	if (err == 0) {
-+		setup_return(regs, &ksig->ka, frame,
-+				offsetof(struct ilp32_rt_sigframe, sig), usig);
-+		regs->regs[1] = (unsigned long)&frame->info;
-+		regs->regs[2] = (unsigned long)&frame->sig.uc;
-+	}
-+
-+	return err;
-+}
-+
-diff --git a/arch/arm64/kernel/sys_ilp32.c b/arch/arm64/kernel/sys_ilp32.c
-index d4cd2a9..a31d538 100644
---- a/arch/arm64/kernel/sys_ilp32.c
-+++ b/arch/arm64/kernel/sys_ilp32.c
-@@ -65,6 +65,9 @@ static unsigned long compat_sys_pwrite64(unsigned int fd,
- 	return sys_pwrite64(fd, (char *) ubuf, count, offset);
- }
- 
-+asmlinkage long ilp32_sys_rt_sigreturn_wrapper(void);
-+#define compat_sys_rt_sigreturn        ilp32_sys_rt_sigreturn_wrapper
-+
- #include <asm/syscall.h>
- 
- #undef __SYSCALL
--- 
-1.9.1
-
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0022-arm64-ilp32-add-vdso-ilp32-and-use-for-signal-return.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0022-arm64-ilp32-add-vdso-ilp32-and-use-for-signal-return.patch
deleted file mode 100644
index a5f9ac2..0000000
--- a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0022-arm64-ilp32-add-vdso-ilp32-and-use-for-signal-return.patch
+++ /dev/null
@@ -1,540 +0,0 @@
-From 8c5fd53b61fbf3d02fd801b37e958b8100f6e8d7 Mon Sep 17 00:00:00 2001
-From: Philipp Tomsich <philipp.tomsich@theobroma-systems.com>
-Date: Tue, 24 May 2016 03:04:51 +0300
-Subject: [PATCH 22/24] arm64:ilp32: add vdso-ilp32 and use for signal return
-
-ILP32 VDSO exports next symbols:
- __kernel_rt_sigreturn;
- __kernel_gettimeofday;
- __kernel_clock_gettime;
- __kernel_clock_getres;
-
-What shared object to use, kernel selects depending on result of
-is_ilp32_compat_task() in arch/arm64/kernel/vdso.c, so it substitutes
-correct pages and spec.
-
-Adjusted to move the move data page before code pages in sync with
-commit 601255ae3c98fdeeee3a8bb4696425e4f868b4f1
-
-Signed-off-by: Philipp Tomsich <philipp.tomsich@theobroma-systems.com>
-Signed-off-by: Christoph Muellner <christoph.muellner@theobroma-systems.com>
-Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
----
- arch/arm64/include/asm/vdso.h                 |  6 ++
- arch/arm64/kernel/Makefile                    |  7 ++
- arch/arm64/kernel/asm-offsets.c               |  7 ++
- arch/arm64/kernel/signal.c                    |  2 +
- arch/arm64/kernel/vdso-ilp32/.gitignore       |  2 +
- arch/arm64/kernel/vdso-ilp32/Makefile         | 74 +++++++++++++++++++++
- arch/arm64/kernel/vdso-ilp32/vdso-ilp32.S     | 33 ++++++++++
- arch/arm64/kernel/vdso-ilp32/vdso-ilp32.lds.S | 95 +++++++++++++++++++++++++++
- arch/arm64/kernel/vdso.c                      | 61 ++++++++++++++---
- arch/arm64/kernel/vdso/gettimeofday.S         | 20 +++++-
- 10 files changed, 294 insertions(+), 13 deletions(-)
- create mode 100644 arch/arm64/kernel/vdso-ilp32/.gitignore
- create mode 100644 arch/arm64/kernel/vdso-ilp32/Makefile
- create mode 100644 arch/arm64/kernel/vdso-ilp32/vdso-ilp32.S
- create mode 100644 arch/arm64/kernel/vdso-ilp32/vdso-ilp32.lds.S
-
-diff --git a/arch/arm64/include/asm/vdso.h b/arch/arm64/include/asm/vdso.h
-index 839ce00..649a9a4 100644
---- a/arch/arm64/include/asm/vdso.h
-+++ b/arch/arm64/include/asm/vdso.h
-@@ -29,6 +29,12 @@
- 
- #include <generated/vdso-offsets.h>
- 
-+#ifdef CONFIG_ARM64_ILP32
-+#include <generated/vdso-ilp32-offsets.h>
-+#else
-+#define vdso_offset_sigtramp_ilp32
-+#endif
-+
- #define VDSO_SYMBOL(base, name)						   \
- ({									   \
- 	(void *)(vdso_offset_##name - VDSO_LBASE + (unsigned long)(base)); \
-diff --git a/arch/arm64/kernel/Makefile b/arch/arm64/kernel/Makefile
-index 9c91b8c..3a25b57 100644
---- a/arch/arm64/kernel/Makefile
-+++ b/arch/arm64/kernel/Makefile
-@@ -47,6 +47,7 @@ arm64-obj-$(CONFIG_ACPI)		+= acpi.o
- arm64-obj-$(CONFIG_ARM64_ACPI_PARKING_PROTOCOL)	+= acpi_parking_protocol.o
- 
- obj-y					+= $(arm64-obj-y) vdso/
-+obj-$(CONFIG_ARM64_ILP32)		+= vdso-ilp32/
- obj-m					+= $(arm64-obj-m)
- head-y					:= head.o
- extra-y					+= $(head-y) vmlinux.lds
-@@ -54,3 +55,9 @@ extra-y					+= $(head-y) vmlinux.lds
- # vDSO - this must be built first to generate the symbol offsets
- $(call objectify,$(arm64-obj-y)): $(obj)/vdso/vdso-offsets.h
- $(obj)/vdso/vdso-offsets.h: $(obj)/vdso
-+
-+ifeq ($(CONFIG_ARM64_ILP32),y)
-+# vDSO - this must be built first to generate the symbol offsets
-+$(call objectify,$(arm64-obj-y)): $(obj)/vdso-ilp32/vdso-ilp32-offsets.h
-+$(obj)/vdso-ilp32/vdso-ilp32-offsets.h: $(obj)/vdso-ilp32
-+endif
-diff --git a/arch/arm64/kernel/asm-offsets.c b/arch/arm64/kernel/asm-offsets.c
-index 0d4f1e7..4e07a26 100644
---- a/arch/arm64/kernel/asm-offsets.c
-+++ b/arch/arm64/kernel/asm-offsets.c
-@@ -100,6 +100,13 @@ int main(void)
-   DEFINE(TSPEC_TV_SEC,		offsetof(struct timespec, tv_sec));
-   DEFINE(TSPEC_TV_NSEC,		offsetof(struct timespec, tv_nsec));
-   BLANK();
-+#ifdef CONFIG_COMPAT
-+  DEFINE(COMPAT_TVAL_TV_SEC,	offsetof(struct compat_timeval, tv_sec));
-+  DEFINE(COMPAT_TVAL_TV_USEC,	offsetof(struct compat_timeval, tv_usec));
-+  DEFINE(COMPAT_TSPEC_TV_SEC,	offsetof(struct compat_timespec, tv_sec));
-+  DEFINE(COMPAT_TSPEC_TV_NSEC,	offsetof(struct compat_timespec, tv_nsec));
-+  BLANK();
-+#endif
-   DEFINE(TZ_MINWEST,		offsetof(struct timezone, tz_minuteswest));
-   DEFINE(TZ_DSTTIME,		offsetof(struct timezone, tz_dsttime));
-   BLANK();
-diff --git a/arch/arm64/kernel/signal.c b/arch/arm64/kernel/signal.c
-index 4ddf00d..c458494 100644
---- a/arch/arm64/kernel/signal.c
-+++ b/arch/arm64/kernel/signal.c
-@@ -264,6 +264,8 @@ void setup_return(struct pt_regs *regs, struct k_sigaction *ka,
- 
- 	if (ka->sa.sa_flags & SA_RESTORER)
- 		sigtramp = ka->sa.sa_restorer;
-+	else if (is_ilp32_compat_task())
-+		sigtramp = VDSO_SYMBOL(current->mm->context.vdso, sigtramp_ilp32);
- 	else
- 		sigtramp = VDSO_SYMBOL(current->mm->context.vdso, sigtramp);
- 
-diff --git a/arch/arm64/kernel/vdso-ilp32/.gitignore b/arch/arm64/kernel/vdso-ilp32/.gitignore
-new file mode 100644
-index 0000000..61806c3
---- /dev/null
-+++ b/arch/arm64/kernel/vdso-ilp32/.gitignore
-@@ -0,0 +1,2 @@
-+vdso-ilp32.lds
-+vdso-ilp32-offsets.h
-diff --git a/arch/arm64/kernel/vdso-ilp32/Makefile b/arch/arm64/kernel/vdso-ilp32/Makefile
-new file mode 100644
-index 0000000..0671e88
---- /dev/null
-+++ b/arch/arm64/kernel/vdso-ilp32/Makefile
-@@ -0,0 +1,74 @@
-+#
-+# Building a vDSO image for AArch64.
-+#
-+# Author: Will Deacon <will.deacon@arm.com>
-+# Heavily based on the vDSO Makefiles for other archs.
-+#
-+
-+obj-ilp32-vdso := gettimeofday-ilp32.o note-ilp32.o sigreturn-ilp32.o
-+
-+# Build rules
-+targets := $(obj-ilp32-vdso) vdso-ilp32.so vdso-ilp32.so.dbg
-+obj-ilp32-vdso := $(addprefix $(obj)/, $(obj-ilp32-vdso))
-+
-+ccflags-y := -shared -fno-common -fno-builtin
-+ccflags-y += -nostdlib -Wl,-soname=linux-ilp32-vdso.so.1 \
-+		$(call cc-ldoption, -Wl$(comma)--hash-style=sysv)
-+
-+obj-y += vdso-ilp32.o
-+extra-y += vdso-ilp32.lds vdso-ilp32-offsets.h
-+CPPFLAGS_vdso-ilp32.lds += -P -C -U$(ARCH) -mabi=ilp32
-+
-+# Force dependency (incbin is bad)
-+$(obj)/vdso-ilp32.o : $(obj)/vdso-ilp32.so
-+
-+# Link rule for the .so file, .lds has to be first
-+$(obj)/vdso-ilp32.so.dbg: $(src)/vdso-ilp32.lds $(obj-ilp32-vdso)
-+	$(call if_changed,vdso-ilp32ld)
-+
-+# Strip rule for the .so file
-+$(obj)/%.so: OBJCOPYFLAGS := -S
-+$(obj)/%.so: $(obj)/%.so.dbg FORCE
-+	$(call if_changed,objcopy)
-+
-+# Generate VDSO offsets using helper script
-+gen-vdsosym := $(srctree)/$(src)/../vdso/gen_vdso_offsets.sh
-+quiet_cmd_vdsosym = VDSOSYM $@
-+define cmd_vdsosym
-+	$(NM) $< | $(gen-vdsosym) | LC_ALL=C sort > $@ && \
-+	cp $@ include/generated/
-+endef
-+
-+$(obj)/vdso-ilp32-offsets.h: $(obj)/vdso-ilp32.so.dbg FORCE
-+	$(call if_changed,vdsosym)
-+
-+# Assembly rules for the .S files
-+#$(obj-ilp32-vdso): %.o: $(src)/../vdso/$(subst -ilp32,,%.S)
-+#	$(call if_changed_dep,vdso-ilp32as)
-+
-+$(obj)/gettimeofday-ilp32.o: $(src)/../vdso/gettimeofday.S
-+	$(call if_changed_dep,vdso-ilp32as)
-+
-+$(obj)/note-ilp32.o: $(src)/../vdso/note.S
-+	$(call if_changed_dep,vdso-ilp32as)
-+
-+# This one should be fine because ILP32 uses the same generic
-+# __NR_rt_sigreturn syscall number.
-+$(obj)/sigreturn-ilp32.o: $(src)/../vdso/sigreturn.S
-+	$(call if_changed_dep,vdso-ilp32as)
-+
-+# Actual build commands
-+quiet_cmd_vdso-ilp32ld = VDSOILP32L $@
-+      cmd_vdso-ilp32ld = $(CC) $(c_flags) -mabi=ilp32  -Wl,-n -Wl,-T $^ -o $@
-+quiet_cmd_vdso-ilp32as = VDSOILP32A $@
-+      cmd_vdso-ilp32as = $(CC) $(a_flags) -mabi=ilp32 -c -o $@ $<
-+
-+# Install commands for the unstripped file
-+quiet_cmd_vdso_install = INSTALL $@
-+      cmd_vdso_install = cp $(obj)/$@.dbg $(MODLIB)/vdso/$@
-+
-+vdso-ilp32.so: $(obj)/vdso-ilp32.so.dbg
-+	@mkdir -p $(MODLIB)/vdso
-+	$(call cmd,vdso_install)
-+
-+vdso_install: vdso-ilp32.so
-diff --git a/arch/arm64/kernel/vdso-ilp32/vdso-ilp32.S b/arch/arm64/kernel/vdso-ilp32/vdso-ilp32.S
-new file mode 100644
-index 0000000..46ac072
---- /dev/null
-+++ b/arch/arm64/kernel/vdso-ilp32/vdso-ilp32.S
-@@ -0,0 +1,33 @@
-+/*
-+ * Copyright (C) 2012 ARM Limited
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License version 2 as
-+ * published by the Free Software Foundation.
-+ *
-+ * This program is distributed in the hope that it will be useful,
-+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-+ * GNU General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
-+ *
-+ * Author: Will Deacon <will.deacon@arm.com>
-+ */
-+
-+#include <linux/init.h>
-+#include <linux/linkage.h>
-+#include <linux/const.h>
-+#include <asm/page.h>
-+
-+	__PAGE_ALIGNED_DATA
-+
-+	.globl vdso_ilp32_start, vdso_ilp32_end
-+	.balign PAGE_SIZE
-+vdso_ilp32_start:
-+	.incbin "arch/arm64/kernel/vdso-ilp32/vdso-ilp32.so"
-+	.balign PAGE_SIZE
-+vdso_ilp32_end:
-+
-+	.previous
-diff --git a/arch/arm64/kernel/vdso-ilp32/vdso-ilp32.lds.S b/arch/arm64/kernel/vdso-ilp32/vdso-ilp32.lds.S
-new file mode 100644
-index 0000000..1dde31f
---- /dev/null
-+++ b/arch/arm64/kernel/vdso-ilp32/vdso-ilp32.lds.S
-@@ -0,0 +1,95 @@
-+/*
-+ * GNU linker script for the VDSO library.
-+ *
-+ * Copyright (C) 2012 ARM Limited
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License version 2 as
-+ * published by the Free Software Foundation.
-+ *
-+ * This program is distributed in the hope that it will be useful,
-+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-+ * GNU General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
-+ *
-+ * Author: Will Deacon <will.deacon@arm.com>
-+ * Heavily based on the vDSO linker scripts for other archs.
-+ */
-+
-+#include <linux/const.h>
-+#include <asm/page.h>
-+#include <asm/vdso.h>
-+
-+SECTIONS
-+{
-+	PROVIDE(_vdso_data = . - PAGE_SIZE);
-+	. = VDSO_LBASE + SIZEOF_HEADERS;
-+
-+	.hash		: { *(.hash) }			:text
-+	.gnu.hash	: { *(.gnu.hash) }
-+	.dynsym		: { *(.dynsym) }
-+	.dynstr		: { *(.dynstr) }
-+	.gnu.version	: { *(.gnu.version) }
-+	.gnu.version_d	: { *(.gnu.version_d) }
-+	.gnu.version_r	: { *(.gnu.version_r) }
-+
-+	.note		: { *(.note.*) }		:text	:note
-+
-+	. = ALIGN(16);
-+
-+	.text		: { *(.text*) }			:text	=0xd503201f
-+	PROVIDE (__etext = .);
-+	PROVIDE (_etext = .);
-+	PROVIDE (etext = .);
-+
-+	.eh_frame_hdr	: { *(.eh_frame_hdr) }		:text	:eh_frame_hdr
-+	.eh_frame	: { KEEP (*(.eh_frame)) }	:text
-+
-+	.dynamic	: { *(.dynamic) }		:text	:dynamic
-+
-+	.rodata		: { *(.rodata*) }		:text
-+
-+	_end = .;
-+	PROVIDE(end = .);
-+
-+	/DISCARD/	: {
-+		*(.note.GNU-stack)
-+		*(.data .data.* .gnu.linkonce.d.* .sdata*)
-+		*(.bss .sbss .dynbss .dynsbss)
-+	}
-+}
-+
-+/*
-+ * We must supply the ELF program headers explicitly to get just one
-+ * PT_LOAD segment, and set the flags explicitly to make segments read-only.
-+ */
-+PHDRS
-+{
-+	text		PT_LOAD		FLAGS(5) FILEHDR PHDRS; /* PF_R|PF_X */
-+	dynamic		PT_DYNAMIC	FLAGS(4);		/* PF_R */
-+	note		PT_NOTE		FLAGS(4);		/* PF_R */
-+	eh_frame_hdr	PT_GNU_EH_FRAME;
-+}
-+
-+/*
-+ * This controls what symbols we export from the DSO.
-+ */
-+VERSION
-+{
-+	LINUX_4.6 {
-+	global:
-+		__kernel_rt_sigreturn;
-+		__kernel_gettimeofday;
-+		__kernel_clock_gettime;
-+		__kernel_clock_getres;
-+	local: *;
-+	};
-+}
-+
-+/*
-+ * Make the sigreturn code visible to the kernel.
-+ */
-+VDSO_sigtramp_ilp32		= __kernel_rt_sigreturn;
-diff --git a/arch/arm64/kernel/vdso.c b/arch/arm64/kernel/vdso.c
-index 26352a6..521a8e4 100644
---- a/arch/arm64/kernel/vdso.c
-+++ b/arch/arm64/kernel/vdso.c
-@@ -40,6 +40,12 @@ extern char vdso_start, vdso_end;
- static unsigned long vdso_pages;
- static struct page **vdso_pagelist;
- 
-+#ifdef CONFIG_ARM64_ILP32
-+extern char vdso_ilp32_start, vdso_ilp32_end;
-+static unsigned long vdso_ilp32_pages;
-+static struct page **vdso_ilp32_pagelist;
-+#endif
-+
- /*
-  * The vDSO data page.
-  */
-@@ -109,24 +115,29 @@ int aarch32_setup_vectors_page(struct linux_binprm *bprm, int uses_interp)
- }
- #endif /* CONFIG_AARCH32_EL0 */
- 
--static struct vm_special_mapping vdso_spec[2];
--
--static int __init vdso_init(void)
-+static int __init vdso_init_common(char *vdso_start, char *vdso_end,
-+					  unsigned long *vdso_pagesp,
-+					  struct page ***vdso_pagelistp,
-+					  struct vm_special_mapping* vdso_spec)
- {
- 	int i;
-+	unsigned long vdso_pages;
-+	struct page **vdso_pagelist;
- 
--	if (memcmp(&vdso_start, "\177ELF", 4)) {
-+	if (memcmp(vdso_start, "\177ELF", 4)) {
- 		pr_err("vDSO is not a valid ELF object!\n");
- 		return -EINVAL;
- 	}
- 
--	vdso_pages = (&vdso_end - &vdso_start) >> PAGE_SHIFT;
-+	vdso_pages = (vdso_end - vdso_start) >> PAGE_SHIFT;
-+	*vdso_pagesp = vdso_pages;
- 	pr_info("vdso: %ld pages (%ld code @ %p, %ld data @ %p)\n",
--		vdso_pages + 1, vdso_pages, &vdso_start, 1L, vdso_data);
-+		vdso_pages + 1, vdso_pages, vdso_start, 1L, vdso_data);
- 
- 	/* Allocate the vDSO pagelist, plus a page for the data. */
- 	vdso_pagelist = kcalloc(vdso_pages + 1, sizeof(struct page *),
- 				GFP_KERNEL);
-+	*vdso_pagelistp = vdso_pagelist;
- 	if (vdso_pagelist == NULL)
- 		return -ENOMEM;
- 
-@@ -135,7 +146,7 @@ static int __init vdso_init(void)
- 
- 	/* Grab the vDSO code pages. */
- 	for (i = 0; i < vdso_pages; i++)
--		vdso_pagelist[i + 1] = virt_to_page(&vdso_start + i * PAGE_SIZE);
-+		vdso_pagelist[i + 1] = virt_to_page(vdso_start + i * PAGE_SIZE);
- 
- 	/* Populate the special mapping structures */
- 	vdso_spec[0] = (struct vm_special_mapping) {
-@@ -150,16 +161,46 @@ static int __init vdso_init(void)
- 
- 	return 0;
- }
-+
-+static struct vm_special_mapping vdso_spec[2];
-+
-+static int __init vdso_init(void)
-+{
-+	return vdso_init_common(&vdso_start, &vdso_end,
-+				&vdso_pages, &vdso_pagelist,
-+				vdso_spec);
-+}
- arch_initcall(vdso_init);
- 
-+#ifdef CONFIG_ARM64_ILP32
-+static struct vm_special_mapping vdso_ilp32_spec[2];
-+
-+static int __init vdso_ilp32_init(void)
-+{
-+	return vdso_init_common(&vdso_ilp32_start, &vdso_ilp32_end,
-+				&vdso_ilp32_pages, &vdso_ilp32_pagelist,
-+				vdso_ilp32_spec);
-+}
-+arch_initcall(vdso_ilp32_init);
-+#endif
-+
- int arch_setup_additional_pages(struct linux_binprm *bprm,
- 				int uses_interp)
- {
- 	struct mm_struct *mm = current->mm;
- 	unsigned long vdso_base, vdso_text_len, vdso_mapping_len;
- 	void *ret;
-+	unsigned long pages = vdso_pages;
-+	struct vm_special_mapping *spec = vdso_spec;
-+
-+#ifdef CONFIG_ARM64_ILP32
-+	if (is_ilp32_compat_task()) {
-+	        pages = vdso_ilp32_pages;
-+	        spec = vdso_ilp32_spec;
-+	}
-+#endif
- 
--	vdso_text_len = vdso_pages << PAGE_SHIFT;
-+	vdso_text_len = pages << PAGE_SHIFT;
- 	/* Be sure to map the data page */
- 	vdso_mapping_len = vdso_text_len + PAGE_SIZE;
- 
-@@ -171,7 +212,7 @@ int arch_setup_additional_pages(struct linux_binprm *bprm,
- 	}
- 	ret = _install_special_mapping(mm, vdso_base, PAGE_SIZE,
- 				       VM_READ|VM_MAYREAD,
--				       &vdso_spec[0]);
-+				       &spec[0]);
- 	if (IS_ERR(ret))
- 		goto up_fail;
- 
-@@ -180,7 +221,7 @@ int arch_setup_additional_pages(struct linux_binprm *bprm,
- 	ret = _install_special_mapping(mm, vdso_base, vdso_text_len,
- 				       VM_READ|VM_EXEC|
- 				       VM_MAYREAD|VM_MAYWRITE|VM_MAYEXEC,
--				       &vdso_spec[1]);
-+				       &spec[1]);
- 	if (IS_ERR(ret))
- 		goto up_fail;
- 
-diff --git a/arch/arm64/kernel/vdso/gettimeofday.S b/arch/arm64/kernel/vdso/gettimeofday.S
-index efa79e8..a2d8a70 100644
---- a/arch/arm64/kernel/vdso/gettimeofday.S
-+++ b/arch/arm64/kernel/vdso/gettimeofday.S
-@@ -25,6 +25,16 @@
- #define NSEC_PER_SEC_LO16	0xca00
- #define NSEC_PER_SEC_HI16	0x3b9a
- 
-+#ifdef __LP64__
-+#define PTR_REG(n)	x##n
-+#define OFFSET(n)	n
-+#define DELOUSE(n)
-+#else
-+#define PTR_REG(n)	w##n
-+#define OFFSET(n)	COMPAT_##n
-+#define DELOUSE(n)	mov     w##n, w##n
-+#endif
-+
- vdso_data	.req	x6
- use_syscall	.req	w7
- seqcnt		.req	w8
-@@ -51,6 +61,8 @@ seqcnt		.req	w8
- /* int __kernel_gettimeofday(struct timeval *tv, struct timezone *tz); */
- ENTRY(__kernel_gettimeofday)
- 	.cfi_startproc
-+	DELOUSE(0)
-+	DELOUSE(1)
- 	mov	x2, x30
- 	.cfi_register x30, x2
- 
-@@ -68,7 +80,7 @@ ENTRY(__kernel_gettimeofday)
- 	mov	x13, #1000
- 	lsl	x13, x13, x12
- 	udiv	x11, x11, x13
--	stp	x10, x11, [x0, #TVAL_TV_SEC]
-+	stp	PTR_REG(10), PTR_REG(11), [x0, #OFFSET(TVAL_TV_SEC)]
- 2:
- 	/* If tz is NULL, return 0. */
- 	cbz	x1, 3f
-@@ -88,6 +100,7 @@ ENDPROC(__kernel_gettimeofday)
- /* int __kernel_clock_gettime(clockid_t clock_id, struct timespec *tp); */
- ENTRY(__kernel_clock_gettime)
- 	.cfi_startproc
-+	DELOUSE(1)
- 	cmp	w0, #CLOCK_REALTIME
- 	ccmp	w0, #CLOCK_MONOTONIC, #0x4, ne
- 	b.ne	2f
-@@ -159,7 +172,7 @@ ENTRY(__kernel_clock_gettime)
- 
- 6:	/* Store to the user timespec. */
- 	lsr	x11, x11, x12
--	stp	x10, x11, [x1, #TSPEC_TV_SEC]
-+	stp	PTR_REG(10), PTR_REG(11), [x1, #OFFSET(TSPEC_TV_SEC)]
- 	mov	x0, xzr
- 	ret
- 7:
-@@ -174,6 +187,7 @@ ENDPROC(__kernel_clock_gettime)
- /* int __kernel_clock_getres(clockid_t clock_id, struct timespec *res); */
- ENTRY(__kernel_clock_getres)
- 	.cfi_startproc
-+	DELOUSE(1)
- 	cmp	w0, #CLOCK_REALTIME
- 	ccmp	w0, #CLOCK_MONOTONIC, #0x4, ne
- 	b.ne	1f
-@@ -187,7 +201,7 @@ ENTRY(__kernel_clock_getres)
- 	ldr	x2, 6f
- 2:
- 	cbz	w1, 3f
--	stp	xzr, x2, [x1]
-+	stp	PTR_REG(zr), PTR_REG(2), [x1]
- 
- 3:	/* res == NULL. */
- 	mov	w0, wzr
--- 
-1.9.1
-
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0023-arm64-ilp32-add-ARM64_ILP32-to-Kconfig.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0023-arm64-ilp32-add-ARM64_ILP32-to-Kconfig.patch
deleted file mode 100644
index de4d108..0000000
--- a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0023-arm64-ilp32-add-ARM64_ILP32-to-Kconfig.patch
+++ /dev/null
@@ -1,54 +0,0 @@
-From eaf01aa3b78c41b3d2dfe6b08134013e428a7cff Mon Sep 17 00:00:00 2001
-From: Andrew Pinski <apinski@cavium.com>
-Date: Tue, 24 May 2016 03:04:52 +0300
-Subject: [PATCH 23/24] arm64:ilp32: add ARM64_ILP32 to Kconfig
-
-This patch adds the config option for ILP32.
-
-Signed-off-by: Andrew Pinski <Andrew.Pinski@caviumnetworks.com>
-Signed-off-by: Philipp Tomsich <philipp.tomsich@theobroma-systems.com>
-Signed-off-by: Christoph Muellner <christoph.muellner@theobroma-systems.com>
-Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
-Reviewed-by: David Daney <ddaney@caviumnetworks.com>
----
- arch/arm64/Kconfig | 12 +++++++++++-
- 1 file changed, 11 insertions(+), 1 deletion(-)
-
-diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
-index 9ce37af..2e14ec8 100644
---- a/arch/arm64/Kconfig
-+++ b/arch/arm64/Kconfig
-@@ -820,12 +820,13 @@ source "fs/Kconfig.binfmt"
- 
- config COMPAT
- 	bool
--	depends on AARCH32_EL0
-+	depends on AARCH32_EL0 || ARM64_ILP32
- 
- config AARCH32_EL0
- 	bool "Kernel support for 32-bit EL0"
- 	def_bool y
- 	depends on ARM64_4K_PAGES || EXPERT
-+	select COMPAT
- 	select HAVE_UID16
- 	select OLD_SIGSUSPEND3
- 	select COMPAT_OLD_SIGACTION
-@@ -841,6 +842,15 @@ config AARCH32_EL0
- 
- 	  If you want to execute 32-bit userspace applications, say Y.
- 
-+config ARM64_ILP32
-+	bool "Kernel support for ILP32"
-+	select COMPAT
-+	select COMPAT_WRAPPER
-+	help
-+	  This option enables support for AArch64 ILP32 user space.  ILP32
-+	  is an ABI where long and pointers are 32bits but it uses the AARCH64
-+	  instruction set.
-+
- config SYSVIPC_COMPAT
- 	def_bool y
- 	depends on COMPAT && SYSVIPC
--- 
-1.9.1
-
diff --git a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0024-fiz-set_personality-by-Catalin.patch b/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0024-fiz-set_personality-by-Catalin.patch
deleted file mode 100644
index ae927e7..0000000
--- a/meta/recipes-kernel/linux-libc-headers/linux-libc-headers/ilp32_4_4/0024-fiz-set_personality-by-Catalin.patch
+++ /dev/null
@@ -1,47 +0,0 @@
-From 3b32fa60e5fd606b7688831cf77b3a8963e24892 Mon Sep 17 00:00:00 2001
-From: Yury Norov <ynorov@caviumnetworks.com>
-Date: Wed, 18 May 2016 03:40:39 +0300
-Subject: [PATCH 24/24] fiz set_personality by Catalin
-
----
- arch/arm64/include/asm/uaccess.h | 2 +-
- fs/exec.c                        | 3 ++-
- 2 files changed, 3 insertions(+), 2 deletions(-)
-
-diff --git a/arch/arm64/include/asm/uaccess.h b/arch/arm64/include/asm/uaccess.h
-index b2ede967..c08e10f 100644
---- a/arch/arm64/include/asm/uaccess.h
-+++ b/arch/arm64/include/asm/uaccess.h
-@@ -58,7 +58,7 @@ extern int fixup_exception(struct pt_regs *regs);
- #define KERNEL_DS	(-1UL)
- #define get_ds()	(KERNEL_DS)
- 
--#define USER_DS		TASK_SIZE_64
-+#define USER_DS		TASK_SIZE
- #define get_fs()	(current_thread_info()->addr_limit)
- 
- static inline void set_fs(mm_segment_t fs)
-diff --git a/fs/exec.c b/fs/exec.c
-index 6f4e1e509..d612f28 100644
---- a/fs/exec.c
-+++ b/fs/exec.c
-@@ -1120,7 +1120,6 @@ int flush_old_exec(struct linux_binprm * bprm)
- 
- 	bprm->mm = NULL;		/* We're using it now */
- 
--	set_fs(USER_DS);
- 	current->flags &= ~(PF_RANDOMIZE | PF_FORKNOEXEC | PF_KTHREAD |
- 					PF_NOFREEZE | PF_NO_SETAFFINITY);
- 	flush_thread();
-@@ -1142,6 +1141,8 @@ EXPORT_SYMBOL(would_dump);
- 
- void setup_new_exec(struct linux_binprm * bprm)
- {
-+	/* set the address limit for the new executable */
-+	set_fs(USER_DS);
- 	arch_pick_mmap_layout(current->mm);
- 
- 	/* This is the point of no return */
--- 
-1.9.1
-
-- 
2.5.0

