From f2fcdef02265df5ce0a815c8d790ff9dbc301b41 Mon Sep 17 00:00:00 2001
From: Manish Jaggi <mjaggi@cavium.com>
Date: Mon, 19 Dec 2016 22:47:55 -0800
Subject: [PATCH 3/7] Add ILP32 support to gdb.

This patch adds AARCH64:ilp32 support to gdb and sets
up the correct sizes for some types like pointers and long.
Also sets up the correct linker map offsets for Linux.

2016-08-30  Andrew Pinski  <apinski@cavium.com>

        * aarch64-tdep.h (gdbarch_tdep): Add ilp32 field.
        * aarch64-tdep.c (aarch64_gdbarch_init): Setup ILP32 support.
        Make sure the gdbarches have compatible ilp32 flags.
        Set long and ptr sizes correctly for ilp32.
        * aarch64-linux-tdep.c (aarch64_linux_init_abi):
        Add support for ILP32.
---
 gdb/aarch64-linux-tdep.c |  8 ++++++--
 gdb/aarch64-tdep.c       | 14 ++++++++++++--
 gdb/aarch64-tdep.h       |  3 +++
 3 files changed, 21 insertions(+), 4 deletions(-)

diff --git a/gdb/aarch64-linux-tdep.c b/gdb/aarch64-linux-tdep.c
index f8cf43e..7702581 100644
--- a/gdb/aarch64-linux-tdep.c
+++ b/gdb/aarch64-linux-tdep.c
@@ -952,8 +952,12 @@ aarch64_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
 
   linux_init_abi (info, gdbarch);
 
-  set_solib_svr4_fetch_link_map_offsets (gdbarch,
-					 svr4_lp64_fetch_link_map_offsets);
+  if (tdep->ilp32)
+    set_solib_svr4_fetch_link_map_offsets (gdbarch,
+					   svr4_ilp32_fetch_link_map_offsets);
+  else
+    set_solib_svr4_fetch_link_map_offsets (gdbarch,
+					   svr4_lp64_fetch_link_map_offsets);
 
   /* Enable TLS support.  */
   set_gdbarch_fetch_tls_load_module_address (gdbarch,
diff --git a/gdb/aarch64-tdep.c b/gdb/aarch64-tdep.c
index 9650a7a..ac3b0ee 100644
--- a/gdb/aarch64-tdep.c
+++ b/gdb/aarch64-tdep.c
@@ -2609,6 +2609,12 @@ aarch64_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
   const struct tdesc_feature *feature;
   int num_regs = 0;
   int num_pseudo_regs = 0;
+  char ilp32 = FALSE;
+
+  if (info.abfd
+      && bfd_get_flavour (info.abfd) == bfd_target_elf_flavour
+      && bfd_arch_bits_per_address (info.abfd) == 32)
+    ilp32 = TRUE;
 
   /* Ensure we always have a target descriptor.  */
   if (!tdesc_has_registers (tdesc))
@@ -2666,6 +2672,9 @@ aarch64_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
        best_arch != NULL;
        best_arch = gdbarch_list_lookup_by_info (best_arch->next, &info))
     {
+      /* ILP32 and LP64 are incompatible. */
+      if (gdbarch_tdep (arches->gdbarch)->ilp32 != ilp32)
+	continue;
       /* Found a match.  */
       break;
     }
@@ -2684,6 +2693,7 @@ aarch64_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
   tdep->lowest_pc = 0x20;
   tdep->jb_pc = -1;		/* Longjump support not enabled by default.  */
   tdep->jb_elt_size = 8;
+  tdep->ilp32 = ilp32;
 
   set_gdbarch_push_dummy_call (gdbarch, aarch64_push_dummy_call);
   set_gdbarch_frame_align (gdbarch, aarch64_frame_align);
@@ -2723,9 +2733,9 @@ aarch64_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
   set_gdbarch_float_bit (gdbarch, 32);
   set_gdbarch_double_bit (gdbarch, 64);
   set_gdbarch_long_double_bit (gdbarch, 128);
-  set_gdbarch_long_bit (gdbarch, 64);
+  set_gdbarch_long_bit (gdbarch, ilp32 ? 32 : 64);
   set_gdbarch_long_long_bit (gdbarch, 64);
-  set_gdbarch_ptr_bit (gdbarch, 64);
+  set_gdbarch_ptr_bit (gdbarch, ilp32 ? 32 : 64);
   set_gdbarch_char_signed (gdbarch, 0);
   set_gdbarch_float_format (gdbarch, floatformats_ieee_single);
   set_gdbarch_double_format (gdbarch, floatformats_ieee_double);
diff --git a/gdb/aarch64-tdep.h b/gdb/aarch64-tdep.h
index af209a9..14b7fbd 100644
--- a/gdb/aarch64-tdep.h
+++ b/gdb/aarch64-tdep.h
@@ -89,6 +89,9 @@ struct gdbarch_tdep
   struct type *vnh_type;
   struct type *vnb_type;
 
+  /* If this is ILP32 or LP64 */
+  char ilp32;
+
   /* syscall record.  */
   int (*aarch64_syscall_record) (struct regcache *regcache, unsigned long svc_number);
 };
-- 
2.5.0

